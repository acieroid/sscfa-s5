// Expected: undefined
{let (%ObjectProto = {[#proto: null, #class: "Object", #extensible: true,]})
{let (%global = {[#proto: %ObjectProto,
                  #class: "Object",
                  #extensible: true,]})
{let (%globalContext = {[#proto: %global,
                         #class: "Object",
                         #extensible: true,]})
{let (%ErrorProto = {[#proto: %ObjectProto,
                      #class: "Error",
                      #extensible: true,]})
{let (%ReferenceErrorProto = {[#proto: %ErrorProto,
                               #class: "Object",
                               #extensible: true,]})
{let (%JSError = func(err)
                 {{[#proto: null,
                    #class: "Object",
                    #extensible: true,]
                   '%js-exn' : {#value (err) ,
                                #writable false ,
                                #configurable false}}})
{let (isDataDescriptor = func(attr-obj)
                         {{let (%or = if (prim
                                      ("stx=", prim
                                      ("typeof", attr-obj
                                      ["value" , {[#proto: null,
                                      #class: "Object",
                                      #extensible: true,]}]) , "undefined"))
                                      {false}
                                      else
                                      {true})
                               if (%or)
                                  {%or}
                                  else
                                  if (prim
                                      ("stx=", prim
                                      ("typeof", attr-obj
                                      ["writable" , {[#proto: null,
                                      #class: "Object",
                                      #extensible: true,]}]) , "undefined"))
                                     {false}
                                     else
                                     {true}}})
{let (isAccessorDescriptor = func(attr-obj)
                             {{let (%or = if (prim
                                 ("stx=", prim
                                 ("typeof", attr-obj
                                 ["set" , {[#proto: null,
                                 #class: "Object",
                                 #extensible: true,]}]) , "undefined"))
                                 {false}
                                 else
                                 {true})
                                 if (%or)
                                 {%or}
                                 else
                                 if (prim
                                 ("stx=", prim
                                 ("typeof", attr-obj
                                 ["get" , {[#proto: null,
                                 #class: "Object",
                                 #extensible: true,]}]) , "undefined"))
                                 {false}
                                 else
                                 {true}}})
{let (%ToBoolean = func(x)
                   {prim("prim->bool", x)})
{let (%UnboundId = func(id)
                   {throw %JSError
                       ({[#proto: %ReferenceErrorProto,
                       #class: "Object",
                       #extensible: true,]
                       'message' : {#value (prim
                       ("string+", "Unbound identifier: " , id)) ,
                       #writable true ,
                       #configurable false}})})
{let (%ToPrimitiveNum = func
                  (obj)
                  {{let (check = func
                  (o , str)
                  {{let (valueOf = o[str , {[#proto: null,
                  #class: "Object",
                  #extensible: true,]}])
                  if (prim
                  ("stx=", prim
                  ("typeof", valueOf) , "function"))
                  {{let (str = valueOf
                  (o,
                  {[#proto: null,
                  #class: "Object",
                  #extensible: true,]}))
                  if (prim
                  ("primitive?", str))
                  {str}
                  else
                  {null}}}
                  else
                  {null}}})
                  {let (r1 = check
                  (obj,
                  "valueOf"))
                  if (if (prim
                  ("stx=", r1 , null))
                  {false}
                  else
                  {true})
                  {r1}
                  else
                  {{let (r2 = check
                  (obj,
                  "toString"))
                  if (if (prim
                  ("stx=", r2 , null))
                  {false}
                  else
                  {true})
                  {r2}
                  else
                  {%TypeError
                  ("valueOf and toString both absent in toPrimitiveNum")}}}}}})
{let (%ToPrimitiveStr = func
             (obj)
             {label ret :
             {{let (toString = obj
             ["toString" , {[#proto: null,
             #class: "Object",
             #extensible: true,]}])
             if (prim
             ("stx=", prim
             ("typeof", toString) , "function"))
             {{let (str = toString
             (obj,
             {[#proto: null,
             #class: "Object",
             #extensible: true,]}))
             if (prim
             ("primitive?", str))
             {break ret str}
             else
             {null}}}
             else
             {undefined}};
             {let (valueOf = obj
             ["valueOf" , {[#proto: null,
             #class: "Object",
             #extensible: true,]}])
             if (prim
             ("stx=", prim
             ("typeof", valueOf) , "function"))
             {{let (str = valueOf
             (obj,
             {[#proto: null,
             #class: "Object",
             #extensible: true,]}))
             if (prim
             ("primitive?", str))
             {break ret str}
             else
             {null}}}
             else
             {undefined}};
             %TypeError
             ("valueOf and toString both absent in toPrimitiveStr")}})
{let (%ToPrimitiveHint = func
        (val , hint)
        {{let (t = prim
        ("typeof", val))
        if ({let (%or = prim
        ("stx=", t , "function"))
        if (%or)
        {%or}
        else
        {prim
        ("stx=", t , "object")}})
        {if (prim
        ("stx=", hint , "string"))
        {%ToPrimitiveStr
        (val)}
        else
        {%ToPrimitiveNum
        (val)}}
        else
        {val}}})
{let (%ToPrimitive = func (val) {%ToPrimitiveHint (val, "number")})
{let (%ToString = func (val) {prim("prim->str", %ToPrimitiveHint(val,"string"))})
{let (%FunctionProto = {[#proto: %ObjectProto,
                         #code: func(this , args) {undefined},
                         #class: "Function",
                         #extensible: true,]
                         'length' : {#value (0.) ,
                                     #writable true ,
                                     #configurable false}})
{let (%makeGetter = func(object , id) {
   {[#proto: %FunctionProto,
     #code: func(this , args) {
              if (prim("hasProperty", object , id)) {
                object[id , {[#proto: null,
                              #class: "Object",
                              #extensible: true,]}]
              } else {
                %UnboundId(id)
              }
            },
   #class: "Object",
   #extensible: false,]}})
{let (%makeSetter = func(object , id) {
     {[#proto: %FunctionProto,
       #code: func(this , args) {
                try {
                  {let ($newVal = args["0" , {[#proto: null,
                                               #class: "Object",
                                               #extensible: true,]}])
                    object[id = $newVal , {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]
                                           '0' : {#value ($newVal) ,
                                                  #writable true ,
                                                  #configurable true}}]}
                } catch {
                  %UnwritableDispatch(id)}
                },
      #class: "Object",
      #extensible: false,]}})
{let (%defineOwnProperty = func
   (obj , field , attr-obj)
   {{let (t = prim
   ("typeof", obj))
   if (if (if (prim
   ("stx=", t , "object"))
   {false}
   else
   {true})
   {if (prim
   ("stx=", t , "function"))
   {false}
   else
   {true}}
   else
   {false})
   {throw "defineOwnProperty didn't get object"}
   else
   {undefined}};
   {let (fstr = %ToString
   (field))
   if (prim
   ("stx=", prim
   ("hasOwnProperty", obj , fstr) , false))
   {if (obj
   [<#extensible>])
   {obj
   [fstr
   <#configurable>=true];
   obj
   [fstr
   <#writable>=true];
   if (isDataDescriptor
   (attr-obj))
   {obj
   [fstr
   <#value>=attr-obj
   ["value" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]];
   obj
   [fstr
   <#writable>=%ToBoolean
   (attr-obj
   ["writable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}])]}
   else
   if (isAccessorDescriptor
   (attr-obj))
   {obj
   [fstr
   <#getter>=attr-obj
   ["get" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]];
   obj
   [fstr
   <#setter>=attr-obj
   ["set" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]]}
   else
   {undefined};
   obj
   [fstr
   <#enumerable>=%ToBoolean
   (attr-obj
   ["enumerable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}])];
   obj
   [fstr
   <#configurable>=%ToBoolean
   (attr-obj
   ["configurable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}])];
   true}
   else
   {%TypeError
   ("(defineOwnProperty) Attempt to add a property to a non-extensible object.")}}
   else
   {{let (current-prop = {[#proto: null,
   #class: "Object",
   #extensible: true,]
   'configurable' : {#value (obj
   [fstr <#configurable>]) ,
   #writable true ,
   #configurable false},
   'enumerable' : {#value (obj
   [fstr <#enumerable>]) ,
   #writable true ,
   #configurable false}})
   {if (prim
   ("isAccessor", obj , fstr))
   {{let ($newVal = obj
   [fstr <#getter>])
   current-prop
   ["get" = $newVal ,
   {[#proto: null,
   #class: "Object",
   #extensible: true,]
   '0' : {#value ($newVal) ,
   #writable true ,
   #configurable true}}]};
   {let ($newVal = obj
   [fstr <#setter>])
   current-prop
   ["set" = $newVal ,
   {[#proto: null,
   #class: "Object",
   #extensible: true,]
   '0' : {#value ($newVal) ,
   #writable true ,
   #configurable true}}]}}
   else
   {{let ($newVal = obj
   [fstr <#writable>])
   current-prop
   ["writable" = $newVal ,
   {[#proto: null,
   #class: "Object",
   #extensible: true,]
   '0' : {#value ($newVal) ,
   #writable true ,
   #configurable true}}]};
   {let ($newVal = obj
   [fstr <#value>])
   current-prop
   ["value" = $newVal ,
   {[#proto: null,
   #class: "Object",
   #extensible: true,]
   '0' : {#value ($newVal) ,
   #writable true ,
   #configurable true}}]}};
   if (prim
   ("stx=", obj
   [fstr <#configurable>] , false))
   {if (prim
   ("stx=", attr-obj
   ["configurable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , true))
   {%TypeError
   ("escalating configurable from false to true")}
   else
   if (prim
   ("stx=", attr-obj
   ["enumerable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , prim
   ("stx=", obj
   [fstr <#enumerable>] , false)))
   {%TypeError
   ("(defineOwnPoperty) Can't change enumerable of a non-configurable property")}
   else
   {undefined};
   if (if (prim
   ("stx=", isDataDescriptor
   (current-prop) , isDataDescriptor
   (attr-obj)))
   {false}
   else
   {true})
   {if (prim
   ("stx=", obj
   [fstr <#configurable>] , false))
   {%TypeError
   ("(defineOwnProperty) Non-configurable property")}
   else
   if (isDataDescriptor
   (current-prop))
   {copy-data-desc
   (current-prop,
   attr-obj)}
   else
   {copy-access-desc
   (current-prop,
   attr-obj)}}
   else
   {undefined}}
   else
   {undefined};
   if (if (isDataDescriptor
   (current-prop))
   {isDataDescriptor
   (attr-obj)}
   else
   {false})
   {if (prim
   ("stx=", current-prop
   ["configurable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , false))
   {if (prim
   ("stx=", current-prop
   ["writable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , false))
   {if (prim
   ("stx=", attr-obj
   ["writable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , true))
   {%TypeError
   ("(defineOwnProperty) Cannot escalate writable from false to true.")}
   else
   if (prim
   ("stx=", prim
   ("sameValue", attr-obj
   ["value" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , current-prop
   ["value" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]) , false))
   {%TypeError
   ("(defineOwnProperty) Cannot change a non-configurable value")}
   else
   {copy-data-desc
   (current-prop,
   attr-obj)}}
   else
   {copy-data-desc
   (current-prop,
   attr-obj)}}
   else
   {copy-data-desc
   (current-prop,
   attr-obj)}}
   else
   if (prim
   ("stx=", current-prop
   ["configurable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , false))
   {if ({let (%or = prim
   ("stx=", prim
   ("sameValue", current-prop
   ["set" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , attr-obj
   ["set" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]) , false))
   if (%or)
   {%or}
   else
   {prim
   ("stx=", prim
   ("sameValue", current-prop
   ["get" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}] , attr-obj
   ["get" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]) , false)}})
   {%TypeError
   (prim
   ("string+", "(defineOwnProperty) Cannot change setter or getter of non-configurable property " , fstr))}
   else
   {copy-access-desc
   (current-prop,
   attr-obj)}}
   else
   {copy-access-desc
   (current-prop,
   attr-obj)};
   if (isDataDescriptor
   (current-prop))
   {if (prim
   ("stx=", prim
   ("sameValue", obj
   [fstr <#value>] , current-prop
   ["value" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]) , false))
   {obj
   [fstr
   <#value>=current-prop
   ["value" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]]}
   else
   {undefined};
   if (if (prim
   ("stx=", obj
   [fstr <#writable>] , current-prop
   ["writable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]))
   {false}
   else
   {true})
   {obj
   [fstr
   <#writable>=current-prop
   ["writable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]]}
   else
   {undefined}}
   else
   if (isAccessorDescriptor
   (current-prop))
   {obj
   [fstr
   <#getter>=current-prop
   ["get" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]];
   obj
   [fstr
   <#setter>=current-prop
   ["set" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]]}
   else
   {undefined};
   if (if (prim
   ("stx=", obj
   [fstr <#enumerable>] , current-prop
   ["enumerable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]))
   {false}
   else
   {true})
   {obj
   [fstr
   <#enumerable>=current-prop
   ["enumerable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]]}
   else
   {undefined};
   if (if (prim
   ("stx=", obj
   [fstr <#configurable>] , current-prop
   ["configurable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]))
   {false}
   else
   {true})
   {obj
   [fstr
   <#configurable>=current-prop
   ["configurable" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]]}
   else
   {undefined};
   true}}}}})
{let (%defineGlobalAccessors = func(context , id) {
   %defineOwnProperty(%globalContext, id, {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]
                                          'get' : {#value (%makeGetter(%global, id)) ,
                                                   #writable true ,
                                                   #configurable false},
                                          'set' : {#value (%makeSetter(%global, id)) ,
                                                   #writable true ,
                                                   #configurable false},
                                          'enumerable' : {#value (true) ,
                                                          #writable false ,
                                                          #configurable false},
                                          'configurable' : {#value (true) ,
                                                            #writable true ,
                                                            #configurable false}})})
{let (%this = %global)
{let (%strictContext = %globalContext)
{let (%nonstrictContext = %globalContext)
{let (%printlambda = func
   (o , s)
   {prim
   ("print", %ToString
   (s["0" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]))})
{let (%print = {[#proto: %FunctionProto,
   #code: %printlambda,
   #class: "Object",
   #extensible: true,]})
{let (%FunctionConstructor = func
   (this , args)
   {{let (argCount = args
   ["length" , {[#proto: null,
   #class: "Object",
   #extensible: true,]}])
   rec (formArgString = func
   (n , result)
   {if (prim
   ("stx=", n , prim
   ("-", argCount , 1.)))
   {result}
   else
   {{let (currentArg = %ToString
   (args
   [prim
   ("prim->str", n) , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]))
   {let (next = if (prim
   ("stx=", n , prim
   ("-", argCount , 2.)))
   {prim
   ("string+", result , currentArg)}
   else
   {prim
   ("string+", prim
   ("string+", result , currentArg) , ",")})
   formArgString
   (prim
   ("+", n , 1.),
   next)}}}})
   {let (body = if (prim
   ("stx=", argCount , 0.))
   {""}
   else
   {args
   [prim
   ("prim->str", prim
   ("-", argCount , 1.)) , {[#proto: null,
   #class: "Object",
   #extensible: true,]}]})
   {let (P = if ({let (%or = prim
   ("stx=", argCount , 0.))
   if (%or)
   {%or}
   else
   {prim
   ("stx=", argCount , 1.)}})
   {""}
   else
   {formArgString
   (0.,
   "")})
   {let (prefix = prim
   ("string+", "((function(){ return function (" , prim
   ("string+", P , "){")))
   {let (final = prim
   ("string+", prefix , prim
   ("string+", body , "}; })());")))
   %evallambda
   (undefined,
   {[#proto: null,
   #class: "Object",
   #extensible: true,]
   '0' : {#value (final) ,
   #writable false ,
   #configurable false}})}}}}}})
{let (%FunctionGlobalFuncObj = {[#proto: %FunctionProto,
   #code: %FunctionConstructor,
   #class: "Object",
   #extensible: true,]
   'prototype' : {#value (%FunctionProto) ,
   #writable false ,
   #configurable false},
   'length' : {#value (0.) ,
   #writable false ,
   #configurable false}})
{{let ($newVal = %FunctionGlobalFuncObj)
   %FunctionProto ["constructor" = $newVal ,
                   {[#proto: null,
                     #class: "Object",
                     #extensible: true,]
                   '0' : {#value ($newVal) ,
                          #writable true ,
                          #configurable true}}]};
   %FunctionProto ["constructor"<#enumerable>=false];
   {let ($newVal = %global)
      %global["window" = $newVal ,
              {[#proto: null,
                #class: "Object",
                #extensible: true,]
              '0' : {#value ($newVal) ,
                     #writable true ,
                     #configurable true}}]};
   {let ($newVal = %print)
     %global["print" = $newVal ,
             {[#proto: null,
               #class: "Object",
               #extensible: true,]
             '0' : {#value ($newVal) ,
                    #writable true ,
                    #configurable true}}]};
   %ObjectProto["propertyIsEnumerable"<#enumerable>=false];
   {let (%ThrowTypeErrorFun = func(this , args)
      {{let (msg = args["0" , {[#proto: null,
                                #class: "Object",
                                #extensible: true,]}])
         throw %JSError(%MakeTypeError(msg))}})
   {let (%ThrowTypeError = {[#proto: %FunctionProto,
                             #code: %ThrowTypeErrorFun,
                             #class: "Function",
                             #extensible: false,]
                            'length' : {#value (0.) ,
                                        #writable false ,
                                        #configurable false}})
   {let (%mkArgsObjBase = func(args)
     {{let (keys = get-own-field-names(args))
     {let (argsObj = {[#proto: %ObjectProto,
     #class: "Arguments",
     #extensible: true,]
     'callee' : {#getter %ThrowTypeError ,
     #setter %ThrowTypeError},
     'caller' : {#getter %ThrowTypeError ,
     #setter %ThrowTypeError}})
     {argsObj
     ["callee"
     <#configurable>=false];
     argsObj
     ["caller"
     <#configurable>=false];
     rec (loop = func
     (iter)
     {{let (strx = %ToString
     (iter))
     if (prim
     ("hasOwnProperty", keys , strx))
     {%defineOwnProperty
     (argsObj,
     strx,
     {[#proto: null,
     #class: "Object",
     #extensible: true,]
     'value' : {#value (args
     [strx , {[#proto: null,
     #class: "Object",
     #extensible: true,]}]) ,
     #writable false ,
     #configurable false},
     'writable' : {#value (true) ,
     #writable false ,
     #configurable false},
     'configurable' : {#value (true) ,
     #writable false ,
     #configurable false},
     'enumerable' : {#value (true) ,
     #writable false ,
     #configurable false}});
     loop
     (prim
     ("+", iter , 1.))}
     else
     {%defineOwnProperty
     (argsObj,
     "length",
     {[#proto: null,
     #class: "Object",
     #extensible: true,]
     'value' : {#value (iter) ,
     #writable false ,
     #configurable false},
     'writable' : {#value (true) ,
     #writable false ,
     #configurable false},
     'configurable' : {#value (true) ,
     #writable false ,
     #configurable false},
     'enumerable' : {#value (false) ,
     #writable false ,
     #configurable false}})}}})
     {loop
     (0.);
     argsObj}}}}})
   {let (%mkArgsObj = func(args)
     {{let (argsObj = %mkArgsObjBase
     (args))
     {{let ($newVal = false)
     argsObj
     ["%new" = $newVal ,
     {[#proto: null,
     #class: "Object",
     #extensible: true,]
     '0' : {#value ($newVal) ,
     #writable true ,
     #configurable true}}]};
     argsObj
     ["%new"
     <#writable>=false];
     argsObj}}})
   {let (%context = %nonstrictContext)
     {%defineGlobalAccessors(%context,"print");
     {let (#strict = false)
     {let (%fun2 = %context["print" , {[#proto: null,
                                        #class: "Object",
                                        #extensible: true,]}])
     {let (%ftype3 = prim("typeof", %fun2))
        if (prim("!", prim("stx=", %ftype3 , "function")))
          {%TypeError("Not a function")}
        else
          {%fun2(undefined, %mkArgsObj({[#proto: null,
                                         #class: "Object",
                                         #extensible: true,]
                                       '0' : {#value ("foo") ,
                                              #writable true ,
                                              #configurable true}}))}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
