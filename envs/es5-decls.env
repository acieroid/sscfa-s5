// Taken from LambdaS5s envs/es5.env. It only contains the declarations of
// global values.

// If %throwUnboundIDErrors is false, we attempt to emulate non-strict mode
// behavior by assigning to the top-level context when the LHS of the assignment is
// an undeclared identifier.
let [%throwUnboundIDErrors] = false

// To be bound later
let [%makeGlobalEnv] = undefined

let [%ObjectProto] = { [#proto : null,] }

let [%global] = { [#proto : %ObjectProto,] }
let [%globalContext] = {[#proto: %global, #extensible: true,]}

let [%Immut] = func(obj, prop) {
  prim("pretty", obj);
  obj[prop<#enumerable> = false];
  obj[prop<#configurable> = false]
}

rec [%protoOfField] = func(object, fld) {
  if (object === null) { object }
  else if (prim("hasOwnProperty", object, fld)) { object }
  else { %protoOfField(object[<#proto>], fld) }
}

let [%isUnbound] = func(context, id) {
  %protoOfField(context, id) === %globalContext &&
  prim("!", prim("hasProperty", %global, id))
}

let [%FunctionProto] = {
  [#proto: %ObjectProto, #class : "Function", #code : func(this, args){ undefined },]
  "length" : {#value 0, #writable true} }

let [%functionToStringlambda] = func(this, args) {
  "function ToString"
}

let [%functionToString] =
  { [#code : %functionToStringlambda, #proto: %FunctionProto, #class: "Function",]
  "length" : {#value 0, #writable false, #configurable false, #enumerable false} }


let [%ErrorProto] = {[#proto : %ObjectProto, #class : "Error",]}

let [%TypeErrorProto] = { [#proto : %ErrorProto,] }

let [%MakeTypeError] = func(msg) {
  let (msg = if (typeof msg === 'object') { 'object passed to ThrowTypeError' }
             else { prim("prim->str", msg) })
  {[#proto : %TypeErrorProto,]
    message: {#value msg, #writable false} }
}

let [%IsJSError] = func(thing) {
  typeof thing === "object" && prim("hasOwnProperty", thing, "%js-exn")
}

let [%ToJSError] = func(maybe-js-error) {
  if (%IsJSError(maybe-js-error)) {
    maybe-js-error["%js-exn"]
  }
  else if (maybe-js-error === "unwritable-field") {
    %MakeTypeError("Field not writable")
  }
  else if (maybe-js-error === "unconfigurable-delete") {
    %MakeTypeError("Field not deletable")
  }
  else { throw maybe-js-error }
}

let [%JSError] = func(err) {
  { [] "%js-exn" : {#value err, #writable false} }
}

let [%ThrowTypeErrorFun] = func(this, args) {
  let (msg = args["0"])
  throw %JSError(%MakeTypeError(msg))
}

let [%ThrowTypeError] = {[
    #code: %ThrowTypeErrorFun,
    #proto: %FunctionProto,
    #extensible: false,
    #class: "Function",
  ]
  "length": {#value 0, #writable false}
}

let [%TypeError] = func(msg) {
  %ThrowTypeErrorFun(undefined, {[] "0": {#value msg, #writable false}})
}


// Errors that may be JavaScript and may be from the interpreter are
// handled here
let [%ErrorDispatch] = func(maybe-js-error) {
  if (%IsJSError(maybe-js-error)) { throw maybe-js-error }
  else if (maybe-js-error === "unwritable-field") {
    %TypeError("Field not writable")
  }
  else if (maybe-js-error === "unconfigurable-delete") {
    %TypeError("Field not deletable")
  }
  else { throw maybe-js-error }
}

let [%ReferenceErrorProto] = { [#proto : %ErrorProto,] }

let [%SyntaxErrorProto] = { [#proto : %ErrorProto,] }

let [%SyntaxError] = func(msg) {
  throw %JSError({[#proto: %SyntaxErrorProto,]
                  message: {#value msg, #writable false}})
}

let [%BooleanProto] =
  { [#proto : %ObjectProto, #class : "Boolean", #primval : false,]}


let [%NumberProto] = { [#proto : %ObjectProto, #class : "Number", #primval : 0,]}

let [%ToBoolean] = func(x) {
  prim("prim->bool", x)
}

let [%ObjectTypeCheck] = func(o) {
  let (t = prim("typeof", o))
  let (c1 = t !== "object")
  let (c2 = t !== "function")
  if (c1 && c2) {
    %TypeError(prim("string+", prim("prim->str", o), " is not an object"))
  } else { null }
}

let [%IsObject] = func(o) {
  let (t = prim("typeof", o))
  let (c1 = t === "object")
  let (c2 = t === "function")
  c1 || c2
}

let [%AppExprCheck] = func(fun, args) {
  if(typeof fun !== "function") {
    %TypeError("Not a function")
  } else {
    fun(undefined, args)
  }
}

// NOTE(joe): not complete, because window could just define getters that throw
//  This should intelligently determine when a variable is free
let [%Typeof] = func(context, id) {
  try { prim("typeof", context[id]) } catch { func(e) { 'undefined' } }
}


let [%instanceof] = func(l, r) {
  let (rtype = prim("typeof", r))
  let (ltype = prim("typeof", l))
  label ret: {
    if (rtype !== "function") {
      %TypeError("Non-function given to instanceof")
    } else { null };

    if (ltype !== "function" && ltype !== "object") {
      break ret false
    } else { null };

    let (O = r["prototype"])
    let (Otype = prim("typeof", O)) {
      if (Otype !== "function" && Otype !== "object") {
        %TypeError("Prototype was not function or object")
      } else { null };

      rec (search = func(v) {
        let (vp = v[<#proto>])
        if (vp === null) {
          false
        } else {
          if (O === vp) {
            true
          } else {
            search(vp)
          }
        }
      })
      break ret search(l)
    }
  }
}


let [%StringProto] = { [#proto : %ObjectProto, #class : "String", #primval : "",]
  "length" : {#value 0, #writable false}}

let [%StringIndices] = func(obj, s) {
  let (len = prim("strlen", s))
  rec (loop = func(i) {
    if (prim("<", i, len)) {
      obj[prim("prim->str", i) = prim("char-at", s, i)];
      loop(prim("+", i, 1))
    } else { undefined }
  })
  loop(0)
}

let [%ToObject] = func (o) {
    if (o === null) {
      %TypeError("%ToObject received null")
    } else {
        label ret : {
            let (t = prim("typeof", o)) {
        if (t === "object" || t === "function") {
            break ret o
        }
        else { null };
        if (t === "string") {
            let (obj =
             {[#class: "String",
                           #extensible: true,
                           #proto: %StringProto,
                           #primval: o,]
                "length" : {#value prim("strlen", o), #writable true}}) {
                %StringIndices(obj, o);
            break ret obj
            }
        }
        else { null };
        if (t === "number") {
            break ret
            {[#class: "Number",
                      #extensible: true,
                      #proto: %NumberProto,
                      #primval: o,]}
        }
        else { null };
        if (t === "boolean") {
            break ret
            {[#class: "Boolean",
                      #extensible: true,
                      #proto: %BooleanProto,
                      #primval: o,]}
        }
        else { null };
        if (t === "function") {
            break ret
            {[#class: "Function",
                      #extensible: true,
                      #proto: %BooleanProto,
                      #primval: o,]}
        }
        else { null };
        %TypeError("%ToObject received undefined")
        }
    }
    }
}

// See 11.2.1, step 2
// Property accessor semantics require us to throw a ReferenceError when the
// "object" part of the bracket expression is undefined.
let [%PropAccessorCheck] = func(o) {
  if (o === undefined) {
    throw %JSError({[#proto : %ReferenceErrorProto,]})
  } else {
    %ToObject(o)
  }
}


let [%UnboundId] = func(id) {
  throw %JSError(
    { [#proto : %ReferenceErrorProto,]
      "message": {#value prim("string+", "Unbound identifier: ", id), #writable true}
    }
  )
}

let [%ThrowReferenceError] = {
    [ #code : func(this, args) {
        throw %JSError({ [#proto : %ReferenceErrorProto,] })
      },]}

let [%SyntaxError] = func(msg) {
  throw %JSError({ [#proto : %SyntaxErrorProto,]
    "message": {#value prim("string+", "ReferenceError: ", msg),
                #writable true}})
}

let [%ThrowSyntaxError] = {
    [ #code : func(this, args) {
        throw %JSError({ [#proto : %SyntaxErrorProto,] })
      },
      #extensible: false,]}

let [%ToPrimitiveNum] = func(obj) {
  let (check = func(o, str) {
    let (valueOf = o[str])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(o, {[]}))
        if (prim("primitive?", str)) {
            str
        } else { null }
    } else { null }
  })
  let (r1 = check(obj, "valueOf"))
  if (r1 !== null) { r1 } else {
    let (r2 = check(obj, "toString"))
    if (r2 !== null) { r2 } else {
      %TypeError("valueOf and toString both absent in toPrimitiveNum")
    }
  }
}

let [%ToPrimitiveStr] = func(obj) {
    label ret : {
    let (toString = obj["toString"])
    if (prim("typeof", toString) === "function") {
            let (str = toString(obj, {[]})) {
        if (prim("primitive?", str)) {
                    break ret str
        }
        else { null }
            }
    };
    let (valueOf = obj["valueOf"])
    if (prim("typeof", valueOf) === "function") {
            let (str = valueOf(obj, {[]})) {
        if (prim("primitive?", str)) {
                    break ret str
        }
        else { null }
            }
    };
    %TypeError("valueOf and toString both absent in toPrimitiveStr")
    }
}

let [%ToPrimitiveHint] = func(val, hint) {
    let (t = prim("typeof", val))
    if(t === "function" || t === "object") {
        if(hint === "string") {
            %ToPrimitiveStr(val)
        }
        else {
            %ToPrimitiveNum(val)
        }
    }
    else {
        val
    }
}

let [%ToPrimitive] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}


let [%ToString] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

// NOTE(joe): in non-strict mode this will need to be changed This is not
// exactly 10.4.3 because getters and setters pass ToObject() forms of numbers.
// The real solution might be to have 4-place get/set methods
let [%resolveThis] = func(strict, obj) {
  if (strict) {
    if (typeof obj === 'object' && obj !== null) {
      let (klass = obj[<#class>])
      if ((klass === "Number" || klass === "String" || klass === "Boolean")
          && (obj !== %StringProto && obj !== %NumberProto && obj !== %BooleanProto)) {
        obj[<#primval>]
      } else {
        obj
      }
    } else {
      obj
    }
  } else {
    if ((obj === null) || (obj === undefined)) {
      %global
    } else {
      obj
    }
  }
}

let [%in] = func(l, r) {
  let (rtype = prim("typeof", r))
  if (rtype !== "object" && rtype !== "function") {
    %TypeError(prim("string+", %ToString(r), " is not an object"))
  } else {
    prim("hasProperty", r, %ToString(l))
  }
}

let [%ToNumber] = func(x) {
  rec (inner = func(x) {
    label ret: {
      let (t = prim("typeof", x)) {
        if (t === "number") {
          break ret x
        };

        if (x === undefined) {
          break ret NaN
        };

        if (x === null || x === false) {
          break ret 0
        };

        if (x === true) {
          break ret 1
        };

        if (t === "string") {
          break ret prim("numstr->num", x)
        };

        // else, a function or object
        break ret inner(%ToPrimitiveNum(x))
      }
    }
  })
  inner(x)
}

let [%ToInteger] = func(i) {
    label ret: {
  let (number = %ToNumber(i)) {
      if (number !== number) {
    break ret 0
      } else { null };
      if (number === 0 || number === +inf || number === -inf) {
    break ret number
      } else { null };
      // Why 0 - 1? No negative number literals (yet)
      let (sign = if (prim("<", number, 0)) { prim("-", 0, 1) } else { 1 })
      let (a = prim("abs", number))
      let (f = prim("floor", a))
      let (r = prim("*", sign, f))
      break ret r
  }
    }
}


let [%NumberConstructor] = func(this, args) {
  if (this === undefined) {
    if (args["length"] === 0) { 0 } else { %ToNumber(args["0"]) }
  } else {
    let (hasProp = prim("hasProperty", args, "0"))
    let (argUndef = args["0"] === undefined)
    let (v = if (hasProp && argUndef) { NaN }
             else if (argUndef) { 0 }
             else { %ToNumber(args["0"]) })
    { [#proto : %NumberProto, #class : "Number", #primval : v,] }
  }
}

let [%isNaNlambda] = func(this, args) {
    let (n = %ToNumber(args["0"]))
    n !== n
}

// 11.9.3
let [%EqEq] = rec (eqeq = func(x1, x2) {
    label ret : {
    let (t1 = prim("typeof", x1))
    let (t2 = prim("typeof", x2))
    if(t1 === t2) {
        if(t1 === "undefined") {
        break ret true
        }
        else {
        if(t1 === "null") {
            break ret true }
        else {
            if(t1 === "number") {
            break ret (x1 === x2) }
            else {
            if(t1 === "string") {
                break ret (x1 === x2) }
            else {
                if(t1 === "object") {
                break ret (x1 === x2) }
                else {
                            if(t1 === "boolean") {
                                break ret (x1 === x2) }
                            else {
                throw "[env] Catastrophe---unknown type in ==" }
            }}}}}}
    else {

            if((x1 === undefined && x2 === null) ||
               (x1 === null && x2 === undefined)) {
        break ret true }
            else {
        if(t1 === "number" && t2 === "string") {
                    break ret (x1 === prim("prim->num", x2)) }
        else {
                    if(t1 === "string" && t2 === "number") {
            break ret (prim("prim->num", x1) === x2) }
                    else {
            if(t1 === "boolean") {
                            break ret (eqeq(prim("prim->num", x1), x2)) }
            else {
                            if (t2 === "boolean") {
                break ret (eqeq(x1, prim("prim->num", x2))) }
                            else {
                if((t1 === "string" || t1 === "number") &&
                   (t2 === "object")) {
                                    break ret eqeq(x1, %ToPrimitive(x2)) }
                else {
                                    if((t2 === "string" || t2 === "number") &&
                                       (t1 === "object")) {
                    break ret eqeq(%ToPrimitive(x1), x2) }
                                    else {
                    break ret false }
                }}}}}}}}}) eqeq

let [%printlambda] = func(o, s) {
    prim("print", %ToString(s["0"]))
}

let [%print] = { [#code : %printlambda, #proto: %FunctionProto,] }

let [%len] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [%slice_internal] = func(list, min, max) {
    let (retObj = {[#extensible: true,]}) {
    rec (inner_slice = func(iter, ix) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", ix) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1), prim("+", ix, 1)) }
            }
            else { retObj["length" = ix] }
        })
    inner_slice(min, 0);
    retObj
    }
}

let [isDataField] = func(obj, field) {
    ((obj[field<#value>] !== undefined) ||
     (obj[field<#writable>] !== undefined))
}

let [isAccessorField] = func(obj, field) {
    ((obj[field<#setter>] !== undefined) ||
     (obj[field<#getter>] !== undefined))
}

let [isGenericField] = func(obj, field) {
    (isDataField(obj, field) === false &&
     isAccessorField(obj, field) === false)
}

let [isDataDescriptor] = func(attr-obj) {
    (typeof (attr-obj["value"]) !== "undefined" ||
     typeof (attr-obj["writable"]) !== "undefined")
}

let [isAccessorDescriptor] = func(attr-obj) {
    (typeof (attr-obj["set"]) !== "undefined" ||
     typeof (attr-obj["get"]) !== "undefined")
}

let [isGenericDescriptor] = func(attr-obj) {
    (isAccessorDescriptor(attr-obj) === false &&
     isDataDescriptor(attr-obj) === false)
}

let [copy-when-defined] = func(obj1, obj2, s) {
    if(obj2[s] !== undefined) {
    obj1[s = obj2[s] ]
    }
    else { undefined }
}

let [copy-data-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "writable");
    copy-when-defined(obj1, obj2, "value");
    obj1[delete "get"];
    obj1[delete "set"]

}

let [copy-access-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "set");
    copy-when-defined(obj1, obj2, "get");
    obj1[delete "value"];
    obj1[delete "writable"]
}

// 8.12.9
let [%defineOwnProperty] = func(obj, field, attr-obj) {
  let (t = typeof obj)
  if (t !== "object" && t !== "function") { throw "defineOwnProperty didn't get object" }
  else { undefined };
  let (fstr = %ToString(field))
  if (prim("hasOwnProperty", obj, fstr) === false) {
    if (obj[<#extensible>]) {
      // Do this to open it up for the other properties (will set these last)
      obj[fstr<#configurable> = true];
      obj[fstr<#writable> = true];

          {if(isDataDescriptor(attr-obj)) {
          obj[fstr<#value> = attr-obj["value"] ];
          obj[fstr<#writable> = %ToBoolean(attr-obj["writable"]) ]
      }
      else if(isAccessorDescriptor(attr-obj)) {
          obj[fstr<#getter> = attr-obj["get"] ];
          obj[fstr<#setter> = attr-obj["set"] ]
          }
          else { undefined }};

      obj[fstr<#enumerable> = %ToBoolean(attr-obj["enumerable"]) ];
      obj[fstr<#configurable> = %ToBoolean(attr-obj["configurable"]) ];
      true
    }
    else { %TypeError("(defineOwnProperty) Attempt to add a property to a non-extensible object.") }
  }
    else { /* it definitely has the property */
    let(current-prop = {[#extensible: true,]
      configurable: {#value obj[fstr<#configurable>], #writable true},
      enumerable: {#value obj[fstr<#enumerable>], #writable true}
    }) {
    if (prim("isAccessor", obj, fstr)) {
      current-prop["get" = obj[fstr<#getter>]];
      current-prop["set" = obj[fstr<#setter>]]
    }
    else {
      current-prop["writable" = obj[fstr<#writable>]];
      current-prop["value" = obj[fstr<#value>]]
    };
      if (obj[fstr<#configurable>] === false) {
      if (attr-obj["configurable"] === true) {
            %TypeError("escalating configurable from false to true")
      }
      else {
        if(attr-obj["enumerable"] === (obj[fstr<#enumerable>] === false)) {
          %TypeError("(defineOwnPoperty) Can't change enumerable of a non-configurable property")
        }
      };
      if ((isDataDescriptor(current-prop)) !== (isDataDescriptor(attr-obj))) {
        if (obj[fstr<#configurable>] === false) {
          %TypeError("(defineOwnProperty) Non-configurable property")
        }
        else {
          if (isDataDescriptor(current-prop)) {
            copy-data-desc(current-prop, attr-obj)
          }
          else {
            copy-access-desc(current-prop, attr-obj)
          }
        }
      }
    };
        // current-prop is what?
        if ((isDataDescriptor(current-prop)) &&
             (isDataDescriptor(attr-obj))) {
            if (current-prop["configurable"] === false) {
            if (current-prop["writable"] === false) {
                if (attr-obj["writable"] === true) {
                %TypeError("(defineOwnProperty) Cannot escalate writable from false to true.")
                }
                else {
                    if (prim("sameValue", attr-obj["value"], current-prop["value"]) === false) {
                      %TypeError("(defineOwnProperty) Cannot change a non-configurable value")
                }
                else { copy-data-desc(current-prop, attr-obj) }
                }
            }
            else { copy-data-desc(current-prop, attr-obj) }
            }
            else { copy-data-desc(current-prop, attr-obj) }
        }
        else {
            if (current-prop["configurable"] === false) {
                if (prim("sameValue", current-prop["set"], attr-obj["set"]) === false ||
                    prim("sameValue", current-prop["get"], attr-obj["get"]) === false) {
      %TypeError(prim("string+", "(defineOwnProperty) Cannot change setter or getter of non-configurable property ", fstr))
            }
            else { copy-access-desc(current-prop, attr-obj) }
            }
            else { copy-access-desc(current-prop, attr-obj) }
        };

        if(isDataDescriptor(current-prop)) {
      if (prim("sameValue", obj[fstr<#value>], current-prop["value"]) === false) {
            obj[fstr<#value> = current-prop["value"]]
      };
      if(obj[fstr<#writable>] !== current-prop["writable"]) {
            obj[fstr<#writable> = current-prop["writable"]]
      }
        }
        else if(isAccessorDescriptor(current-prop)) {
            obj[fstr<#getter> = current-prop["get"]];
            obj[fstr<#setter> = current-prop["set"]]
        }
        else { undefined };

    if(obj[fstr<#enumerable>] !== current-prop["enumerable"]) {
          obj[fstr<#enumerable> = current-prop["enumerable"]]
    };
    if(obj[fstr<#configurable>] !== current-prop["configurable"]) {
          obj[fstr<#configurable> = current-prop["configurable"]]
        };
        true
    }
    }
}

// Defines a property on an object from section 15.
// If given attributes, uses them, otherwise, uses the defaults
// as specified at the end of the intro to 15:
//    In every case, the length property of a built-in Function object
//    described in this clause has the attributes { [[Writable]]: false,
//    [[Enumerable]]: false, [[Configurable]]: false }. Every other property
//    described in this clause has the attributes { [[Writable]]: true,
//    [[Enumerable]]: false, [[Configurable]]: true } unless otherwise
//    specified.
let [%define15Property] = func(obj, field, prop) {
  let (mkPropObj = func(value, writable, enumerable, configurable) {
    if (value !== null) {
      {[] "value": {#value value, #writable true},
            "writable" : {#value writable, #writable true},
          "enumerable" : {#value enumerable, #writable true},
          "configurable" : {#value configurable, #writable true}}
    } else {
      {[] "writable" : {#value writable, #writable true},
          "enumerable" : {#value enumerable, #writable true},
          "configurable" : {#value configurable, #writable true}}
    }
  })
  if ((typeof obj) === "function" && field === "length") {
    %defineOwnProperty(obj, field, mkPropObj(prop, false, false, false))
  }
  else {
    %defineOwnProperty(obj, field, mkPropObj(prop, true, false, true))
  }
}

let [%definePropertylambda] = func(this, args) {
    let (obj = args["0"])
    let (field = args["1"])
    let (propobj = args["2"])
    // 8.10.5 checks

    if (%ObjectTypeCheck(obj)) {
    %TypeError("defineProperty didn't get object")
    }
    else {
    let (attrobj = {[#extensible: true,]}) {
        let (enumerable = propobj["enumerable"]) {
        if ((typeof enumerable) !== "undefined") {
            attrobj["enumerable" = enumerable]
        }
        else { attrobj }
        };

        let (configurable = propobj["configurable"]) {
        if ((typeof configurable) !== "undefined") {
            attrobj["configurable" = configurable]
        }
        else { attrobj }
        };

        let (writable = propobj["writable"]) {
        if ((typeof writable) !== "undefined") {
            attrobj["writable" = writable]
        }
        else { attrobj }
        };

        let (value = propobj["value"]) {
        if ((typeof value) !== "undefined") {
            attrobj["value" = value]
        }
        else { attrobj }
        };

        let (get = propobj["get"]) {
        if ((typeof get) !== "undefined" &&
            (prim("typeof", get) !== "function")) {
            %TypeError("defineProperty given a non-function getter")
        }
        else {
            attrobj["get" = get]
        }
        };

        let (set = propobj["set"]) {
        if (typeof set !== "undefined" &&
            (prim("typeof", set) !== "function")) {
            %TypeError("defineProperty given a non-function setter")
        }
        else {
            attrobj["set" = set]
        }
        };

        // 8.10.5, step 9
        if ((isDataDescriptor(attrobj)) &&
        (isAccessorDescriptor(attrobj))) {
                %TypeError("The attributes given to defineProperty were inconsistent")
        }
        else {
            %defineOwnProperty(obj, field, attrobj)
        }
    }
    }
}

let [%defineProperty] = { [#code : %definePropertylambda,] }

let [%ObjectConstructor] = func(this, args) {
  let (calledAsFunction = this === undefined)
  let (hasArg = prim(">", args["length"], 0))
  let (notNull = prim("!", args["0"] === null))
  let (notUndefined = prim ("!", args["0"] === undefined))
  let (shouldReturnEarly =
    calledAsFunction && hasArg && notNull && notUndefined)
  let (defaultRtn = { [#proto : %ObjectProto,] })
  if (shouldReturnEarly) {
    %ToObject(args["0"])
  } else {
    if (hasArg) {
      let (argtype = prim("typeof", args["0"]))
      let (isArgObject = argtype === "object" || argtype === "function")
      let (isArgSomething = argtype === "boolean" ||
        argtype === "string" || argtype === "number")
      if (isArgObject) { args["0"] } else {
        if (isArgSomething) { %ToObject(args["0"]) } else { defaultRtn }
      }
    } else {
      defaultRtn
    }
  }
}

// Used internally
let [%mkArgsObjBase] = func(args) {
  let (keys = get-own-field-names(args)) {
  let (argsObj = {[#proto: %ObjectProto,
                   #class: "Arguments",
                   #extensible: true,]
                   "callee" : {#getter %ThrowTypeError, #setter %ThrowTypeError},
                   "caller" : {#getter %ThrowTypeError, #setter %ThrowTypeError}}) {
    argsObj["callee" <#configurable> = false];
    argsObj["caller" <#configurable> = false];
    rec (loop = func(iter) {
      let (strx = %ToString(iter))
      if (prim("hasOwnProperty", keys, strx)) {
        %defineOwnProperty(argsObj, strx, {
          []
          "value" : {#value args[strx], #writable false},
          "writable" : {#value true, #writable false},
          "configurable": {#value true, #writable false},
          "enumerable": {#value true, #writable false}
        });
        loop(prim("+", iter, 1))
      }
      else {
        %defineOwnProperty(argsObj, "length", {
          []
          "value" : {#value iter, #writable false},
          "writable" : {#value true, #writable false},
          "configurable": {#value true, #writable false},
          "enumerable": {#value false, #writable false}
        })
      }
    }) {
    loop(0);
    argsObj
    }
  }
  }
}

let [%mkArgsObj] = func(args) {
  let (argsObj = %mkArgsObjBase(args)) {
    argsObj["%new" = false];
    argsObj["%new"<#writable> = false];
    argsObj
  }
}

let [%mkNewArgsObj] = func(args) {
  let (argsObj = %mkArgsObjBase(args)) {
    argsObj["%new" = true];
    argsObj["%new"<#writable> = false];
    argsObj
  }
}

let [%oneArgObj] = func(arg) {
  %mkArgsObj({[] "0": {#value arg, #writable false},
                 "length" : {#value 1, #writable false}})
}

let [%twoArgObj] = func(arg1, arg2) {
  %mkArgsObj({[] "0": {#value arg1, #writable false},
                 "1": {#value arg2, #writable false},
                 "length" : {#value 2, #writable false}})
}

let [%calllambda] = func(this, args) {
  let (callArgs = %slice_internal(args, 1, %len(args))) {
    this(args["0"], callArgs)
  }
}

// http://es5.github.com/#x15.3.4.3
// 15.3.4.3 Function.prototype.apply (thisArg, argArray)
let [%applylambda] = func(this, args) {
  let (applyArgs = args["1"]) {
    if ((prim("typeof", applyArgs) === 'undefined') ||
        applyArgs === null) {
      applyArgs := {[]}
    } else { undefined };
    %ObjectTypeCheck(applyArgs);
    applyArgs := %mkArgsObj(applyArgs);
    this(args["0"], applyArgs)
  }
}


let [%call] = { [#code : %calllambda, #proto : %FunctionProto,] }
let [%apply] = { [#code : %applylambda, #proto : %FunctionProto,] }



let [%makeGetter] = func(object, id) {
  {[#code: func(this, args) {
    if (prim("hasProperty", object, id)) {
      object[id]
    } else {
      %UnboundId(id)
    }
  },
  #proto: %FunctionProto,
  #extensible: false,]}
}

let [%UnwritableDispatch] = func(id) {
  func(e) {
    if(e === 'unwritable-field') {
      %TypeError(prim("string+", id, " not writable"))
    }
    else { %ErrorDispatch(e) }
  }
}

let [%makeSetter] = func(object, id) {
  {[#code: func(this, args) {
//    object[id = args["0"]]
    try {
      object[id = args["0"]]
    } catch {
      %UnwritableDispatch(id)
    }
  },
  #proto: %FunctionProto,
  #extensible: false,]}
}

let [%primEach] = func(arr, fn) {
  rec (loop = func(i) {
    let (istr = %ToString(i))
    if(prim("hasOwnProperty", arr, istr)) {
      fn(arr[istr]);
      loop(prim("+", i , 1))
    } else {
      undefined
    }
  })
  loop(0)
}


let [%defineGlobalVar] = func(context, id) {
  if (prim("!", prim("hasProperty", context, id))) {
    %defineOwnProperty(%global,
      id,
      {[] "value" : {#value undefined, #writable true},
          "writable" : {#value true, #writable true},
          "enumerable": {#value true, #writable true},
          "configurable" : {#value false, #writable true}});
    %defineOwnProperty (context,
      id,
      {[] "get" : {#value %makeGetter(%global, id), #writable true},
          "set" : {#value %makeSetter(%global, id), #writable true},
          "enumerable" : {#value true, #writable false},
          "configurable" : {#value true, #writable false}})
  }
}


let [%defineGlobalAccessors] = func(context, id) {
  %defineOwnProperty (%globalContext,
    id,
    {[] "get" : {#value %makeGetter(%global, id), #writable true},
        "set" : {#value %makeSetter(%global, id), #writable true},
        "enumerable" : {#value true, #writable false},
        "configurable" : {#value true, #writable true}})
}


let [%isNaN] = { [#code : %isNaNlambda, #proto : %FunctionProto,] }

let [%ErrorConstructor] = func(this, args) {
  let (o = {[#proto : %ErrorProto, #class : "Error",]})
  if (prim(">=", args["length"], 1)) {
    o["message" = %ToString(args["0"])];
    o
  } else { o }
}

let [%ErrorGlobalFuncObj] =
  {[#code : %ErrorConstructor, #proto : %FunctionProto,]
   "prototype" : {#value %ErrorProto, #writable false}}


let [%etslambda] = func(this, args) {
  if (prim("typeof", this) !== "object") {
    %TypeError("This not object in Error.prototype.toString")
  } else {
    let (name = if (this["name"] === undefined) { "Error" } else {
      %ToString(this["name"]) })
    let (msg = if (this["message"] === undefined) { "" } else {
      %ToString(this["message"]) })
    let (c1 = name === "")
    let (c2 = msg === "")
      label ret: {
      if (c1 && c2) {
          break ret "Error"
      } else { null };
      if (c1) {
          break ret msg
      } else { null };
      if (c2) {
          break ret name
      } else { null };

      let (prefix = prim("string+", name, ": "))
      break ret prim("string+", prefix, msg)
      }
  }
}

let [%ets] = {[#code : %etslambda, #proto : %FunctionProto,]}


let [%NumberGlobalFuncObj] =
  { [#code : %NumberConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %NumberProto, #writable false},
    "MAX_VALUE" : {#value 1.79769313486231571e+308, #writable false},
    "MIN_VALUE" : {#value 5.0e-324, #writable false},
    "NaN" : {#value NaN, #writable false},
    "NEGATIVE_INFINITY" : {#value -inf, #writable false},
    "POSITIVE_INFINITY" : {#value +inf, #writable false},
    "length" : {#value 1, #writable false}}



let [%stringToStringlambda] = func(this, args) {
  this[<#primval>]
}

let [%stringToString] =
  { [#code : %stringToStringlambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }


let [%StringConstructor] = func(this, args) {
  let (S = if (args["length"] === 0) { "" } else { %ToString(args["0"]) })
  if (this === undefined) {
    // Called as function
    S
  } else {
    let (obj =
      {[#proto : %StringProto, #primval : S, #class : "String",]
       "length" : {#value prim("strlen", S), #writable true}}) {
        %StringIndices(obj, S);
    obj
    }
  }
}

let [%StringGlobalFuncObj] =
  { [#code : %StringConstructor, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false} }

let [%BooleanConstructor] = func(this, args) {
  let (b = %ToBoolean(args["0"]))
  if (this === undefined) {
    b
  } else {
    {[#proto : %BooleanProto, #class : "Boolean", #primval : b,]}
  }
}

let [%booleanToStringlambda] = func(this, args) {
  let (t = prim("typeof", this))
  let (b = if (t === "boolean") { this } else {
    if (t === "object") {
      if (this[<#class>] === "Boolean") {
        this[<#primval>]
      } else { %TypeError("Boolean.prototype.toString got non-boolean object")}
    } else { %TypeError(prim("string+", "Boolean.prototype.toString got ", t)) }
  })
  if (b) { "true" } else { "false" }
}

let [%booleanToString] =
  { [#code : %booleanToStringlambda, #proto: %FunctionProto, #class: "Function",] }


let [%BooleanGlobalFuncObj] = { [#code : %BooleanConstructor, #proto : %FunctionProto,] }
 let [%ObjectGlobalFuncObj] =
  { [#code : %ObjectConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %ObjectProto, #writable false},
    "length" : {#value 1, #writable false},
  }

let [%gpoLambda] = func(this, args) {
  let (O = args["0"]) {
     %ObjectTypeCheck(O);
     O[<#proto>]
  }
}

let [%gpo] = {[#code : %gpoLambda, #proto : %FunctionProto,]}


let [%gopdLambda] = func(this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);
      let (name = %ToString(args["1"]))

      label ret: {
      if (prim("!", prim("hasOwnProperty", O, name))) {
          break ret undefined
      } else { null };

      let (obj = {[#proto : %ObjectProto,]}) {
          %defineOwnProperty(obj,
                 "enumerable",
                 {[] "value" : {#value O[name<#enumerable>], #writable true},
                  "writable" : {#value true, #writable true},
                  "enumerable" : {#value true, #writable true},
                  "configurable" : {#value true, #writable true}});
          %defineOwnProperty(obj,
                 "configurable",
                 {[] "value" : {#value O[name<#configurable>], #writable true},
                  "writable" : {#value true, #writable true},
                  "enumerable" : {#value true, #writable true},
                  "configurable" : {#value true, #writable true}});

          if (prim("!", prim("isAccessor", O, name))) {
              %defineOwnProperty(obj,
                     "value",
                     {[] "value" : {#value O[name], #writable true},
                      "writable" : {#value true, #writable true},
                      "enumerable" : {#value true, #writable true},
                      "configurable" : {#value true, #writable true}});
              %defineOwnProperty(obj,
                     "writable",
                     {[] "value" : {#value O[name<#writable>], #writable true},
                      "writable" : {#value true, #writable true},
                      "enumerable" : {#value true, #writable true},
                      "configurable" : {#value true, #writable true}});
          break ret obj
          } else {
              %defineOwnProperty(obj,
                     "get",
                     {[] "value" : {#value O[name<#getter>], #writable true},
                      "writable" : {#value true, #writable true},
                      "enumerable" : {#value true, #writable true},
                      "configurable" : {#value true, #writable true}});
              %defineOwnProperty(obj,
                     "set",
                     {[] "value" : {#value O[name<#setter>], #writable true},
                      "writable" : {#value true, #writable true},
                      "enumerable" : {#value true, #writable true},
                      "configurable" : {#value true, #writable true}});
          break ret obj
          }
      }
      }
  }
}

let [%gopd] = {[#code : %gopdLambda, #proto : %FunctionProto,]}


let [%objectToStringlambda] = func(this, args) {
    label ret: {
    if (this === undefined) {
        break ret "[object Undefined]"
    } else { undefined };

    if (this === null) {
        break ret "[object Null]"
    } else { undefined };

    let (O = %ToObject(this))
    let (class = O[<#class>])
    break ret prim("string+", "[object ", prim("string+", class, "]"))
    }
}

let [%objectToString] =
  { [#code : %objectToStringlambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }

let [%propEnumlambda] = func(this, args) {
  let (getOwnProperty = func(o, f) {
    if (prim("hasOwnProperty", o, f)) { o[f] } else { undefined }})
  if (args["0"] === undefined) { false } else {
  let (P = %ToString(args["0"]))
  let (O = %ToObject(this))
  let (desc = getOwnProperty(O, P))
  if (desc === undefined) {
    false
  } else {
    O[P<#enumerable>]
  }}
}

let [%propertyIsEnumerable] =
  {[#code : %propEnumlambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false} }

let [%toLocaleStringLambda] = func(this, args) {
  let (O = %ToObject(this))
  let (toString = O["toString"])
  if (toString[<#code>] === null) {
    %TypeError("toLocaleString")
  } else {
    toString(O, {[]})
  }
}

let [%toLocaleString] =
  { [#code : %toLocaleStringLambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }

let [%valueOflambda] = func(this, args) {
  %ToObject(this)
}

let [%valueOf] =
  { [#code : %valueOflambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false}
  }


let [%hasOwnPropertylambda] = func(this, args) {
    if(prim("hasOwnProperty", this, args["0"])) {
      true
    }
    else {
      false
    }
}

let [%hasOwnProperty] =
  { [#code : %hasOwnPropertylambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}
  }


let [%IsPrototypeOflambda] = func(this, args) {
    rec (searchChain = func(o, v) {
      let (vproto = v[<#proto>])
      if (vproto === null) {
        false
      } else {
        if (o === vproto) {
          true
        } else {
          searchChain(o, vproto)
        }
      }
    })
    let (vtype = prim("typeof", args["0"]))
    if (prim("!", vtype === "object") && prim("!", vtype === "function")) {
      false
    } else {
      let (O = %ToObject(this))
      searchChain(O, args["0"])
    }
}

let [%isPrototypeOf] =
  { [#code : %IsPrototypeOflambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}
  }
let [%EvalErrorProto] =
  { [#proto : %ErrorProto,]
    "name" : {#value "EvalError", #writable false}}

let [%NativeErrorConstructor] = func(proto) {
  func(this, args) {
    let (rtn = { [#proto : proto, #class : "Error",] })
    if (args["0"] !== undefined) {
      rtn["message" = %ToString(args["0"])];
      rtn
    } else {
      rtn
    }
  }
}


let [%SyntaxErrorConstructor] = %NativeErrorConstructor(%SyntaxErrorProto)

let [%SyntaxErrorGlobalFuncObj] =
  { [#code : %SyntaxErrorConstructor, #proto : %SyntaxErrorProto,]
    "prototype" : {#value %SyntaxErrorProto, #writable false} }



let [%EvalErrorConstructor] = %NativeErrorConstructor(%EvalErrorProto)

let [%EvalErrorGlobalFuncObj] =
  { [#code : %EvalErrorConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %EvalErrorProto, #writable false} }



let [%RangeErrorProto] =
  { [#proto : %ErrorProto,]
    "name" : {#value "RangeError", #writable false}}

let [%RangeErrorConstructor] = %NativeErrorConstructor(%RangeErrorProto)

let [%RangeErrorGlobalFuncObj] =
  { [#code : %RangeErrorConstructor, #proto : %RangeErrorProto,]
    "prototype" : {#value %RangeErrorProto, #writable false} }



let [%ReferenceErrorConstructor] = %NativeErrorConstructor(%ReferenceErrorProto)

let [%ReferenceErrorGlobalFuncObj] =
  { [#code : %ReferenceErrorConstructor, #proto : %ReferenceErrorProto,]
    "prototype" : {#value %ReferenceErrorProto, #writable false} }


let [%TypeErrorConstructor] = %NativeErrorConstructor(%TypeErrorProto)

let [%TypeErrorGlobalFuncObj] =
  { [#code : %TypeErrorConstructor, #proto : %TypeErrorProto,]
    "prototype" : {#value %TypeErrorProto, #writable false} }


let [%URIErrorProto] =
  { [#proto : %ErrorProto,]
    "name" : {#value "URIError", #writable false}}

let [%URIErrorConstructor] = %NativeErrorConstructor(%URIErrorProto)

let [%URIErrorGlobalFuncObj] =
  { [#code : %URIErrorConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %URIErrorProto, #writable false} }


let [%ArrayProto] = { [#proto : %ObjectProto, #class : "Array",]
  "length" : {#value 0, #writable true} }

let [%gopnLambda] = func(this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);
      let (A =
       {[#proto : %ArrayProto, #class : "Array",]
            "length" : {#value 0, #writable true}})
      let (props = get-own-field-names(O))
      let (len = props["length"])
      rec (loop = func(i) {
      if (prim("<", i, len)) {
          let (to = prim("prim->str", i))
          let (from = prim("prim->str", prim("-", len, prim("+", i, 1))))
          A[to = props[from] ];
          loop(prim("+", i, 1))
      } else {
          A["length" = i]
      }
      }) {
      loop(0);
      A
      }
  }
}

let [%gopn] = {[#code : %gopnLambda, #proto : %FunctionProto,]}

let [%definePropertiesLambda] = func(this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);
      let (props = %ToObject(args["1"]))
      let (names = get-own-field-names(props))
      let (len = names["length"])
      rec (loop = func(i) {
      label ret: {
          if (prim("<", i, len)) {
          let (indx = prim("prim->str", i))
          let (name = names[indx])
          if (props[name<#enumerable>]) {
              let (argsObj = {[]}) {
              argsObj["0" = O];
              argsObj["1" = name];
              argsObj["2" = props[name] ];
              argsObj["length" = 3];
                  %definePropertylambda(null, argsObj);
              break ret loop(prim("+", i, 1))
              }
          } else {
              break ret loop(prim("+", i, 1))
          }
          } else { break ret undefined }
      }})
      loop(0);
      O
  }
}

let [%defineProperties] =
  {[#code : %definePropertiesLambda, #proto : %FunctionProto,]}

let [%createLambda] = func(this, args) {
  let (O = args["0"])
  let (t = prim("typeof", O))
  let (c1 = t !== "object")
  let (c2 = t !== "function")
    let (c3 = O !== null) {

    if (c1 && c2 && c3) {
    %TypeError("Object.create failed")
    } else { null };

    let (obj = {[#proto : O,]}) {
        if (prim(">=", args["length"], 2) && args["1"] !== undefined) {
        let (Properties = %ToObject(args["1"]))
        let (argsObj = {[]}) {
            argsObj["0" = obj];
            argsObj["1" = Properties];
            argsObj["length" = 2];
            %definePropertiesLambda(null, argsObj);
            obj
        }
        } else {
        obj
        }
    }
    }
}

let [%create] = {[#code : %createLambda, #proto : %FunctionProto,]}


let [%sealLambda] = func(this, args) {
    let (O = args["0"]) {
        %ObjectTypeCheck(O);

    let (names = get-own-field-names(O))
    let (len = names["length"])
    rec (loop = func(i) {
        if (prim("<", i, len)) {
        let (name = names[prim("prim->str", i)])
        O[name<#configurable> = false];
        loop(prim("+", i, 1))
        } else { null }
    })
    loop(0);
    O[<#extensible>=false];
    O
    }
}

let [%seal] = {[#code : %sealLambda, #proto : %FunctionProto,]}

let [%freezelambda] = func(this, args) {
  let (O = args["0"]) {
      %ObjectTypeCheck(O);

      let (names = get-own-field-names(O))
      let (len = names["length"])
      rec (loop = func(i) {
      if (prim("<", i, len)) {
          let (name = names[prim("prim->str", i)]) {
          if (prim("!", prim("isAccessor", O, name))) {
              if (O[name<#writable>]) {
              O[name<#writable> = false]
              }
          };

          O[name<#configurable> = false];
          loop(prim("+", i, 1))
          }
      } else { null }
      }) {
      loop(0);
      O[<#extensible> = false];
      O
      }
  }
}

let [%freeze] = {[#code : %freezelambda, #proto : %FunctionProto,]}


let [%preventExtensionsLambda] = func(this, args) {
    let (O = args["0"]) {
        %ObjectTypeCheck(O);
    O[<#extensible> = false];
    O
    }
}
let [%preventExtensions] =
  {[#code : %preventExtensionsLambda, #proto : %FunctionProto,]}


let [%isFrozenLambda] = func(this, args) {
    let (O = args["0"]) {
        %ObjectTypeCheck(O);
    let (names = get-own-field-names(O))
    let (len = names["length"])
    rec (loop = func(i) {
        label ret: {
        if (prim("<", i, len)) {
            let (name = names[prim("prim->str", i)])
            let (isData = prim("!", prim("isAccessor", O, name))) {

            if (isData && O[name<#writable>]) {
            break ret false
            } else { null };

            if (O[name<#configurable>]) {
            break ret false
            } else { null };

            break ret loop(prim("+", i, 1))
      }
        } else { break ret prim("!", O[<#extensible>]) }
        }})
    loop(0)
    }
}

let [%isFrozen] = {[#code : %isFrozenLambda, #proto : %FunctionProto,]}


let [%isSealedLambda] = func(this, args) {
    let (O = args["0"]) {
        %ObjectTypeCheck(O);
    let (names = get-own-field-names(O))
    let (len = names["length"])
    rec (loop = func(i) {
        label ret: {
        if (prim("<", i, len)) {
            let (name = names[prim("prim->str", i)])
            if (O[name<#configurable>]) {
            break ret false
            } else { null };
            break ret loop(prim("+", i, 1))
        } else { break ret prim("!", O[<#extensible>]) }
        }})
    loop(0)
    }
}

let [%isSealed] = {[#code : %isSealedLambda, #proto : %FunctionProto,]}


let [%isExtensibleLambda] = func(this, args) {
    let (O = args["0"]) {
        %ObjectTypeCheck(O);
    O[<#extensible>]
    }
}

let [%isExtensible] = {[#code : %isExtensibleLambda, #proto : %FunctionProto,]}


let [%propertyNames] = func(obj, get-non-enumerable) {
  let (aux = {[#extensible : true,]})
  rec (helper = func(obj) {
    if (obj === null) {
      undefined
    } else {
      let (cur = get-own-field-names(obj))
      let (length = cur["length"])
      rec (loop = func(i) {
        if (prim("<", i, length)) {
          let (istr = prim("prim->str",i)) {
            if (obj[cur[istr]<#enumerable>] || get-non-enumerable) {
              aux[cur[istr] = true]
            } else {undefined };
            loop(prim("+",i,1))
          }
        }
        else { undefined }
      })
      loop(0);
      helper(obj[<#proto>])
    }
  }) {
    helper(obj);
    get-own-field-names(aux)
  }
}

let [%keysLambda] = func(this, args) {
    let (O = args["0"]) {
        %ObjectTypeCheck(O);

    let (A =
         {[#proto : %ArrayProto, #class : "Array",]
              "length" : {#value 0, #writable true}})
    let (names = get-own-field-names(O))
    let (len = names["length"])

    rec (loop = func(i, enumCount) {
        if (prim("<", i, len)) {
        let (indx = prim("prim->str", i))
        let (name = names[indx])
        if (O[name<#enumerable>]) {
            let (pd = {[] "value" : {#value name, #writable true},
                   "writable" : {#value true, #writable true},
                   "enumerable" : {#value true, #writable true},
                   "configurable" : {#value true, #writable true}})
            %defineOwnProperty(A, prim("prim->str", enumCount), pd);
            loop(prim("+", i, 1), prim("+", enumCount, 1))
        } else {
            loop(prim("+", i, 1), enumCount)
        }
        } else { A["length" = enumCount] }
    }) {
        loop(0, 0);
        A
    }
    }
}

let [%keys] = {[#code : %keysLambda, #proto : %FunctionProto,]}

let [%ToUint] = func(n, limit) {
  let (number = %ToNumber(n))
  if (number !== number || number === 0 || number === +inf || number === -inf) {
    0
  } else {
    let (sign = if (prim("<", number ,0)) { prim("-", 0, 1) } else { 1 })
    let (posInt = prim("*", sign, prim("floor", prim("abs", number))))
    if (prim("<", sign, 0)) {
      let (close = prim("%", posInt, limit))
      prim("+", close, limit)
    } else {
      prim("%", posInt, limit)
    }
  }
}

let [%ToUint32] = func(n) {
  %ToUint(n, 4294967296.0)
}

let [%ToInt32] = func(n) {
  let (int32bit = %ToUint32(n))
  if (prim(">=", int32bit, 2147483648.0)) {
    prim("-", int32bit, 4294967296.0)
  } else {
    int32bit
  }
}

let [%ToUint16] = func(n) {
  %ToUint(n, 65536.0)
}

let [%fromcclambda] = func(this, args) {
  if (args["length"] === 0) {
    ""
  } else {
    let (end = args["length"])
    rec (loop = func(i, soFar) {
      if (prim("<", i, end)) {
        let (char = prim("ascii_ntoc", %ToUint16(args[prim("prim->str", i)])))
        let (next = prim("string+", soFar, char))
        loop(prim("+", i, 1), next)
      } else { soFar }
    })
    loop(0, "")
  }
}

let [%fromCharCode] =
  {[#code : %fromcclambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}}


let [%joinlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (sep = if (args["0"] === undefined) { "," }
    else { %ToString(args["0"]) })
    label ret: {
    if (len === 0) {
        break ret ""
    } else { null };
    rec (loop = func(k, R) {
        if (prim(">=", k, len)) {
        R
        } else {
        let (S = prim("string+", R, sep))
        let (element = O[%ToString(k)])
        let (next =
             if (element === null || element === undefined) { "" }
             else { %ToString(element) })
        loop(prim("+", k, 1), prim("string+", S, next))
        }
    })
    let (start = if (O["0"] === undefined || O["0"] === null) { "" }
         else { %ToString(O["0"]) })
    break ret loop(1, start)
    }
}

let [%join] = { [#code : %joinlambda, #proto : %FunctionProto,] }


let [%poplambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else {
    let (indx = %ToString(prim("-", len, 1)))
      let (element = O[indx]) {
      O[delete indx];
      O["length" = %ToNumber(indx)];
      element
      }
  }
}

let [%pop] = { [#code : %poplambda, #proto : %FunctionProto,] }

let [%ArrayLengthChange] = func(arr, newlen) {
  let (oldlen = %ToUint32(arr["length"]))
  rec (fix = func(i) {
    if (prim("<", i, oldlen)) {
      arr[delete prim("prim->str", i)];
      fix(prim("+", i, 1))
    }
  })
  fix(newlen)
}

// 15.4: A property name P (in the form of a String value) is an array index if and
// only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to
// 2^32-1
let [%set-property] = func(obj, fld, val) {
  let (obj = %ToObject(obj))
  let (fld = %ToString(fld))

  let (check = func(flag) {
    if (flag) {
      %TypeError("set-property failed")
    } else { null }
  })

  let (e = prim("!", obj[<#extensible>])) {
  check(e);

  let (isArrayIndex = func() {
    let (uint = %ToUint32(fld))
      if (%ToString(uint) === fld) {
        uint !== 4294967295.0
      }
      else {
        false
      }
  })
  let (setArrayField = func() {
    let (lenCheck = func() {
      if (fld === "length") {
        let (newLen = %ToUint32(val))
        let (toCompare = %ToNumber(val))
        if (newLen !== toCompare) {
          throw %JSError({[#proto : %RangeErrorProto,]})
        } else {
          if (prim("<", newLen, obj["length"])) {
            %ArrayLengthChange(obj, newLen)
          } else { undefined }
        }
      } else { undefined }
    }) {
    lenCheck();

    obj[fld = if (fld === "length") { %ToUint32(val) } else { val }];

    if (isArrayIndex()) {
      let (uint = %ToUint32(fld))
      let (len = obj["length"])
      if (prim("<", len, prim("+", uint, 1))) {
        obj["length" = prim("+", uint, 1)]
      } else { undefined }
    }
    else { undefined }
    }})
  if (obj[<#class>] === "Array") {
    setArrayField()
  }
  else {
    obj[fld = val]
  }
  }
}

let [%pushlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  rec (loop = func(i, n) {
    if (prim("<", i, args["length"])) {
      let (ii = prim("prim->str", i))
      %set-property(O, %ToString(n), args[ii]);
      //O[%ToString(n) = args[ii] ];
      loop(prim("+", i, 1), prim("+", n, 1))
    } else { n }
  })
  loop(0, len)
}

let [%push] = {[#code : %pushlambda, #proto : %FunctionProto,]}

let [%reverselambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (middle = prim("floor", prim("/", len, 2)))
  rec (loop = func(lower) {
    if (lower !== middle) {
    label ret: {
        let (upper = prim("-", prim("-", len, lower), 1))
        let (upperP = %ToString(upper))
        let (lowerP = %ToString(lower))
        let (lowerValue = O[lowerP])
        let (upperValue = O[upperP])
        let (lowerExists = prim("hasProperty", O, lowerP))
        let (upperExists = prim("hasProperty", O, upperP))

        if (lowerExists && upperExists) {
        O[lowerP = upperValue];
        O[upperP = lowerValue];
        break ret loop(prim("+", lower, 1))
        } else { null };

        if (upperExists) {
        O[lowerP = upperValue];
        O[delete upperP];
        break ret loop(prim("+", lower, 1))
        } else { null };

        if (lowerExists) {
        O[delete lowerP];
        O[upperP = lowerValue];
        break ret loop(prim("+", lower, 1))
        } else { null };

        break ret loop(prim("+", lower, 1))
    }
    }
  }) {
      loop(0);
      O
  }
}

let [%reverse] = {[#code : %reverselambda, #proto : %FunctionProto,]}


let [%shiftlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else {
    let (first = O["0"])
    rec (loop = func(k) {
    label ret: {
        if (prim(">=", k, len)) {
        break ret undefined
        } else { null };

        let (from = %ToString(k))
        let (to = %ToString(prim("-", k, 1)))
        let (fromPresent = prim("hasProperty", O, from))
        if (fromPresent) {
        let (fromVal = O[from])
        O[to = fromVal];
        break ret loop(prim("+", k, 1))
        } else {
        O[delete to];
        break ret loop(prim("+", k, 1))
        }
    }})
    loop(1);
    let (newLen = prim("-", len, 1))
    O[delete %ToString(newLen)];
    O["length" = newLen];
    first
  }
}

let [%shift] = {[#code : %shiftlambda, #proto : %FunctionProto,]}

let [%arrayToStringlambda] = func(this, args) {
  let (array = %ToObject(this))
  let (thefunc = array["join"])
  let (ffunc =
  if (prim("!", prim("typeof", thefunc) === "object") &&
      prim("!", prim("typeof", thefunc) === "function")) {
    %objectToStringlambda
  } else {
    if (thefunc[<#code>] === null) {
      %objectToStringlambda
    } else { thefunc }
  })
  ffunc(array, {[]})
}

let [%arrayToString] =
  { [#code : %arrayToStringlambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }

let [%arrayTLSlambda] = func(this, args) {
  let (isCallable = func(o) {
      label ret: {
      if (prim("!", prim("typeof", o) === "object") &&
              prim("!", prim("typeof", o) === "function")) {
          break ret false
      } else { null };
      if (o[<#code>] === null) {
          break ret false
      } else { null };
      break ret true
      }})
  let (array = %ToObject(this))
  let (arrayLen = array["length"])
  let (len = %ToUint32(arrayLen))
  let (separator = " ")
    label ret: {
    if (len === 0) {
        break ret ""
    } else { null };
    let (firstElement = array["0"])
    let (R = if (firstElement === null || firstElement === undefined) { "" } else {
        let (elementObj = %ToObject(firstElement))
        let (funcc = elementObj["toLocaleString"])
        if (prim("!", isCallable(funcc))) {
        %TypeError("Not callable in ArrayTLS")
      }
        else { null };
        funcc(elementObj, {[]}) })
    rec (inner = func(k, r) {
        if (prim(">=", k, len)) {
        r
        } else {
        let (S = prim("string+", prim("prim->str", r), separator))
        let (nextElement = array[prim("prim->str", k)])
        let (toAppend = if (nextElement === null ||
                    nextElement === undefined) { "" } else {
                    let (elementObj = %ToObject(nextElement))
                    let (funcc = elementObj["toLocaleString"]) {
                        if (prim("!", isCallable(funcc))) {
                        throw %JSError({[#proto : %TypeErrorProto,]})
                        } else { null };
                        funcc(elementObj, {[]}) }})
        inner(prim("+", k, 1),
              prim("string+", prim("prim->str", r),
               prim("prim->str", toAppend)))
        }
    })
    break ret inner(1, R)
    }
}

let [%arrayToLocaleString] =
  { [#code : %arrayTLSlambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }

let [%ArrayConstructor] = func(this, args) {
    label ret: {
    if (prim(">=", args["length"], 2)) {
        let (rtnobj =
         {[#proto : %ArrayProto, #class : "Array",]
          "length" : {#value 0, #writable true}, })
        rec (init = func(n) {
        rtnobj[ prim("prim->str", n) = args[prim("prim->str", n)] ];
        if (prim(">", n, 0)) {
            init(prim("-", n, 1))
        }
        }) {
        init(args["length"]);
        rtnobj["length" = args["length"] ];
        break ret rtnobj
        }
    } else { null };
    let (c1 = prim("typeof", args["0"]) === "number")
    let (c2 = if (c1) { %ToUint32(args["0"]) !== args["0"] } else { false })
    if (c2) {
        throw %JSError({[#proto : %RangeErrorProto,]})
    } else {
        if (c1) {
        break ret { [#proto : %ArrayProto, #class : "Array",]
                "length" : {#value %ToUint32(args["0"]), #writable true} }
        } else {
        let (rtn = {[#proto : %ArrayProto, #class : "Array",]
                "length" : {#value args["length"], #writable true}}) {
            %defineOwnProperty(rtn,
                       "0",
                       {[] "value" : {#value args["0"], #writable true},
                    "writable" : {#value true, #writable true},
                    "enumerable" : {#value true, #writable true},
                    "configurable" : {#value true, #writable true}});
            break ret rtn
        }
        }
    }
    }
}

let [%concatLambda] = func(this, args) {
  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %ArrayConstructor(emptyobj, emptyobj))
  rec (procElt = func(obj, elt, n) {
    let (procNormalElt = func(nelt, k) {
      obj[prim("prim->str", k) = nelt];
      prim("+", k, 1)
    })
    rec (procArrayElt = func(arr, fromIndex, toIndex) {
      if (arr[prim("prim->str", fromIndex)] === undefined) {
        toIndex
      } else {
        obj[prim("prim->str", toIndex) = arr[prim("prim->str", fromIndex)] ];
        procArrayElt(arr, prim("+", fromIndex, 1), prim("+", toIndex, 1))
      }
    })
    if (prim("typeof", elt) === "object") {
      if (elt[<#class>] === "Array") {
        procArrayElt(elt, 0, n)
      } else {
        procNormalElt(elt, n)
      }
    } else {
      procNormalElt(elt, n)
    }
  })
  rec (procAllElts = func(from, fromIndex, toIndex) {
    if (from[prim("prim->str", fromIndex)] !== undefined) {
      let (nextI = procElt(A, from[prim("prim->str", fromIndex)], toIndex))
      procAllElts(from, prim("+", fromIndex, 1), nextI)
    } else { toIndex }
  })
  let (halftime = if (O[<#class>] === "Array") {
    procAllElts(O, 0, 0) } else { A["0" = O]; 1 })
    let (end = procAllElts(args, 0, halftime)) {
    A["length" = end];
    A
    }
}

let [%concat] =
  { [#code : %concatLambda, #proto : %FunctionProto,] }

let [%sortlambda] = func(this, args) {
  let (obj = %ToObject(this))
  let (sortCompare = func(j, k) {
    let (jString = %ToString(j))
    let (kString = %ToString(k))

    let (hasj = prim("hasProperty", obj, jString))
    let (hask = prim("hasProperty", obj, kString))
      label ret: {
      if (hasj === false && hask === false) {
          break ret 0
      } else { null };

      if (hasj === false) {
          break ret 1
      } else { null };

      if (hask === false) {
          break ret prim("-", 0, 1)
      } else { null };

      let (x = obj[jString])
      let (y = obj[kString]) {
          if (x === undefined && y === undefined) {
          break ret 0
          } else { null };

          if (x === undefined) {
          break ret 1
          } else { null };

          if (y === undefined) {
          break ret prim("-", 0, 1)
          } else { null };

          if (args["0"] !== undefined) {
          if (prim("typeof", args["0"]) !== "function") {
              throw %JSError({[#proto : %TypeErrorProto,]})
          } else { null };

          break ret args["0"](undefined,
                      {[] "0" : {#value x, #writable true},
                       "1" : {#value y, #writable true}})
          } else { null };

          let (xString = %ToString(x))
          let (yString = %ToString(y)) {

          if (prim("string<", xString, yString)) {
              break ret prim("-", 0, 1)
          } else { null };

          if (prim("string<", yString, xString)) {
              break ret 1
          } else { null };
          break ret 0
          }
      }
      }})

  let (insert = func(elt, before) {
    rec (insertAndShift = func(prior, i) {
      let (indx = prim("prim->str", i))
    let (next = obj[indx]) {
        obj[indx = prior];
        if (prim("<", i, before)) {
        insertAndShift(next, prim("+", i, 1))
        } else { undefined }
    }
    })

    rec (loop = func(currIndex) {
      if (currIndex === before) {
        // elt can stay where it was
        undefined
      } else {
        let (indx = prim("prim->str", currIndex))
        let (result = sortCompare(currIndex, before))
        if (result === 1) {
          let (old = obj[indx]) {
            obj[indx = elt];
            insertAndShift(old, prim("+", currIndex, 1))
          }
        } else {
          loop(prim("+", currIndex, 1))
        }
      }
    })

    loop(0)
  })
  let (len = obj["length"])
  rec (isort = func(i) {
    if (prim("<", i, len)) {
      insert(obj[prim("prim->str", i)], i);
      isort(prim("+", i, 1))
    } else { obj }
  })

  isort(1)
}

let [%sort] = { [#code : %sortlambda, #proto : %FunctionProto,] }

let [%ArrayGlobalFuncObj] =
  { [#code : %ArrayConstructor, #proto : %FunctionProto, #class : "Function",]
    "prototype" : {#value %ArrayProto, #writable false} }


let [%getCurrentUTC] = func() { prim("current-utc-millis", "ignored") }

let [%parse] = func(v) { 0 } // TODO: implement

let [%CheckObjectCoercible] = func(o) {
  if (o === undefined || o === null) {
    %TypeError("Not object coercible")
  } else { undefined }
}

let [%charatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    ""
  } else {
    prim("char-at", S, position)
  }
}

let [%charat] = {[#code : %charatlambda, #proto : %FunctionProto,]}

let [%charcodeatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    NaN
  } else {
    prim("ascii_cton", prim("char-at", S, position))
  }
}

let [%charcodeat] = {[#code : %charcodeatlambda, #proto : %FunctionProto,]}

let [%strconcatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (end = args["length"])
  rec (loop = func(i, soFar) {
    if (prim("<", i, end)) {
      let (next = %ToString(args[prim("prim->str", i)]))
      loop(prim("+", i, 1), prim("string+", soFar, next))
    } else { soFar }
  })
  loop(0, S)
}

let [%strconcat] = {[#code : %strconcatlambda, #proto : %FunctionProto,]}

let [%min] = func(a, b) {
  if (prim("<=", a, b)) { a } else { b }
}
let [%max] = func(a, b) {
  if (prim("<=", a, b)) { b } else { a }
}

let [%substringlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (intEnd =
    let (end = args["1"])
    if (end === undefined) { len } else { %ToInteger(end) })
  let (finalStart = %min(%max(intStart, 0), len))
  let (finalEnd = %min(%max(intEnd, 0), len))
  let (from = %min(finalStart, finalEnd))
  let (to = %max(finalStart, finalEnd))
  rec (loop = func(i, soFar) {
    if (prim("<", i, to)) {
      loop(prim("+", i, 1), prim("string+", soFar, prim("char-at", S, i)))
    } else { soFar }
  })
  loop(from, "")
}

let [%substring] = {[#code : %substringlambda, #proto : %FunctionProto,]}

let [%splicelambda] = func(this, args) {
  let (start = args["0"])
  let (deleteCount = args["1"])

  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A =
    {[#proto : %ArrayProto, #class : "Array",]
        "length" : {#value 0, #writable true}})
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(start))
  let (actualStart =
    if (prim("<", relativeStart, 0)) {
      %max(prim("+", len, relativeStart), 0)
    } else {
      %min(relativeStart, len)
    })
  let (actualDeleteCount =
       %min(%max(%ToInteger(deleteCount), 0), prim("-", len, actualStart))) {

      rec (writeToALoop = func(k) {
      if (prim("<", k, actualDeleteCount)) {
          let (from = %ToString(prim("+", actualStart, k)))
          if (prim("hasProperty", O, from)) {
          let (fromValue = O[from])
              %defineOwnProperty(A,
                     %ToString(k),
                     {[] "value" : {#value fromValue, #writable true},
                      "writable" : {#value true, #writable true},
                      "enumerable" : {#value true, #writable true},
                      "configurable" : {#value true, #writable true}});
          A["length" = prim("+", A["length"], 1)];
          writeToALoop(prim("+", k, 1))
          } else {
          writeToALoop(prim("+", k, 1))
          }
      } else { undefined }
      })
      writeToALoop(0);

      let (itemCount = prim("-", args["length"], 2)) {
      let (step1 = func() {
          if (prim("<", itemCount, actualDeleteCount)) {
          let (end = prim("-", len, actualDeleteCount))
          rec (writeToOLoop = func(k) {
              if (prim("<", k, end)) {
              let (from = %ToString(prim("+", k, actualDeleteCount)))
              let (to = %ToString(prim("+", k, itemCount)))
              if (prim("hasProperty", O, from)) {
                  O[to = O[from] ];
                  writeToOLoop(prim("+", k, 1))
              } else {
                  O[delete to];
                  writeToOLoop(prim("+", k, 1))
              }
              } else { undefined }
          })
          writeToOLoop(actualStart);

          let (delLimit = prim("+", prim("-", len, actualDeleteCount), itemCount))
          rec (deleteloop = func(k) {
              if (prim(">", k, delLimit)) {
              let (next = prim("-", k, 1))
              O[delete %ToString(next)];
              deleteloop(next)
              } else { undefined }
          })
          deleteloop(len)
          } else { null }
      })
      step1();

      let (step2 = func() {
          if (prim(">", itemCount, actualDeleteCount)) {
          rec (writeToOLoop = func(k) {
              if (prim(">", k, actualStart)) {
              let (from = %ToString(prim("+", k, prim("-", actualDeleteCount, 1))))
              let (to = %ToString(prim("+", k, prim("-", itemCount, 1))))
              if (prim("hasProperty", O, from)) {
                  O[to = O[from] ];
              writeToOLoop(prim("-", k, 1))
              } else {
                  O[delete to];
                  writeToOLoop(prim("-", k, 1))
              }
              } else { undefined }
          })

          writeToOLoop(prim("-", len, actualDeleteCount))
          } else {
          undefined
          }
      })
      step2();

      let (outerEnd = args["length"])
      rec(outerloop = func(k, argsIndex) {
          if (prim("<", argsIndex, outerEnd)) {
          O[%ToString(k) = args[prim("prim->str", argsIndex)] ];
          outerloop(prim("+", k, 1), prim("+", argsIndex, 1))
          } else { undefined }
      })
      outerloop(actualStart, 2);
      O["length" = prim("+", prim("-", len, actualDeleteCount), itemCount)];
      A
      }
  }
}

let [%splice] = {[#code : %splicelambda, #proto : %FunctionProto,]}

let [%unshiftlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (argCount = args["length"]) {

      rec (Oloop = func(k) {
      if (prim(">", k, 0)) {
          let (from = %ToString(prim("-", k, 1)))
          let (to = %ToString(prim("+", k, prim("-", argCount, 1))))
          if (prim("hasProperty", O, from)) {
          O[to = O[from] ];
          Oloop(prim("-", k, 1))
          } else {
          O[delete to];
          Oloop(prim("-", k, 1))
          }
      } else { undefined }
      })
      Oloop(len);

      let (end = args["length"])
      rec (argsLoop = func(argsIndex, j) {
      if (prim("<", argsIndex, end)) {
          O[%ToString(j) = args[prim("prim->str", argsIndex)] ];
          argsLoop(prim("+", argsIndex, 1), prim("+", j, 1))
      } else { undefined }
      })
      argsLoop(0, 0);

      let (finalLen = prim("+", len, argCount)) {
      O["length" = finalLen];
      finalLen
      }
  }
}

let [%unshift] = {[#code : %unshiftlambda, #proto : %FunctionProto,]}


let [%aiolambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (negOne = prim("-", 0, 1))

    label ret: {
    if (len === 0) {
        break ret negOne
    } else { undefined };

    let (n = if (args["1"] === undefined) { 0 } else { %ToInteger(args["1"]) }) {
        if (prim(">=", n, len)) {
        break ret negOne
        } else { undefined };

        rec (loop = func(k) {
        if (prim("<", k, len)) {
            let (kStr = %ToString(k))
            if (prim("hasProperty", O, kStr)) {
            let (elementK = O[kStr])
            if (args["0"] === elementK) {
                break ret k
            } else { undefined };
            loop(prim("+", k, 1))
            } else {
            loop(prim("+", k, 1))
            }
        } else { undefined }
        })
        let (start = if (prim(">=", n, 0)) { n } else {
            %max(prim("-", len, prim("abs", n)), 0)
        }) {
        loop(start);
        break ret negOne
        }
    }
    }
}

let [%arrayIndexOf] = {[#code : %aiolambda, #proto : %FunctionProto,]}

let [%aliolambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (negOne = prim("-", 0, 1))

    label ret: {
    if (len === 0) {
        break ret negOne
    } else { undefined };

    let (n = if (args["1"] === undefined) { prim("-", len, 1) }
         else { %ToInteger(args["1"]) })
    rec (loop = func(k) {
        if (prim(">=", k, 0)) {
        let (kstr = %ToString(k))
        if (prim("hasProperty", O, kstr)) {
            if (O[kstr] === args["0"]) {
            break ret k
            } else { loop(prim("-", k, 1)) }
        } else { loop(prim("-", k, 1)) }
        } else { undefined }
    })

    let (start = if (prim(">=", n, 0)) { %min(n, prim("-", len, 1)) }
         else { prim("-", len, prim("abs", n)) })
    loop(start);
    break ret negOne
    }
}

let [%arrayLastIndexOf] = {[#code : %aliolambda, #proto : %FunctionProto,]}


let [%foreachlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (callbackfn = args["0"])

  label ret: {

      if (prim("typeof", callbackfn) !== "function") {
          %TypeError("Callback not a function in forEach")
      } else { undefined };

      let (T = args["1"])
      rec (loop = func(k) {
          if (prim("<", k, len)) {
              let (Pk = %ToString(k))
              if (prim("hasProperty", O, Pk)) {
                  let (kValue = O[Pk])
                  let (argslist =
                       {[] "0" : {#value kValue, #writable true},
                        "1" : {#value k, #writable true},
                        "2" : {#value O, #writable true}})
                  callbackfn(T, argslist);
                  loop(prim("+", k, 1))
              } else {
                  loop(prim("+", k, 1))
              }
          } else { undefined }
      })
      loop(0);
      undefined
  }
}

let [%foreach] = {[#code : %foreachlambda, #proto : %FunctionProto,]}

let [%maplambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
    if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not a function in map")
    } else { null };

    let (T = args["1"])
    let (A = {[#proto : %ArrayProto, #class : "Array",]})

    rec (loop = func(k) {
        if (prim("<", k, len)) {
        let (Pk = %ToString(k))
        if (prim("hasProperty", O, Pk)) {
            let (kValue = O[Pk])
            let (argsObj = {[]}) {
            argsObj["0" = kValue];
            argsObj["1" = k];
            argsObj["2" = O];
            argsObj["length" = 3];
            let (mappedValue = callbackfn(T, argsObj))
                %defineOwnProperty(A,
                           Pk,
                           {[] "value" : {#value mappedValue, #writable true},
                        "writable" : {#value true, #writable true},
                        "enumerable" : {#value true, #writable true},
                        "configurable" : {#value true, #writable true}});
            loop(prim("+", k, 1))
            }
        } else {
            loop(prim("+", k, 1))
        }
        } else { A["length" = k] }
    }) {

        loop(0);
        break ret A
    }
    }
}

let [%map] = {[#code : %maplambda, #proto : %FunctionProto,]}

let [%filterlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
    if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not a function in filter")
    } else { null };

    let (T = args["1"])
  let (A = {[#proto : %ArrayProto, #class : "Array",]
            "length": {#value 0, #writable true}})

    rec (loop = func(k, to) {
        if (prim("<", k, len)) {
        let (Pk = %ToString(k))
        if (prim("hasProperty", O, Pk)) {
            let (kValue = O[Pk])
            let (argsObj = {[]}) {
            argsObj["0" = kValue];
            argsObj["1" = k];
            argsObj["2" = O];
            argsObj["length" = 3];
            let (selected  = callbackfn(T, argsObj))
            if (%ToBoolean(selected)) {
                %defineOwnProperty(A, %ToString(to),
                           {[] "value" : {#value kValue, #writable true},
                            "writable" : {#value true, #writable true},
                            "enumerable" : {#value true, #writable true},
                            "configurable" : {#value true, #writable true}});
                loop(prim("+", k, 1), prim("+", to, 1))
            } else {
                loop(prim("+", k, 1), to)
            }
            }
        } else {
            loop(prim("+", k, 1), to)
        }
        } else {
        A["length" = to]
        }
    }) {
        loop(0, 0);
        break ret A
    }
    }
}

let [%filter] = {[#code : %filterlambda, #proto : %FunctionProto,]}

let [%reducelambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
    if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not a function in reduce")
    } else { null };

    if (len === 0 && prim("<", args["length"], 2)) {
      %TypeError("Reducing an empty list with not enough arguments.")
    } else { null };

    let (origK = 0)
    let (accumulator = if (prim(">=", args["length"], 2)) { args["1"] } else {
        rec (accumLoop = func(k) {
        if (prim("<", k, len)) {
            let (Pk = %ToString(k))
            let (kPresent = prim("hasProperty", O, Pk))
            if (kPresent) {
            origK := k;
            O[Pk]
            } else {
            accumLoop(prim("+", k, 1))
            }
        } else { %TypeError("In Array reduce") }
        })
        accumLoop(0)
    })

    rec (outerLoop = func(k, accumulator) {
        if (prim("<", k, len)) {
        let (Pk = %ToString(k))
        let (kPresent = prim("hasProperty", O, Pk))
        if (kPresent) {
            let (kValue = O[Pk])
            let (argsObj = {[]}) {
            argsObj["0" = accumulator];
            argsObj["1" = kValue];
            argsObj["2" = k];
            argsObj["3" = O];
            argsObj["length" = 4];
            let (next = callbackfn(undefined, argsObj))
            outerLoop(prim("+", k, 1), next)
            }
        } else {
            outerLoop(prim("+", k, 1), accumulator)
        }
        } else { accumulator }
    })

    break ret outerLoop(origK, accumulator)
    }
}

let [%reduce] = {[#code : %reducelambda, #proto : %FunctionProto,]}

let [%everylambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
    if (prim("typeof", callbackfn) !== "function") {
      %TypeError("Callback not function in every")
    } else { null };

    let (T = args["1"])
    rec (loop = func(k) {
        if (prim("<", k, len)) {
        let (Pk = %ToString(k))
        let (kPresent = prim("hasProperty", O, Pk))
        if (kPresent) {
            let (kValue = O[Pk])
            let (argsObj = {[]}) {
            argsObj["0" = kValue];
            argsObj["1" = k];
            argsObj["2" = O];
            argsObj["length" = 3];
            let (testResult = callbackfn(T, argsObj))
            if (%ToBoolean(testResult) === false) {
                false
            } else {
                loop(prim("+", k, 1))
            }
            }
        } else {
            loop(prim("+", k, 1))
        }
        } else { true }
    })

    break ret loop(0)
    }
}

let [%every] = {[#code : %everylambda, #proto : %FunctionProto,]}

let [%somelambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
    if (prim("typeof", callbackfn) !== "function") {
    %TypeError("Callback not function in some")
    } else { null };

    let (T = args["1"])
    rec (loop = func(k) {
        if (prim("<", k, len)) {
        let (Pk = %ToString(k))
        let (kPresent = prim("hasProperty", O, Pk))
        if (kPresent) {
            let (kValue = O[Pk])
            let (argsObj = {[]}) {
            argsObj["0" = kValue];
            argsObj["1" = k];
            argsObj["2" = O];
            argsObj["length" = 3];
            let (testResult = callbackfn(T, argsObj))
            if (%ToBoolean(testResult) === true) {
                true
            } else {
                loop(prim("+", k, 1))
            }
            }
        } else {
            loop(prim("+", k, 1))
        }
        } else { false }
    })

    break ret loop(0)
    }
}

let [%some] = {[#code : %somelambda, #proto : %FunctionProto,]}

let [%reduceRightLambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (callbackfn = args["0"])

    label ret: {
    if (prim("typeof", callbackfn) !== "function") {
    %TypeError("Callback not function in reduceRight")
    } else { null };

    if (len === 0 && prim("<", args["length"], 2)) {
    %TypeError("Zero-length array in reduceRight")
    } else { null };

    let (origK = prim("-", len, 1))
    let (accumulator = if (prim(">=", args["length"], 2)) { args["1"] } else {
        rec (accumLoop = func(k) {
        if (prim(">=", k, 0)) {
            let (Pk = %ToString(k))
            let (kPresent = prim("hasProperty", O, Pk))
            if (kPresent) {
            origK := k;
            O[Pk]
            } else {
            accumLoop(prim("-", k, 1))
            }
        } else { %TypeError("reduceRight") }
        })
        accumLoop(origK)
    })

    rec (outerLoop = func(k, accumulator) {
        if (prim(">=", k, 0)) {
        let (Pk = %ToString(k))
        let (kPresent = prim("hasProperty", O, Pk))
        if (kPresent) {
            let (kValue = O[Pk])
            let (argsObj = {[]}) {
            argsObj["0" = accumulator];
            argsObj["1" = kValue];
            argsObj["2" = k];
            argsObj["3" = O];
            argsObj["length" = 4];
            let (next = callbackfn(undefined, argsObj))
            outerLoop(prim("-", k, 1), next)
            }
        } else {
            outerLoop(prim("-", k, 1), accumulator)
        }
        } else { accumulator }
    })

    break ret outerLoop(origK, accumulator)
    }
}

let [%reduceRight] = {[#code : %reduceRightLambda, #proto : %FunctionProto,]}


let [%slicelambda] = func(this, args) {
  let (O = %ToObject(this))
  let (A = {[#proto : %ArrayProto, #class : "Array",]
            "length": {#value 0, #writable true}})
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(args["0"]))

  let (initk = if (prim("<", relativeStart, 0)) {
    let (added = prim("+", len, relativeStart))
    if (prim(">", added, 0)) { added } else { 0 }
    } else {
      if (prim("<", relativeStart, len)) { relativeStart } else { len }
    })

  let (relativeEnd = if (args["1"] === undefined) { len }
    else { %ToInteger(args["1"]) })

  let (final = if (prim("<", relativeEnd, 0)) {
    let (added = prim("+", len, relativeEnd))
    if (prim(">", added, 0)) { added } else { 0 }
  } else {
    if (prim("<", relativeEnd, len)) { relativeEnd } else { len }
  })

    rec (loop = func(n, k, finalLen) {
    label ret: {
        if (prim(">=", k, final)) {
        break ret finalLen
        } else { null };

        let (Pk = %ToString(k))
        let (kPresent = prim("hasProperty", O, Pk))
        if (kPresent) {
        let (kValue = O[Pk])
            %defineOwnProperty(A,
                       %ToString(n),
                       {[] "value" : {#value kValue, #writable true},
                    "writable" : {#value true, #writable true},
                    "configurable" : {#value true, #writable true},
                    "enumerable" : {#value true, #writable true}});
        break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
        } else {
        break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
        }
    }}) {

    A["length" = loop(0, initk, 0)];
    A
    }
}

let [%slice] = {[#code : %slicelambda, #proto : %FunctionProto,]}

let [%bindLambda] = func(this, args) {
  label ret: {
    if (prim("typeof", this) !== "function") {
      %TypeError("this not function in bind")
    } else { null };

    let (thisArg = args["0"])
    let (A = %slicelambda(args, %oneArgObj(1)))
    let (mkNewObj = func(proto) {
      let (proto = if(%IsObject(proto)) { proto } else { %ObjectProto })
      {[#proto: proto, #class: "Object", #extensible: true,]}
    })
    let (Flambda = func(this_inner, args_inner) {
      let (thisArg = if (args_inner["%new"]) {
        mkNewObj(this["prototype"])
      } else {
        thisArg
      })
      let (concatted = %concatLambda(A, args_inner))
      this(thisArg, concatted)
    })
    let (F = {[#code : Flambda, #proto : %FunctionProto, #class : "Function",]})
    let (addthrower = func(name) {
      %defineOwnProperty(F,
             name,
             {[] "get" : {#value %ThrowTypeError, #writable true},
          "set" : {#value %ThrowTypeError, #writable true},
          "enumerable" : {#value false, #writable true},
          "configurable" : {#value false, #writable true}})
    })
    let (FLength = if (this[<#class>] === "Function") {
      let (L = prim("-", this["length"], A["length"])) %max(0, L)}
      else { 0 }) {
        %defineOwnProperty(F,
               "length",
               {[] "value" : {#value FLength, #writable true},
            "writable" : {#value false, #writable true},
            "enumerable" : {#value false, #writable true},
            "configurable" : {#value false, #writable true}});

        addthrower("caller");
        addthrower("arguments");
        break ret F
    }
  }
}

let [%bind] = {[#code : %bindLambda, #proto : %FunctionProto,]}

let [%numToStringAbstract] = func(n, r) {
    rec (nts = func(n, r) {
    label ret: {
        if (n !== n) {
        break ret "NaN"
        } else { null };

        if (n === 0) {
        break ret "0"
        } else { null };

        if (prim("<", n, 0)) {
        let (negOne = prim("-", 0, 1))
        let (newN = prim("*", n, negOne))
        break ret prim("string+", "-", nts(newN, r))
        } else { null };

        if (n === +inf) {
        break ret "Infinity"
        } else { null };

        if (r === 10) {
        break ret prim("prim->str", n)
        } else { null };
        break ret prim("base", n, r)
    }})
  nts(n, r)
}

let [%numberToStringlambda] = func(this, args) {
  let (notNumProto = this !== %NumberProto)
  if (notNumProto && this[<#proto>] !== %NumberProto) {
    throw {[#proto : %TypeErrorProto,]}
  } else {
    let (rint = if (args["0"] === undefined) { 10 } else { %ToInteger(args["0"]) })
    if (rint === 10) {
      %numToStringAbstract(this[<#primval>], 10)
    } else {
      if (prim("!", prim("typeof", rint) === "number")) {
        throw "RangeError"
      } else {
        if (prim("<", rint, 2) || prim(">", rint, 36)) {
          throw "RangeError"
        } else {
          %numToStringAbstract(this[<#primval>], rint)
        }
      }
    }
  }
}

let [%numberToString] =
  { [#code : %numberToStringlambda, #proto: %FunctionProto, #class: "Function",] }

let [%StringIndexOflambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (pos = %ToInteger(args["1"]))
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j === searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) !== prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim(">", prim("+", curr, searchLen), len)) { prim("-", 0, 1) } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("+", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%StringIndexOf] = { [#code : %StringIndexOflambda, #proto : %FunctionProto,]}

let [%replacelambda] = func(this, args) {
  let (S = %ToString(this))
  let (search = %ToString(args["0"]))
  let (replace = args["1"])
  if(typeof replace !== "function") { throw "String.replace() only supports functions" }
  else {
    rec (loop = func(str) {
      let (start = %StringIndexOflambda(str, %oneArgObj(search))) {
        if (start === prim("-", 0, 1)) { str }
        else {
          let (replaced = %ToString(replace(undefined, %oneArgObj(replace))))
          let (before = %substringlambda(str, %twoArgObj(0, start)))
          let (afterix = prim("+", start, prim("strlen", search)))
          let (after = %substringlambda(str, %oneArgObj(afterix))) {
            prim("string+", before,
              prim("string+", replaced,
              loop(after)))
          }
        }
      }
    }) {
      loop(S)
    }
  }
}

let [%replace] = { [#code : %replacelambda, #proto : %FunctionProto,] }


let [%sliolambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (numPos = %ToNumber(args["1"]))
  let (pos =
    if (numPos !== numPos) {
      +inf
    } else { %ToInteger(numPos) })
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j === searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) !== prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim("<", curr, 0)) { prim("-", 0, 1) } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("-", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%StringLastIndexOf] = {[#code : %sliolambda, #proto : %FunctionProto,]}

let [%localeCompareLambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (That = %ToString(args["0"]))
  prim("locale-compare", S, That)
}

let [%localeCompare] = {[#code : %localeCompareLambda, #proto : %FunctionProto,]}

let [%stringSliceLambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (end = args["1"])
  let (intEnd = if (end === undefined) { len } else { %ToInteger(end) })
  let (from = if (prim("<", intStart, 0)) {
    %max(prim("+", len, intStart), 0) } else { %min(intStart, len) })
  let (to = if (prim("<", intEnd, 0)) {
    %max(prim("+", len, intEnd), 0) } else { %min(intEnd, len) })
  let (span = %max(prim("-", to, from), 0))
  rec (build = func(i, result) {
    if (prim("<", i, span)) {
      let (next = prim("string+", result, prim("char-at", S, prim("+", from, i))))
      build(prim("+", i, 1), next)
    } else { result }
  })
  build(0, "")
}

let [%stringSlice] = {[#code : %stringSliceLambda, #proto : %FunctionProto,]}

let [%tlclambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-lower", S)
}

let [%toLowerCase] = {[#code : %tlclambda, #proto : %FunctionProto,]}

let [%tuclambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-upper", S)
}

let [%toUpperCase] = {[#code : %tuclambda, #proto : %FunctionProto,]}

let [%splitLambda] = func(this, args) {
  "String.prototype.split NYI"
}

let [%split] = {[#code : %splitLambda, #proto : %FunctionProto,]}

let [%IsFinite] = func(n) {
  prim("!", (n !== n || n === +inf || n === -inf))
}

// http://es5.github.com/#x15.9.1.2
let [%msPerDay] = 86400000
let [%msPerHour] = 3600000
let [%msPerMin] = 60000
let [%msPerSecond] = 1000
let [%Day] = func(t) { prim("floor", prim("/", t, %msPerDay)) }
let [%TimeWithinDay] = func(t) { prim("%", t, %msPerDay) }

// http://es5.github.com/#x15.9.1.3
let [%DaysInYear] = func(y) {
  if (prim("%", y, 4) !== 0) {
    365
  }
  else {
    if (prim("%", y, 400) === 0 || prim("%", y, 100) !== 0) {
      366
    }
    else {
      365
    }
  }
}

// http://es5.github.com/#DayFromYear
let [%DayFromYear] = func(y) {
  let (fragment = func(offset, coefficient) {
    prim("floor", prim("/", prim("-", y, offset), coefficient))
  })
  let (base = prim("*", 365, prim("-", y, 1970)))
  let (part1 = fragment(1969, 4))
  let (part2 = fragment(1901, 100))
  let (part3 = fragment(1601, 400))
  prim("+", prim("-", prim("+", base, part1), part2), part3)
}

// http://es5.github.com/#TimeFromYear
let [%TimeFromYear] = func(y) {
  prim("*", %msPerDay, %DayFromYear(y))
}

// http://es5.github.com/#YearFromTime
let [%YearFromTime] = func(t) {
  let (sign = if (prim(">", t, 0)) {1} else { prim("-", 0, 1) })
  let (start = if (sign === 1) {1969} else {1970})
  rec (loop = func(y) {
    if (prim("<=", %TimeFromYear(y), t)
        && prim(">", %TimeFromYear(prim("+", 1, y)), t)) {
      y
    }
    else {
      loop(prim("+", y, sign))
    }
  })
  loop(start)
}

// http://es5.github.com/#x15.9.1.4
let [%DayWithinYear] = func(t) {
  prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
}

// http://es5.github.com/#InLeapYear
let [%InLeapYear] = func(t) {
  if(%DaysInYear(%YearFromTime(t)) === 365) {
    0
  } else {
    1
  }
}

let [%DaysInMonth] = func(m, leap) {
  let (m = prim("%", m, 12))
  if (m === 3 || m === 5 || m === 8 || m === 10) {
    30
  } else if (m === 1) {
    prim("+", 28, leap)
  } else {
    31
  }
}

// http://es5.github.com/#x15.9.1.4
let [%MonthFromTime] = func(t) {
  let (DayWithinYear = func(t) {
    prim("-", %Day(t), %DayFromYear(%YearFromTime(t)))
  })
  let (CheckLeapRange = func(start, end) {
    prim("<=", prim("+", start, %InLeapYear(t)), DayWithinYear(t)) &&
    prim("<", DayWithinYear(t), prim("+", end, %InLeapYear(t)))
  })
  if (prim("<=", 0, %DayWithinYear(t)) &&
      prim("<", %DayWithinYear(t), 31)) {
    0
  } else if(prim("<=", 31, %DayWithinYear(t)) &&
            prim("<", %DayWithinYear(t), prim("+", 59, %InLeapYear(t)))) {
    1
  }
  else if(CheckLeapRange(59, 90)) { 2 }
  else if(CheckLeapRange(90, 120)) { 3 }
  else if(CheckLeapRange(120, 151)) { 4 }
  else if(CheckLeapRange(151, 181)) { 5 }
  else if(CheckLeapRange(181, 212)) { 6 }
  else if(CheckLeapRange(212, 243)) { 7 }
  else if(CheckLeapRange(243, 273)) { 8 }
  else if(CheckLeapRange(273, 304)) { 9 }
  else if(CheckLeapRange(304, 334)) { 10 }
  else if(CheckLeapRange(334, 365)) { 11 }
  else { %TypeError("Something terrible in date %MonthFromTime")}
}

// http://es5.github.com/#x15.9.1.5
let [%DateFromTime] = func(t) {
  let (mft = %MonthFromTime(t))
  let (CalcDay = func(offset) {
    prim("-", prim("-", %DayWithinYear(t), offset), %InLeapYear(t))
  })
  if (mft === 0) { prim("+", %DayWithinYear(t), 1) }
  else if (mft === 1) { prim("-", %DayWithinYear(t), 30) }
  else if (mft === 2) { CalcDay(58) }
  else if (mft === 3) { CalcDay(89) }
  else if (mft === 4) { CalcDay(119) }
  else if (mft === 5) { CalcDay(150) }
  else if (mft === 6) { CalcDay(180) }
  else if (mft === 7) { CalcDay(211) }
  else if (mft === 8) { CalcDay(242) }
  else if (mft === 9) { CalcDay(272) }
  else if (mft === 10) { CalcDay(303) }
  else if (mft === 11) { CalcDay(333) }
  else { %TypeError("Something terrible happened in %DateFromTime")}
}

let [%LocalTime] = func(t) { t }

let [%MakeDate] = func(day, time) { prim("+", prim("*", day, %msPerDay), time) }

// http://es5.github.com/#x15.9.1.12
// Implementation draws heavily from the date test harness
let [%MakeDay] = func(yr, mt, date) {
  if (prim("!", (%IsFinite(yr) && %IsFinite(mt) && %IsFinite(date)))) {
    NaN
  }
  else {
    let (y = %ToInteger(yr))
    let (m = %ToInteger(mt))
    let (dt = %ToInteger(date))
    let (ym = prim("+", y, prim("floor", prim("/", m, 12))))
    let (mn = prim("%", m, 12))
    let (yt = %TimeFromYear(y))
    rec (loop = func(t, mo, leap) {
      if(prim("<", mo, m)) {
        let (leap = %InLeapYear(t))
        let (t = prim("+", t, prim("*", %DaysInMonth(mo, leap), %msPerDay)))
        loop(t, prim("+", mo, 1), leap)
      } else {
        t
      }
    }) {
    let (t = loop(yt, 0, %InLeapYear(yt)))
    if (%YearFromTime(t) !== ym ||
        %MonthFromTime(t) !== mn ||
        %DateFromTime(t) !== 1) {
      NaN
    } else {
      prim("-", prim("+", %Day(t), dt), 1)
    }
  }
  }
}

let [%MakeTime] = func(h, m, s, ms) {
  if (prim("!", (%IsFinite(h) && %IsFinite(m) && %IsFinite(s) && %IsFinite(ms)))) {
    NaN
  }
  else {
    let (hour = %ToInteger(h))
    let (min = %ToInteger(m))
    let (sec = %ToInteger(s))
    let (millis = %ToInteger(ms))
    let (t = prim("+",
      prim("+",
        prim("+",
          prim("*", hour, %msPerHour),
          prim("*", min, %msPerMin)),
        prim("*", sec, %msPerSecond)),
      millis)) {
      t
    }
  }

}

// http://es5.github.com/#x15.9.1.9
// S5 has no time zone adjustments or daylight savings time.
// It is, for the time being, indifferent to your i18n and l10n concerns.
let [%UTC] = func(t) { t }

let [%getYearlambda] = func(this, args) { 78 } // TODO: implement

let [%getYear] = { [#code : %getYearlambda,] }

let [%getMonthlambda] = func(this, args) { 3 } // TODO: implement

let [%getMonth] = { [#code: %getMonthlambda,] }

let [%DateProto] = {
  [#proto : %ObjectProto, #class: "Date",]
  "getYear" : {#value %getYear, #writable false},
  "getMonth": {#value %getMonth, #writable false},
}

let [%dateToStringLambda] = func(this, args) {
  "Date toString NYI"
}

let [%dateToString] = {[#code : %dateToStringLambda, #proto : %FunctionProto,]}

let [%dateValueOfLambda] = func(this, args) {
  this[<#primval>]
}

let [%dateValueOf] = {[#code : %dateValueOfLambda, #proto : %FunctionProto,]}

// http://es5.github.com/#x15.9.1.14
let [%TimeClip] = func(t) {
  if (prim("!", %IsFinite(t) &&
      prim("<=", prim("abs", t), 8.64e15))) {
    NaN
  } else {
    %ToInteger(t)
  }
}

let [%DateConstructor] = func(this, args) {
  let (calledAsFunction = this === undefined)
  let (nargs = args["length"])
  if (calledAsFunction) {
    let (v = %getCurrentUTC())
    let (o =
    { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : v,] })
    %dateToStringLambda(o, {[]})
  } else {
    if (nargs === 0) {
      let (v = %getCurrentUTC())
      { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : v,] }
    }
    else if (nargs === 1) {
      let (v = %ToPrimitive(args["0"]))
      let (V =
        if (prim("typeof", v) === "string") { %parse(v) } else { %ToNumber(v) })
      let (clipped = %TimeClip(V))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : clipped,] }
    } else {
      let (y = %ToNumber(args["0"]))
      let (m = %ToNumber(args["1"]))
      let (dt = if (args["2"] === undefined) { 1 } else { %ToNumber(args["2"]) })
      let (h = if (args["3"] === undefined) { 0 } else { %ToNumber(args["3"]) })
      let (min = if (args["4"] === undefined) { 0 } else { %ToNumber(args["4"]) })
      let (s = if (args["5"] === undefined) { 0 } else { %ToNumber(args["5"]) })
      let (milli = if (args["6"] === undefined) { 0 } else { %ToNumber(args["6"]) })
      let (yr =
        let (tiy = %ToInteger(y))
        let (rangecond1 = prim("<", 0, tiy) || 0 === tiy)
        let (rangecond2 = prim("<", tiy, 99) || tiy === 99)
        if (y !== y && rangecond1 && rangecond2) {
          prim("+", 1900, tiy) } else { y })
      let (finalDate = %MakeDate(%MakeDay(yr, m, dt), %MakeTime(h, min, s, milli)))
      let (primval = %TimeClip(%UTC(finalDate))) {
        { [#proto : %DateProto, #class : "Date", #extensible : true, #primval : primval,] }
      }
    }
  }
}

let [%DateGlobalFuncObj] = { [#code : %DateConstructor, #proto : %FunctionProto,]
                             "prototype" : {#value %DateProto, #writable true} }

// http://es5.github.com/#x15.9.5.26
let [%dateGetTimezoneOffsetLambda] = func(this, args) {
  let (t = this[<#primval>])
  if (t === NaN) { NaN }
  else {
    0
  }
}

let [%dateGetTimezoneOffset] = {[
    #code : %dateGetTimezoneOffsetLambda,
    #proto : %FunctionProto,
  ]}

let [%dategetDayLambda] = func(this, args) {
  let (day = prim("floor", prim("/", this[<#primval>], %msPerDay)))
  let (weekday = prim("%", prim("+", day, 4), 7)) {
    weekday
  }
}

let [%dategetDay] = {[#code : %dategetDayLambda, #proto : %FunctionProto,]}

let [%dategetDateLambda] = func(this, args) {
  let (t = this[<#primval>])
  if (t === NaN) { t } else { %DateFromTime(%LocalTime(t)) }
}

let [%dategetDate] = {[#code: %dategetDateLambda, #proto : %FunctionProto,]}

let [%defineNYIProperty] = func(base, name) {
  let (unimplFunc = func(this, args) {
    %TypeError(prim("string+", name, " NYI"))
  })
  let (unimplObj = {[#code: unimplFunc, #proto: %FunctionProto,]})
  %define15Property(base, name, unimplObj)
}

let [%testlambda] = func(this, args) {
  prim("print", "You used the es5.env testlambda.  Are you sure you didn't forget to include the regexp.js library, or regexp.env?")
}

let [%test] = { [#code : %testlambda,] }

let [%RegExpProto] = { [#proto : %ObjectProto,]
  "test" : {#value %test, #writable false} }

let [%RegExpConstructor] = func(this, args) {
  {[#proto : %RegExpProto,]}
}

let [%RegExpGlobalFuncObj] = {[#code : %RegExpConstructor, #proto : %FunctionProto,]
  "prototype" : {#value %RegExpProto, #writable false},
  "length" : {#value 2,
              #writable false,
              #configurable false,
              #enumerable false}}

let [%parseIntlambda] = func(this, args) {
  let (numstr = %ToString(args["0"]))
  prim("numstr->num", numstr)
}

let [%parseInt] = { [#code : %parseIntlambda, #proto : %FunctionProto,] }

let [%decodeURILambda] = func(this, args) {
  "decodeURI NYI"
}

let [%decodeURI] = {[#code : %decodeURILambda, #proto: %FunctionProto,]}

let [%decodeURIComponentLambda] = func(this, args) {
  "decodeURIComponent NYI"
}

let [%decodeURIComponent] = {[#code : %decodeURIComponentLambda, #proto: %FunctionProto,]}

let [%encodeURILambda] = func(this, args) {
  "encodeURI NYI"
}

let [%encodeURI] = {[#code : %encodeURILambda, #proto: %FunctionProto,]}

let [%encodeURIComponentLambda] = func(this, args) {
  "encodeURIComponent NYI"
}

let [%encodeURIComponent] = {[#code : %encodeURIComponentLambda, #proto: %FunctionProto,]}

let [%explambda] = func() {
  undefined
}

let [%exp] = { [#code : %explambda,] }

let [%Math] = { []
  "E" : {#value 2.7182818284590452354, #writable false},
  "LN10": {#value 2.302585092994046, #writable false},
  "LN2" : {#value 0.6931471805599453, #writable false},
  "LOG2E" : {#value 1.4426950408889634, #writable false},
  "LOG10E" : {#value 0.4342944819032518, #writable false},
  "PI" : {#value 3.141592653589793, #writable false},
  "SQRT1_2" : {#value 0.7071067811865476, #writable false},
  "SQRT2" : {#value 1.4142135623730951, #writable false},
  "exp" : {#value %exp, #writable false} }

let [%minMaxLambda] = func(this, args, op, init) {
  let (end = args["length"])

    label ret: {
    if (end === 0) {
        break ret init
    } else { null };

    rec (loop = func(best, i) {
        if (prim("<", i, end)) {
        let (curr = %ToNumber(args[prim("prim->str", i)]))
        if (curr !== curr) {
            break ret NaN
        } else { null };

        loop(op(best, curr), prim("+", i, 1))
        } else { best }
    })
    break ret loop(init, 0)
    }
}

let [%mathMinLambda] = func(this, args) {
  %minMaxLambda(this, args, %min, +inf)
}

let [%mathMin] = {[#code : %mathMinLambda, #proto : %FunctionProto,]}


let [%mathMaxLambda] = func(this, args) {
  %minMaxLambda(this, args, %max, -inf)
}

let [%mathMax] = {[#code : %mathMaxLambda, #proto : %FunctionProto,]}


let [%mathAbsLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
    label ret: {
    if (n !== n) { break ret n } else { null };
    if (n === -inf) { break ret +inf} else { null };
    break ret prim("abs", n)
    }
}

let [%mathAbs] = {[#code : %mathAbsLambda, #proto : %FunctionProto,]}

let [%acosLambda] = func(this, args) {
  "acos NYI"
}

let [%acos] = {[#code : %acosLambda, #proto : %FunctionProto,]}


let [%asinLambda] = func(this, args) {
  "asin NYI"
}

let [%asin] = {[#code : %asinLambda, #proto : %FunctionProto,]}

let [%atanLambda] = func(this, args) {
  "atan NYI"
}

let [%atan] = {[#code : %atanLambda, #proto : %FunctionProto,]}

let [%atan2Lambda] = func(this, args) {
  "atan2 NYI"
}

let [%atan2] = {[#code : %atan2Lambda, #proto : %FunctionProto,]}

let [%cosLambda] = func(this, args) {
  "cos NYI"
}

let [%cos] = {[#code : %cosLambda, #proto : %FunctionProto,]}

let [%randomLambda] = func(this, args) {
  4 // IEEE-Vetted random number
}

let [%random] = {[#code : %randomLambda, #proto : %FunctionProto,]}


let [%roundLambda] = func(this, args) {
  "round NYI"
}

let [%round] = {[#code : %roundLambda, #proto : %FunctionProto,]}

let [%sinLambda] = func(this, args) {
  let (n = %ToNumber(args["0"])) {
    label ret: {
      if (n !== n) {
        break ret n
      } else { null };

      if (n === 0) {
        break ret n
      } else { null };

      if (n === +inf) {
        break ret NaN
      } else { null };

      if (n === -inf) {
        break ret NaN
      } else { null };

      break ret prim("sin", n)
    }
  }
}

let [%sin] = {[#code : %sinLambda, #proto : %FunctionProto,]}

let [%sqrtLambda] = func(this, args) {
  "sqrt NYI"
}

let [%sqrt] = {[#code : %sqrtLambda, #proto : %FunctionProto,]}

let [%tanLambda] = func(this, args) {
  "tan NYI"
}

let [%tan] = {[#code : %tanLambda, #proto : %FunctionProto,]}

let [%mathLogLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
    label ret: {
    if (n !== n) { break ret n } else { null };
    if (prim("<", n, 0)) { break ret NaN } else { null };
    if (n === 0) { break ret -inf } else { null };
    if (n === 1) { break ret 0 } else { null };
    if (n === +inf) { break ret n } else { null };
    break ret prim("log", n)
    }
}

let [%mathLog] = {[#code : %mathLogLambda, #proto : %FunctionProto,]}

let [%mathCeilLambda] = func(this, args) {
  let (x = %ToNumber(args["0"]))
    label ret: {
    if (x !== x || x === 0 || x === -inf || x === +inf) {
        break ret x
    } else { null };
    break ret prim("ceil", x)
    }
}

let [%mathCeil] = {[#code : %mathCeilLambda, #proto : %FunctionProto,]}

let [%mathFloorLambda] = func(this, args) {
  let (x = %ToNumber(args["0"]))
    label ret: {
    if (x !== x || x === 0 || x === -inf || x === +inf) {
        break ret x
    } else { null };
    break ret prim("floor", x)
    }
}

let [%mathFloor] = {[#code : %mathFloorLambda, #proto : %FunctionProto,]}

let [%PrimAdd] = func(l, r) {
    let (l = %ToPrimitive(l))
    let (r = %ToPrimitive(r))
  if (prim("typeof", l) === "string") {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else if (prim("typeof", r) === "string") {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else {
    let (lnum = prim("prim->num", l))
    let (rnum = prim("prim->num", r))
    prim("+", lnum, rnum)
  }
}

let [%PrefixOp] = func(obj, fld, op) {
  let (oldValue = %ToNumber(obj[fld]))
    let (newValue = op(oldValue, 1)) {
    obj[fld = newValue];
    newValue
    }
}

let [%PrefixIncrement] = func(obj, fld) {
  %PrefixOp(obj, fld, %PrimAdd)
}

let [%mathPowLambda] = func(this, args) {
    let (x = %ToNumber(args["0"]))
    let (y = %ToNumber(args["1"]))

    label ret: {
    if (y !== y) {
            break ret NaN
    } else { null };

    if (y === 0) {
            break ret 1
    } else { null };

    if (x !== x && y !== 0) {
            break ret NaN
    } else { null };

    let (absX = prim("abs", x)) {
    if (prim(">", absX, 1) && y === +inf) {
            break ret +inf
    } else { null };

    if (prim(">", absX, 1) && y === -inf) {
            break ret 0
    } else { null };

    if (absX === 1 && ((y === +inf) || (y === -inf))) {
            break ret NaN
    } else { null };

    if (prim("<", absX, 1) && y === +inf) {
            break ret 0
    } else { null };

    if (prim("<", absX, 1) && y === -inf) {
            break ret +inf
    } else { null };

    if (x === +inf && prim(">", y, 0)) {
            break ret +inf
    } else { null };

    if (x === +inf && prim("<", y, 0)) {
            break ret 0
    } else { null };

    let (isOdd = func(n) {
            let (divided = prim("/", n, 2))
            (prim("floor", n) === n) && (prim("floor", divided) !== divided)
    }) {
    if (x === -inf && prim(">", y, 0)) {
            break ret if (isOdd(y)) { -inf } else { +inf }
    } else { null };

    if (x === -inf && prim("<", y, 0)) {
            break ret 0
    } else { null };

    if (x === 0 && prim(">", y, 0)) {
            break ret 0
    } else { null };

    if (x === 0 && prim("<", y, 0)) {
            break ret +inf
    } else { null };

    // If x is -0 and y<0 and y is an odd integer, the result is -inf
    // If x is -0 and y<0 and y is not an odd integer, the result +inf
    let (oddY = isOdd(y))
    if (x === 0 && prim("<", y, 0) && oddY) {
            break ret -inf
    } else { null };
    if (x === 0 && prim("<", y, 0)) {
            break ret +inf
    } else { null };

    let (isFinite = func(n) {
            n !== +inf && n !== -inf
    })
    let (finiteX = isFinite(x))
    let (finiteY = isFinite(y))
    if (prim("<", x, 0) && finiteX && finiteY && prim("floor", y) !== y) {
            break ret NaN
    } else { null };

    break ret prim("pow", x, y)
    }}}
}

let [%mathPow] = {[#code : %mathPowLambda, #proto : %FunctionProto,]}

let [%valueOfLambda] = func(this, args, proto, typestr) {
  let (hasWrongProto = this[<#proto>] !== proto)
  let (hasWrongTypeof = typeof(this) !== typestr)
  let (isntProto = this !== proto)
  if (hasWrongProto && hasWrongTypeof && isntProto) {
    %TypeError("valueOf")
  } else {
    if (hasWrongTypeof) { this[<#primval>] } else { this }
  }
}

let [%stringValueOf] =
  {[#code : func(this, args) {
      %valueOfLambda(this, args, %StringProto, "string")
    },
    #proto : %FunctionProto,]}

let [%numValueOf] =
  {[#code : func(this, args) {
      %valueOfLambda(this, args, %NumberProto, "number")
    },
    #proto : %FunctionProto,]}

let [%booleanValueOf] =
 {[#code : func(this, args) {
    %valueOfLambda(this, args, %BooleanProto, "boolean")
  },
  #proto : %FunctionProto,]}

let [%toFixedLambda] = func(this, args) {
  let (f = %ToInteger(args["0"]))
    label ret: {
      if (prim("<", f, 0) || prim(">", f, 20)) {
        throw %JSError({[#proto : %RangeErrorProto,]})
      } else { null };

      let (x = if (prim("typeof", this) === "number") { this }
               else { this[<#primval>] })
      if (x !== x) {
        break ret "NaN"
      } else { null };

      if (prim(">=", x, 1e21)) {
        break ret %ToString(x)
      } else { null };

      break ret prim("to-fixed", x, f)
    }
}

let [%toFixed] = {[#code : %toFixedLambda, #proto : %FunctionProto,]}

let [%numTLSLambda] = func(this, args) {
  let (x = if (prim("typeof", this) === "number") { this }
    else { this[<#primval>] })
  let (obj = {[#proto : %StringProto, #primval : prim("prim->str", x),]})
  %toLocaleStringLambda(obj, {[]})
}

let [%numTLS] = {[#code : %numTLSLambda, #proto : %FunctionProto,]}

let [%toExponentialLambda] = func(this, args) {
  // TODO: implement
  "toExponential NYI"
}

let [%toExponential] = {[#code : %toExponentialLambda, #proto : %FunctionProto,]}

let [%toPrecisionLambda] = func(this, args) {
  // TODO: implement
  "toPrecision NYI"
}

let [%toPrecision] = {[#code : %toPrecisionLambda, #proto : %FunctionProto,]}

let [%PrimSub] = func(l, r) {
    let (l = %ToNumber(l))
    let (r = %ToNumber(r))
    prim("-", l, r)
}

let [%BitwiseAnd] = func(l, r) {
  prim("&", %ToInt32(l), %ToInt32(r))
}

let [%SignedRightShift] = func(l, r) {
  prim(">>", %ToInt32(l), %ToUint32(r))
}

let [%LeftShift] = func(l, r) {
  prim("<<", %ToInt32(l), %ToUint32(r))
}

let [%UnsignedRightShift] = func(l, r) {
  prim(">>>", %ToUint32(l), %ToUint32(r))
}

let [%PrefixDecrement] = func(obj, fld) {
  %PrefixOp(obj, fld, %PrimSub)
}

let [%PostfixOp] = func(obj, fld, op) {
  let (oldValue = %ToNumber(obj[fld]))
    let (newValue = op(oldValue, 1)) {
    obj[fld = newValue];
    oldValue
    }
}

let [%PostDecrement] = func(obj, fld) {
  %PostfixOp(obj, fld, %PrimSub)
}

let [%PostIncrement] = func(obj, fld) {
  %PostfixOp(obj, fld, %PrimAdd)
}

let [%PrimMultOp] = func(l, r, op) {
  let (lNum = %ToNumber(l))
  let (rNum = %ToNumber(r))
  op(lNum, rNum)
}

let [%CompareOp] = func(l, r, LeftFirst) {
  let (rest = func(px, py) {
    let (pxtype = prim("typeof", px))
    let (pytype = prim("typeof", py))

    label ret: {
      if (pxtype !== "string" || pytype !== "string") {
        let (nx = %ToNumber(px))
        let (ny = %ToNumber(py)) {

          if (nx !== nx || ny !== ny) {
            break ret undefined
          } else { null };

          if (nx === ny) {
            break ret false
          } else { null };

          // TODO(matt): not sure how to compare -0 vs. 0

          if (nx === +inf) {
            break ret false
          } else { null };

          if (ny === +inf) {
            break ret true
          } else { null };

          if (ny === -inf) {
            break ret false
          } else { null };

          if (nx === -inf) {
            break ret true
          } else { null };

          break ret prim("<", nx, ny)
        }
      } else {
        //break ret prim("strcmp", px, py)
        break ret prim("string<", px, py)
      }
    }
  })

  if (LeftFirst) {
    let (px = %ToPrimitiveHint(l, "number"))
    let (py = %ToPrimitiveHint(r, "number"))
    rest(px, py)
  } else {
    let (py = %ToPrimitiveHint(r, "number"))
    let (px = %ToPrimitiveHint(l, "number"))
    rest(px, py)
  }
}

let [%LessThan] = func(l, r) {
  let (result = %CompareOp(l, r, true))
  if (result === undefined) { false } else { result }
}

let [%GreaterThan] = func(l, r) {
  let (result = %CompareOp(r, l, false))
  if (result === undefined) { false } else { result }
}

let [%LessEqual] = func(l, r) {
  let (result = %CompareOp(r, l, false))
  (result !== undefined) && prim("!", result)
}

let [%GreaterEqual] = func(l, r) {
  let (result = %CompareOp(l, r, true))
  (result !== undefined) && prim("!", result)
}

let [%BitwiseInfix] = func(l, r, op) {
  let (lnum = %ToInt32(l))
  let (rnum = %ToInt32(r))
  op(lnum, rnum)
}


let [%EnvCheckAssign] = func(context, id, val, strict) {
  if (%isUnbound(context, id) && strict) {
    throw %JSError(
      {[#proto : %ReferenceErrorProto,] message: {#value id, #writable true}}
    )
  } else {
    try {
      %set-property(context, id, val)
    } catch {
      %UnwritableDispatch(id)
    }
  }
}

// 11.4.6
let [%UnaryPlus] = func(expr) {
  %ToNumber(expr)
}

// 11.4.7
let [%UnaryNeg] = func(expr) {
  let (oldValue = %ToNumber(expr))
  if (oldValue !== oldValue) {
    // NaN
    oldValue
  } else {
    let (negOne = prim("-", 0, 1))
    prim("*", oldValue, negOne)
  }
}

let [%BitwiseNot] = func(expr) {
  let (oldValue = %ToInt32(expr))
  prim("~", oldValue)
}

let [%logLambda] = func(o, s) {
  rec (loop = func(i) {
    if (prim("hasProperty", s, prim("prim->str", i))) {
      prim("pretty", s[prim("prim->str", i)]);
      loop(prim("+", i, 1))
    } else {
      undefined
    }
  })
  loop(0)
}

let [%log] = { [#code : %logLambda, #proto: %FunctionProto,] }

let [%console] = {
  [#proto: null,]
  "log": {#value %log, #writable false},
  "info": {#value %log, #writable false},
  "warn": {#value %log, #writable false},
  "error": {#value %log, #writable false}
}

let [%makeContextVarDefiner] = func() {
  let (envstore = {[#extensible: true,]})
  func(context, id) {
    // If we are using the real, honest-to-goodness global context,
    // then we should be adding bindings to global.  This will only happen
    // if the passed context is %nonstrictContext from an indirect eval
    let (envstore = if (context === %globalContext) { %global } else { envstore})
    if (prim("hasOwnProperty", context, id)) {
      if (prim("!", prim("hasProperty", envstore, id))) {
        envstore[id = undefined]
      };
      undefined /* do nothing, var exists */
    } else {

      // This line is necessary for global vars to appear with just a var
      // statement and no assignment
      envstore[id = undefined];
      let (%setter = {[#code: func(this, args) {
        if (prim("hasProperty", envstore, id)) {
          envstore[id = args["0"]]
        }
        else {
          %UnboundId(id)
        }
      },]})
      let (%getter = {[#code: func(this, args) {
        if (prim("hasProperty", envstore, id)) {
          envstore[id]
        }
        else {
          %UnboundId(id)
        }
      },]})
      %defineOwnProperty(context, id, {[]
        "get": {#value %getter, #writable true},
        "set": {#value %setter, #writable true}
      })
    }
  }
}

let [%configurableEval] = func(evalThis, evalContext, useStrict, args) {
  let (evalStr = args["0"])
  let (evalStr = if (useStrict) {
    prim("string+", "'use strict';", evalStr)
  } else {
    evalStr
  })
  let (globalEnv = %makeGlobalEnv()) {
    globalEnv["%this" = evalThis];
    globalEnv["%strictContext" = {[#proto: evalContext, #extensible: true, #primval: true,]}];
    globalEnv["%nonstrictContext" = evalContext];
    globalEnv["%defineGlobalVar" = %makeContextVarDefiner()];
    if (typeof evalStr === 'string') {
      @eval(evalStr, globalEnv)
    } else {
      evalStr
    }
  }
}

let [%evallambda] = func(this, args) {
  %configurableEval(%global, %globalContext, false, args)
}

let [%eval] = { [#code : %evallambda,] }

let [%maybeDirectEval] = func(theThis, theContext, args, strict) {
  let (contextEval = theContext["eval"])
  if (contextEval === %eval) {
    %configurableEval(theThis, theContext, strict, args)
  } else {
    %AppExprCheck(contextEval, args)
  }
}

let [%FunctionConstructor] = func(this, args) {
  let (argCount = args["length"])
  rec (formArgString = func(n, result) {
    if (n === prim("-", argCount, 1)) {
      result
    } else {
      let (currentArg = %ToString(args[prim("prim->str", n)]))
      let (next =
        if (n === prim("-", argCount, 2)) {
          prim("string+", result, currentArg)
        } else {
          prim("string+", prim("string+", result, currentArg), ",")
        })
      formArgString(prim("+", n, 1), next)
    }
  })
  let (body =
    if (argCount === 0) { "" } else {
      args[prim("prim->str", prim("-", argCount, 1))]
    })
  let (P = if (argCount === 0 || argCount === 1) { "" }
    else { formArgString(0, "") })
  let (prefix =
    prim("string+", "((function(){ return function (",
                    prim("string+", P, "){")))
  let (final = prim("string+", prefix, prim("string+", body, "}; })());")))
  %evallambda(undefined, {[] "0": {#value final, #writable false}})
}

let [%FunctionGlobalFuncObj] =
  { [#code : %FunctionConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %FunctionProto, #writable false},
    "length" : {#value 0, #writable false}
  }

let [%isFiniteLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
  %IsFinite(n)
}

let [%isFinite] = {[#code : %isFiniteLambda, #proto : %FunctionProto,]}

let [%parseFloatLambda] = func(this, args) {
  "parseFloat NYI"
}

let [%parseFloat] = {[#code : %parseFloatLambda, #proto : %FunctionProto,]}

let [%escapeLambda] = func(this, args) {
  "escape NYI"
}

let [%escape] = {[#code : %escapeLambda, #proto : %FunctionProto,]}

let [%unescapeLambda] = func(this, args) {
  "unescape NYI"
}

let [%unescape] = {[#code : %unescapeLambda, #proto : %FunctionProto,]}

let [%makeWithContext] = func(context, object) {
  let (names = %propertyNames(object, true))
  let (mksetter = func(id) {
   {[#code: func(this, args) {
     if(prim("hasProperty", object, id)) {
       object[id = args["0"]]
     } else {
       context[id = args["0"]]
     }
    },]}
  })
  let (mkgetter = func(id) {
   {[#code: func(this, args) {
     if(prim("hasProperty", object, id)) {
       object[id]
     } else {
       context[id]
     }
    },]}
  })
  let (newcontext = {[#extensible: true, #proto: context,]})
  let (addBinding = func(id) {
    %defineOwnProperty(newcontext, id, {[]
      "set": {#value mksetter(id), #writable true},
      "get": {#value mkgetter(id), #writable true},
      "configurable": {#value true, #writable true},
      "enumerable": {#value true, #writable true}
    })
  }) {
    %primEach(names, addBinding);
    newcontext
  }
}

// Set up global environment
let [%this] = %global
let [%strictContext] = %globalContext
let [%nonstrictContext] = %globalContext
