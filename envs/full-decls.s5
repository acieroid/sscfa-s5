let (%throwUnboundIDErrors = false)
let (%makeGlobalEnv = undefined)
let (%ObjectProto = {[#proto: null, #class: "Object", #extensible: true,]})
let (%global = {[#proto: %ObjectProto, #class: "Object", #extensible: true,]})
let (%globalContext = {[#proto: %global, #class: "Object", #extensible: true,]})
let (%Immut = func(obj , prop)
              {prim("pretty", obj);
               obj[prop<#enumerable>=false];
               obj[prop<#configurable>=false]})
let (%isUnbound = func(context , id)
                  {if (prim("stx=", prim("protoOfField", context, id) , %globalContext))
                      {prim("!", prim("hasProperty", %global , id))}
                      else
                      {false}})
let (%FunctionProto = {[#proto: %ObjectProto,
                        #code: func(this , args)
                               {undefined},
                        #class: "Function",
                        #extensible: true,]
                       'length' : {#value (0.) ,
                                   #writable true ,
                                   #configurable false}})
let (%functionToStringlambda = func(this , args)
                               {"function ToString"})
let (%functionToString = {[#proto: %FunctionProto,
                           #code: %functionToStringlambda,
                           #class: "Function",
                           #extensible: true,]
                          'length' : {#value (0.) ,
                                      #writable false ,
                                      #configurable false}})
let (%ErrorProto = {[#proto: %ObjectProto,
                     #class: "Error",
                     #extensible: true,]})
let (%TypeErrorProto = {[#proto: %ErrorProto,
                         #class: "Object",
                         #extensible: true,]})
let (%MakeTypeError = func(msg)
                      {let (msg = if (prim("stx=", prim("typeof", msg) , "object"))
                                     {"object passed to ThrowTypeError"}
                                     else
                                     {prim("prim->str", msg)})
                       {[#proto: %TypeErrorProto,
                         #class: "Object",
                         #extensible: true,]
                        'message' : {#value (msg) ,
                                     #writable false ,
                                     #configurable false}}})
let (%IsJSError = func(thing)
                  {if (prim("stx=", prim("typeof", thing) , "object"))
                      {prim("hasOwnProperty", thing , "%js-exn")}
                      else
                      {false}})
let (%ToJSError = func(maybe-js-error)
                  {if (%IsJSError(maybe-js-error))
                      {maybe-js-error["%js-exn" , {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]}]}
                      else
                      if (prim("stx=", maybe-js-error , "unwritable-field"))
                         {%MakeTypeError("Field not writable")}
                         else
                         if (prim("stx=", maybe-js-error , "unconfigurable-delete"))
                            {%MakeTypeError("Field not deletable")}
                            else
                            {throw maybe-js-error}})
let (%JSError = func(err)
                {{[#proto: null, #class: "Object", #extensible: true,]
                  '%js-exn' : {#value (err) ,
                               #writable false ,
                               #configurable false}}})
let (%ThrowTypeErrorFun = func(this , args)
                          {let (msg = args["0" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                           throw %JSError(%MakeTypeError(msg))})
let (%ThrowTypeError = {[#proto: %FunctionProto,
                         #code: %ThrowTypeErrorFun,
                         #class: "Function",
                         #extensible: false,]
                        'length' : {#value (0.) ,
                                    #writable false ,
                                    #configurable false}})
let (%TypeError = func(msg)
                  {%ThrowTypeErrorFun(undefined,
                                      {[#proto: null,
                                        #class: "Object",
                                        #extensible: true,]
                                       '0' : {#value (msg) ,
                                              #writable false ,
                                              #configurable false}})})
let (%ErrorDispatch = func(maybe-js-error)
                      {if (%IsJSError(maybe-js-error))
                          {throw maybe-js-error}
                          else
                          if (prim("stx=", maybe-js-error , "unwritable-field"))
                             {%TypeError("Field not writable")}
                             else
                             if (prim("stx=", maybe-js-error , "unconfigurable-delete"))
                                {%TypeError("Field not deletable")}
                                else
                                {throw maybe-js-error}})
let (%ReferenceErrorProto = {[#proto: %ErrorProto,
                              #class: "Object",
                              #extensible: true,]})
let (%SyntaxErrorProto = {[#proto: %ErrorProto,
                           #class: "Object",
                           #extensible: true,]})
let (%SyntaxError = func(msg)
                    {throw %JSError({[#proto: %SyntaxErrorProto,
                                      #class: "Object",
                                      #extensible: true,]
                                     'message' : {#value (msg) ,
                                                  #writable false ,
                                                  #configurable false}})})
let (%BooleanProto = {[#proto: %ObjectProto,
                       #class: "Boolean",
                       #extensible: true,]})
let (%NumberProto = {[#proto: %ObjectProto,
                      #class: "Number",
                      #extensible: true,]})
let (%ToBoolean = func(x)
                  {prim("prim->bool", x)})
let (%ObjectTypeCheck = func(o)
                        {let (t = prim("typeof", o))
                         let (c1 = if (prim("stx=", t , "object"))
                                      {false}
                                      else
                                      {true})
                         let (c2 = if (prim("stx=", t , "function"))
                                      {false}
                                      else
                                      {true})
                         if (if (c1)
                                {c2}
                                else
                                {false})
                            {%TypeError(prim("string+", prim("prim->str", o) , " is not an object"))}
                            else
                            {null}})
let (%IsObject = func(o)
                 {let (t = prim("typeof", o))
                  let (c1 = prim("stx=", t , "object"))
                  let (c2 = prim("stx=", t , "function"))
                  let (%or = c1)
                  if (%or)
                     {%or}
                     else
                     {c2}})
let (%AppExprCheck = func(fun , args)
                     {if (if (prim("stx=", prim("typeof", fun) , "function"))
                             {false}
                             else
                             {true})
                         {%TypeError("Not a function")}
                         else
                         {fun(undefined,
                              args)}})
let (%Typeof = func(context , id)
               {try
                {prim("typeof", context[id , {[#proto: null,
                                               #class: "Object",
                                               #extensible: true,]}])}
                catch
                {func(e)
                 {"undefined"}}})
let (%instanceof = func(l , r)
                   {let (rtype = prim("typeof", r))
                    let (ltype = prim("typeof", l))
                    label ret :
                    {if (if (prim("stx=", rtype , "function"))
                            {false}
                            else
                            {true})
                        {%TypeError("Non-function given to instanceof")}
                        else
                        {null};
                     if (if (if (prim("stx=", ltype , "function"))
                                {false}
                                else
                                {true})
                            {if (prim("stx=", ltype , "object"))
                                {false}
                                else
                                {true}}
                            else
                            {false})
                        {break ret false}
                        else
                        {null};
                     let (O = r["prototype" , {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]}])
                     let (Otype = prim("typeof", O))
                     {if (if (if (prim("stx=", Otype , "function"))
                                 {false}
                                 else
                                 {true})
                             {if (prim("stx=", Otype , "object"))
                                 {false}
                                 else
                                 {true}}
                             else
                             {false})
                         {%TypeError("Prototype was not function or object")}
                         else
                         {null};
                      rec (search = func(v)
                                    {let (vp = v[<#proto>])
                                     if (prim("stx=", vp , null))
                                        {false}
                                        else
                                        if (prim("stx=", O , vp))
                                           {true}
                                           else
                                           {search(vp)}})
                      break ret search(l)}}})
let (%StringProto = {[#proto: %ObjectProto,
                      #class: "String",
                      #extensible: true,]
                     'length' : {#value (0.) ,
                                 #writable false ,
                                 #configurable false}})
let (%StringIndices = func(obj , s)
                      {let (len = prim("strlen", s))
                       rec (loop = func(i)
                                   {if (prim("<", i , len))
                                       {let ($newVal = prim("char-at", s , i))
                                        obj[prim("prim->str", i) = $newVal ,
                                            {[#proto: null,
                                              #class: "Object",
                                              #extensible: true,]
                                             '0' : {#value ($newVal) ,
                                                    #writable true ,
                                                    #configurable true}}];
                                        loop(prim("+", i , 1.))}
                                       else
                                       {undefined}})
                       loop(0.)})
let (%ToObject = func(o)
                 {if (prim("stx=", o , null))
                     {%TypeError("%ToObject received null")}
                     else
                     {label ret :
                      {let (t = prim("typeof", o))
                       {if (let (%or = prim("stx=", t , "object"))
                            if (%or)
                               {%or}
                               else
                               {prim("stx=", t , "function")})
                           {break ret o}
                           else
                           {null};
                        if (prim("stx=", t , "string"))
                           {let (obj = {[#proto: %StringProto,
                                         #class: "String",
                                         #extensible: true,]
                                        'length' : {#value (prim("strlen", o)) ,
                                                    #writable true ,
                                                    #configurable false}})
                            {%StringIndices(obj,
                                            o);
                             break ret obj}}
                           else
                           {null};
                        if (prim("stx=", t , "number"))
                           {break ret {[#proto: %NumberProto,
                                        #class: "Number",
                                        #extensible: true,]}}
                           else
                           {null};
                        if (prim("stx=", t , "boolean"))
                           {break ret {[#proto: %BooleanProto,
                                        #class: "Boolean",
                                        #extensible: true,]}}
                           else
                           {null};
                        if (prim("stx=", t , "function"))
                           {break ret {[#proto: %BooleanProto,
                                        #class: "Function",
                                        #extensible: true,]}}
                           else
                           {null};
                        %TypeError("%ToObject received undefined")}}}})
let (%PropAccessorCheck = func(o)
                          {if (prim("stx=", o , undefined))
                              {throw %JSError({[#proto: %ReferenceErrorProto,
                                                #class: "Object",
                                                #extensible: true,]})}
                              else
                              {%ToObject(o)}})
let (%UnboundId = func(id)
                  {throw %JSError({[#proto: %ReferenceErrorProto,
                                    #class: "Object",
                                    #extensible: true,]
                                   'message' : {#value (prim("string+", "Unbound identifier: " , id)) ,
                                                #writable true ,
                                                #configurable false}})})
let (%ThrowReferenceError = {[#proto: null,
                              #code: func(this , args)
                                     {throw %JSError({[#proto: %ReferenceErrorProto,
                                                       #class: "Object",
                                                       #extensible: true,]})},
                              #class: "Object",
                              #extensible: true,]})
let (%SyntaxError = func(msg)
                    {throw %JSError({[#proto: %SyntaxErrorProto,
                                      #class: "Object",
                                      #extensible: true,]
                                     'message' : {#value (prim("string+", "ReferenceError: " , msg)) ,
                                                  #writable true ,
                                                  #configurable false}})})
let (%ThrowSyntaxError = {[#proto: null,
                           #code: func(this , args)
                                  {throw %JSError({[#proto: %SyntaxErrorProto,
                                                    #class: "Object",
                                                    #extensible: true,]})},
                           #class: "Object",
                           #extensible: false,]})
let (%ToPrimitiveNum = func(obj)
                       {let (check = func(o , str)
                                     {let (valueOf = o[str , {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}])
                                      if (prim("stx=", prim("typeof", valueOf) , "function"))
                                         {let (str = valueOf(o,
                                                             {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}))
                                          if (prim("primitive?", str))
                                             {str}
                                             else
                                             {null}}
                                         else
                                         {null}})
                        let (r1 = check(obj,
                                        "valueOf"))
                        if (if (prim("stx=", r1 , null))
                               {false}
                               else
                               {true})
                           {r1}
                           else
                           {let (r2 = check(obj,
                                            "toString"))
                            if (if (prim("stx=", r2 , null))
                                   {false}
                                   else
                                   {true})
                               {r2}
                               else
                               {%TypeError("valueOf and toString both absent in toPrimitiveNum")}}})
let (%ToPrimitiveStr = func(obj)
                       {label ret :
                        {let (toString = obj["toString" , {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]}])
                         if (prim("stx=", prim("typeof", toString) , "function"))
                            {let (str = toString(obj,
                                                 {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}))
                             if (prim("primitive?", str))
                                {break ret str}
                                else
                                {null}}
                            else
                            {undefined};
                         let (valueOf = obj["valueOf" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])
                         if (prim("stx=", prim("typeof", valueOf) , "function"))
                            {let (str = valueOf(obj,
                                                {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]}))
                             if (prim("primitive?", str))
                                {break ret str}
                                else
                                {null}}
                            else
                            {undefined};
                         %TypeError("valueOf and toString both absent in toPrimitiveStr")}})
let (%ToPrimitiveHint = func(val , hint)
                        {let (t = prim("typeof", val))
                         if (let (%or = prim("stx=", t , "function"))
                             if (%or)
                                {%or}
                                else
                                {prim("stx=", t , "object")})
                            {if (prim("stx=", hint , "string"))
                                {%ToPrimitiveStr(val)}
                                else
                                {%ToPrimitiveNum(val)}}
                            else
                            {val}})
let (%ToPrimitive = func(val)
                    {%ToPrimitiveHint(val,
                                      "number")})
let (%ToString = func(val)
                 {prim("prim->str", %ToPrimitiveHint(val,
                                                     "string"))})
let (%resolveThis = func(strict , obj)
                    {if (strict)
                        {if (if (prim("stx=", prim("typeof", obj) , "object"))
                                {if (prim("stx=", obj , null))
                                    {false}
                                    else
                                    {true}}
                                else
                                {false})
                            {let (klass = obj[<#class>])
                             if (if (let (%or = let (%or = prim("stx=", klass , "Number"))
                                                if (%or)
                                                   {%or}
                                                   else
                                                   {prim("stx=", klass , "String")})
                                     if (%or)
                                        {%or}
                                        else
                                        {prim("stx=", klass , "Boolean")})
                                    {if (if (if (prim("stx=", obj , %StringProto))
                                                {false}
                                                else
                                                {true})
                                            {if (prim("stx=", obj , %NumberProto))
                                                {false}
                                                else
                                                {true}}
                                            else
                                            {false})
                                        {if (prim("stx=", obj , %BooleanProto))
                                            {false}
                                            else
                                            {true}}
                                        else
                                        {false}}
                                    else
                                    {false})
                                {obj[<#primval>]}
                                else
                                {obj}}
                            else
                            {obj}}
                        else
                        if (let (%or = prim("stx=", obj , null))
                            if (%or)
                               {%or}
                               else
                               {prim("stx=", obj , undefined)})
                           {%global}
                           else
                           {obj}})
let (%in = func(l , r)
           {let (rtype = prim("typeof", r))
            if (if (if (prim("stx=", rtype , "object"))
                       {false}
                       else
                       {true})
                   {if (prim("stx=", rtype , "function"))
                       {false}
                       else
                       {true}}
                   else
                   {false})
               {%TypeError(prim("string+", %ToString(r) , " is not an object"))}
               else
               {prim("hasProperty", r , %ToString(l))}})
let (%ToNumber = func(x)
                 {rec (inner = func(x)
                               {label ret :
                                {let (t = prim("typeof", x))
                                 {if (prim("stx=", t , "number"))
                                     {break ret x}
                                     else
                                     {undefined};
                                  if (prim("stx=", x , undefined))
                                     {break ret NaN}
                                     else
                                     {undefined};
                                  if (let (%or = prim("stx=", x , null))
                                      if (%or)
                                         {%or}
                                         else
                                         {prim("stx=", x , false)})
                                     {break ret 0.}
                                     else
                                     {undefined};
                                  if (prim("stx=", x , true))
                                     {break ret 1.}
                                     else
                                     {undefined};
                                  if (prim("stx=", t , "string"))
                                     {break ret prim("numstr->num", x)}
                                     else
                                     {undefined};
                                  break ret inner(%ToPrimitiveNum(x))}}})
                  inner(x)})
let (%ToInteger = func(i)
                  {label ret :
                   {let (number = %ToNumber(i))
                    {if (if (prim("stx=", number , number))
                            {false}
                            else
                            {true})
                        {break ret 0.}
                        else
                        {null};
                     if (let (%or = let (%or = prim("stx=", number , 0.))
                                    if (%or)
                                       {%or}
                                       else
                                       {prim("stx=", number , +inf)})
                         if (%or)
                            {%or}
                            else
                            {prim("stx=", number , -inf)})
                        {break ret number}
                        else
                        {null};
                     let (sign = if (prim("<", number , 0.))
                                    {prim("-", 0. , 1.)}
                                    else
                                    {1.})
                     let (a = prim("abs", number))
                     let (f = prim("floor", a))
                     let (r = prim("*", sign , f))
                     break ret r}}})
let (%NumberConstructor = func(this , args)
                          {if (prim("stx=", this , undefined))
                              {if (prim("stx=", args["length" , {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]}] , 0.))
                                  {0.}
                                  else
                                  {%ToNumber(args["0" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])}}
                              else
                              {let (hasProp = prim("hasProperty", args , "0"))
                               let (argUndef = prim("stx=", args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                               let (v = if (if (hasProp)
                                               {argUndef}
                                               else
                                               {false})
                                           {NaN}
                                           else
                                           if (argUndef)
                                              {0.}
                                              else
                                              {%ToNumber(args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                               {[#proto: %NumberProto,
                                 #class: "Number",
                                 #extensible: true,]}}})
let (%isNaNlambda = func(this , args)
                    {let (n = %ToNumber(args["0" , {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]}]))
                     if (prim("stx=", n , n))
                        {false}
                        else
                        {true}})
let (%EqEq = rec (eqeq = func(x1 , x2)
                         {label ret :
                          {let (t1 = prim("typeof", x1))
                           let (t2 = prim("typeof", x2))
                           if (prim("stx=", t1 , t2))
                              {if (prim("stx=", t1 , "undefined"))
                                  {break ret true}
                                  else
                                  if (prim("stx=", t1 , "null"))
                                     {break ret true}
                                     else
                                     if (prim("stx=", t1 , "number"))
                                        {break ret prim("stx=", x1 , x2)}
                                        else
                                        if (prim("stx=", t1 , "string"))
                                           {break ret prim("stx=", x1 , x2)}
                                           else
                                           if (prim("stx=", t1 , "object"))
                                              {break ret prim("stx=", x1 , x2)}
                                              else
                                              if (prim("stx=", t1 , "boolean"))
                                                 {break ret prim("stx=", x1 , x2)}
                                                 else
                                                 {throw "[env] Catastrophe---unknown type in =="}}
                              else
                              if (let (%or = if (prim("stx=", x1 , undefined))
                                                {prim("stx=", x2 , null)}
                                                else
                                                {false})
                                  if (%or)
                                     {%or}
                                     else
                                     if (prim("stx=", x1 , null))
                                        {prim("stx=", x2 , undefined)}
                                        else
                                        {false})
                                 {break ret true}
                                 else
                                 if (if (prim("stx=", t1 , "number"))
                                        {prim("stx=", t2 , "string")}
                                        else
                                        {false})
                                    {break ret prim("stx=", x1 , prim
                                                                   ("prim->num", x2))}
                                    else
                                    if (if (prim("stx=", t1 , "string"))
                                           {prim("stx=", t2 , "number")}
                                           else
                                           {false})
                                       {break ret prim("stx=", prim("prim->num", x1) , x2)}
                                       else
                                       if (prim("stx=", t1 , "boolean"))
                                          {break ret eqeq(prim("prim->num", x1),
                                                          x2)}
                                          else
                                          if (prim("stx=", t2 , "boolean"))
                                             {break ret eqeq(x1,
                                                             prim("prim->num", x2))}
                                             else
                                             if (if (let (%or = prim("stx=", t1 , "string"))
                                                     if (%or)
                                                        {%or}
                                                        else
                                                        {prim("stx=", t1 , "number")})
                                                    {prim("stx=", t2 , "object")}
                                                    else
                                                    {false})
                                                {break ret eqeq(x1,
                                                                %ToPrimitive
                                                                  (x2))}
                                                else
                                                if (if (let (%or = prim
                                                                    ("stx=", t2 , "string"))
                                                        if (%or)
                                                           {%or}
                                                           else
                                                           {prim("stx=", t2 , "number")})
                                                       {prim("stx=", t1 , "object")}
                                                       else
                                                       {false})
                                                   {break ret eqeq(%ToPrimitive
                                                                    (x1),
                                                                   x2)}
                                                   else
                                                   {break ret false}}})
             eqeq)
let (%printlambda = func(o , s)
                    {prim("print", %ToString(s["0" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]))})
let (%print = {[#proto: %FunctionProto,
                #code: %printlambda,
                #class: "Object",
                #extensible: true,]})
let (%len = func(list)
            {rec (inner_len = func(iter)
                              {if (prim("hasOwnProperty", list , prim
                                                                   ("prim->str", iter)))
                                  {prim("+", 1. , inner_len(prim("+", 1. , iter)))}
                                  else
                                  {iter}})
             inner_len(0.)})
let (%slice_internal = func(list , min , max)
                       {let (retObj = {[#proto: null,
                                        #class: "Object",
                                        #extensible: true,]})
                        {rec (inner_slice = func(iter , ix)
                                            {if (prim("hasOwnProperty", list , prim
                                                                    ("prim->str", iter)))
                                                {let ($newVal = list[prim
                                                                    ("prim->str", iter) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                 retObj[prim("prim->str", ix) = $newVal ,
                                                        {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]
                                                         '0' : {#value ($newVal) ,
                                                                #writable true ,
                                                                #configurable true}}];
                                                 if (prim(">", iter , max))
                                                    {undefined}
                                                    else
                                                    {inner_slice(prim
                                                                   ("+", iter , 1.),
                                                                 prim
                                                                   ("+", ix , 1.))}}
                                                else
                                                {let ($newVal = ix)
                                                 retObj["length" = $newVal ,
                                                        {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]
                                                         '0' : {#value ($newVal) ,
                                                                #writable true ,
                                                                #configurable true}}]}})
                         inner_slice(min,
                                     0.);
                         retObj}})
let (isDataField = func(obj , field)
                   {let (%or = if (prim("stx=", obj[field <#value>] , undefined))
                                  {false}
                                  else
                                  {true})
                    if (%or)
                       {%or}
                       else
                       if (prim("stx=", obj[field <#writable>] , undefined))
                          {false}
                          else
                          {true}})
let (isAccessorField = func(obj , field)
                       {let (%or = if (prim("stx=", obj[field <#setter>] , undefined))
                                      {false}
                                      else
                                      {true})
                        if (%or)
                           {%or}
                           else
                           if (prim("stx=", obj[field <#getter>] , undefined))
                              {false}
                              else
                              {true}})
let (isGenericField = func(obj , field)
                      {if (prim("stx=", isDataField(obj,
                                                    field) , false))
                          {prim("stx=", isAccessorField(obj,
                                                        field) , false)}
                          else
                          {false}})
let (isDataDescriptor = func(attr-obj)
                        {let (%or = if (prim("stx=", prim("typeof", attr-obj
                                                                    ["value" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , "undefined"))
                                       {false}
                                       else
                                       {true})
                         if (%or)
                            {%or}
                            else
                            if (prim("stx=", prim("typeof", attr-obj["writable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , "undefined"))
                               {false}
                               else
                               {true}})
let (isAccessorDescriptor = func(attr-obj)
                            {let (%or = if (prim("stx=", prim("typeof", attr-obj
                                                                    ["set" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , "undefined"))
                                           {false}
                                           else
                                           {true})
                             if (%or)
                                {%or}
                                else
                                if (prim("stx=", prim("typeof", attr-obj
                                                                  ["get" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , "undefined"))
                                   {false}
                                   else
                                   {true}})
let (isGenericDescriptor = func(attr-obj)
                           {if (prim("stx=", isAccessorDescriptor(attr-obj) , false))
                               {prim("stx=", isDataDescriptor(attr-obj) , false)}
                               else
                               {false}})
let (copy-when-defined = func(obj1 , obj2 , s)
                         {if (if (prim("stx=", obj2[s , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}] , undefined))
                                 {false}
                                 else
                                 {true})
                             {let ($newVal = obj2[s , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}])
                              obj1[s = $newVal ,
                                   {[#proto: null,
                                     #class: "Object",
                                     #extensible: true,]
                                    '0' : {#value ($newVal) ,
                                           #writable true ,
                                           #configurable true}}]}
                             else
                             {undefined}})
let (copy-data-desc = func(obj1 , obj2)
                      {copy-when-defined(obj1,
                                         obj2,
                                         "configurable");
                       copy-when-defined(obj1,
                                         obj2,
                                         "enumerable");
                       copy-when-defined(obj1,
                                         obj2,
                                         "writable");
                       copy-when-defined(obj1,
                                         obj2,
                                         "value");
                       obj1[delete "get"];
                       obj1[delete "set"]})
let (copy-access-desc = func(obj1 , obj2)
                        {copy-when-defined(obj1,
                                           obj2,
                                           "configurable");
                         copy-when-defined(obj1,
                                           obj2,
                                           "enumerable");
                         copy-when-defined(obj1,
                                           obj2,
                                           "set");
                         copy-when-defined(obj1,
                                           obj2,
                                           "get");
                         obj1[delete "value"];
                         obj1[delete "writable"]})
let (%defineOwnProperty = func(obj , field , attr-obj)
                          {let (t = prim("typeof", obj))
                           if (if (if (prim("stx=", t , "object"))
                                      {false}
                                      else
                                      {true})
                                  {if (prim("stx=", t , "function"))
                                      {false}
                                      else
                                      {true}}
                                  else
                                  {false})
                              {throw "defineOwnProperty didn't get object"}
                              else
                              {undefined};
                           let (fstr = %ToString(field))
                           if (prim("stx=", prim("hasOwnProperty", obj , fstr) , false))
                              {if (obj[<#extensible>])
                                  {obj[fstr<#configurable>=true];
                                   obj[fstr<#writable>=true];
                                   if (isDataDescriptor(attr-obj))
                                      {obj[fstr<#value>=attr-obj["value" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]];
                                       obj[fstr<#writable>=%ToBoolean
                                            (attr-obj["writable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])]}
                                      else
                                      if (isAccessorDescriptor(attr-obj))
                                         {obj[fstr<#getter>=attr-obj["get" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]];
                                          obj[fstr<#setter>=attr-obj["set" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]]}
                                         else
                                         {undefined};
                                   obj[fstr<#enumerable>=%ToBoolean(attr-obj
                                                                    ["enumerable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])];
                                   obj[fstr<#configurable>=%ToBoolean
                                        (attr-obj["configurable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])];
                                   true}
                                  else
                                  {%TypeError("(defineOwnProperty) Attempt to add a property to a non-extensible object.")}}
                              else
                              {let (current-prop = {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]
                                                    'configurable' : {#value (obj
                                                                    [fstr <#configurable>]) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                    'enumerable' : {#value (obj
                                                                    [fstr <#enumerable>]) ,
                                                                    #writable true ,
                                                                    #configurable false}})
                               {if (prim("isAccessor", obj , fstr))
                                   {let ($newVal = obj[fstr <#getter>])
                                    current-prop["get" = $newVal ,
                                                 {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]
                                                  '0' : {#value ($newVal) ,
                                                         #writable true ,
                                                         #configurable true}}];
                                    let ($newVal = obj[fstr <#setter>])
                                    current-prop["set" = $newVal ,
                                                 {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]
                                                  '0' : {#value ($newVal) ,
                                                         #writable true ,
                                                         #configurable true}}]}
                                   else
                                   {let ($newVal = obj[fstr <#writable>])
                                    current-prop["writable" = $newVal ,
                                                 {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]
                                                  '0' : {#value ($newVal) ,
                                                         #writable true ,
                                                         #configurable true}}];
                                    let ($newVal = obj[fstr <#value>])
                                    current-prop["value" = $newVal ,
                                                 {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]
                                                  '0' : {#value ($newVal) ,
                                                         #writable true ,
                                                         #configurable true}}]};
                                if (prim("stx=", obj[fstr <#configurable>] , false))
                                   {if (prim("stx=", attr-obj["configurable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , true))
                                       {%TypeError("escalating configurable from false to true")}
                                       else
                                       if (prim("stx=", attr-obj["enumerable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , prim
                                                                    ("stx=", obj
                                                                    [fstr <#enumerable>] , false)))
                                          {%TypeError("(defineOwnPoperty) Can't change enumerable of a non-configurable property")}
                                          else
                                          {undefined};
                                    if (if (prim("stx=", isDataDescriptor
                                                           (current-prop) , isDataDescriptor
                                                                    (attr-obj)))
                                           {false}
                                           else
                                           {true})
                                       {if (prim("stx=", obj[fstr <#configurable>] , false))
                                           {%TypeError("(defineOwnProperty) Non-configurable property")}
                                           else
                                           if (isDataDescriptor(current-prop))
                                              {copy-data-desc(current-prop,
                                                              attr-obj)}
                                              else
                                              {copy-access-desc(current-prop,
                                                                attr-obj)}}
                                       else
                                       {undefined}}
                                   else
                                   {undefined};
                                if (if (isDataDescriptor(current-prop))
                                       {isDataDescriptor(attr-obj)}
                                       else
                                       {false})
                                   {if (prim("stx=", current-prop["configurable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , false))
                                       {if (prim("stx=", current-prop
                                                           ["writable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , false))
                                           {if (prim("stx=", attr-obj
                                                               ["writable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , true))
                                               {%TypeError("(defineOwnProperty) Cannot escalate writable from false to true.")}
                                               else
                                               if (prim("stx=", prim("sameValue", attr-obj
                                                                    ["value" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , current-prop
                                                                    ["value" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , false))
                                                  {%TypeError("(defineOwnProperty) Cannot change a non-configurable value")}
                                                  else
                                                  {copy-data-desc(current-prop,
                                                                  attr-obj)}}
                                           else
                                           {copy-data-desc(current-prop,
                                                           attr-obj)}}
                                       else
                                       {copy-data-desc(current-prop,
                                                       attr-obj)}}
                                   else
                                   if (prim("stx=", current-prop["configurable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , false))
                                      {if (let (%or = prim("stx=", prim
                                                                    ("sameValue", current-prop
                                                                    ["set" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , attr-obj
                                                                    ["set" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , false))
                                           if (%or)
                                              {%or}
                                              else
                                              {prim("stx=", prim("sameValue", current-prop
                                                                    ["get" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , attr-obj
                                                                    ["get" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , false)})
                                          {%TypeError(prim("string+", "(defineOwnProperty) Cannot change setter or getter of non-configurable property " , fstr))}
                                          else
                                          {copy-access-desc(current-prop,
                                                            attr-obj)}}
                                      else
                                      {copy-access-desc(current-prop,
                                                        attr-obj)};
                                if (isDataDescriptor(current-prop))
                                   {if (prim("stx=", prim("sameValue", obj
                                                                    [fstr <#value>] , current-prop
                                                                    ["value" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , false))
                                       {obj[fstr<#value>=current-prop
                                             ["value" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}]]}
                                       else
                                       {undefined};
                                    if (if (prim("stx=", obj[fstr <#writable>] , current-prop
                                                                    ["writable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                           {false}
                                           else
                                           {true})
                                       {obj[fstr<#writable>=current-prop
                                             ["writable" , {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]}]]}
                                       else
                                       {undefined}}
                                   else
                                   if (isAccessorDescriptor(current-prop))
                                      {obj[fstr<#getter>=current-prop
                                            ["get" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]];
                                       obj[fstr<#setter>=current-prop
                                            ["set" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]]}
                                      else
                                      {undefined};
                                if (if (prim("stx=", obj[fstr <#enumerable>] , current-prop
                                                                    ["enumerable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                       {false}
                                       else
                                       {true})
                                   {obj[fstr<#enumerable>=current-prop
                                         ["enumerable" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}]]}
                                   else
                                   {undefined};
                                if (if (prim("stx=", obj[fstr <#configurable>] , current-prop
                                                                    ["configurable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                       {false}
                                       else
                                       {true})
                                   {obj[fstr<#configurable>=current-prop
                                         ["configurable" , {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]}]]}
                                   else
                                   {undefined};
                                true}}})
let (%define15Property = func(obj , field , prop)
                         {let (mkPropObj = func(value , writable , enumerable , configurable)
                                           {if (if (prim("stx=", value , null))
                                                   {false}
                                                   else
                                                   {true})
                                               {{[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]
                                                 'value' : {#value (value) ,
                                                            #writable true ,
                                                            #configurable false},
                                                 'writable' : {#value (writable) ,
                                                               #writable true ,
                                                               #configurable false},
                                                 'enumerable' : {#value (enumerable) ,
                                                                 #writable true ,
                                                                 #configurable false},
                                                 'configurable' : {#value (configurable) ,
                                                                   #writable true ,
                                                                   #configurable false}}}
                                               else
                                               {{[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]
                                                 'writable' : {#value (writable) ,
                                                               #writable true ,
                                                               #configurable false},
                                                 'enumerable' : {#value (enumerable) ,
                                                                 #writable true ,
                                                                 #configurable false},
                                                 'configurable' : {#value (configurable) ,
                                                                   #writable true ,
                                                                   #configurable false}}}})
                          if (if (prim("stx=", prim("typeof", obj) , "function"))
                                 {prim("stx=", field , "length")}
                                 else
                                 {false})
                             {%defineOwnProperty(obj,
                                                 field,
                                                 mkPropObj(prop,
                                                           false,
                                                           false,
                                                           false))}
                             else
                             {%defineOwnProperty(obj,
                                                 field,
                                                 mkPropObj(prop,
                                                           true,
                                                           false,
                                                           true))}})
let (%definePropertylambda = func(this , args)
                             {let (obj = args["0" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}])
                              let (field = args["1" , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}])
                              let (propobj = args["2" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])
                              if (%ObjectTypeCheck(obj))
                                 {%TypeError("defineProperty didn't get object")}
                                 else
                                 {let (attrobj = {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]})
                                  {let (enumerable = propobj["enumerable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                   if (if (prim("stx=", prim("typeof", enumerable) , "undefined"))
                                          {false}
                                          else
                                          {true})
                                      {let ($newVal = enumerable)
                                       attrobj["enumerable" = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}]}
                                      else
                                      {attrobj};
                                   let (configurable = propobj["configurable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                   if (if (prim("stx=", prim("typeof", configurable) , "undefined"))
                                          {false}
                                          else
                                          {true})
                                      {let ($newVal = configurable)
                                       attrobj["configurable" = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}]}
                                      else
                                      {attrobj};
                                   let (writable = propobj["writable" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                   if (if (prim("stx=", prim("typeof", writable) , "undefined"))
                                          {false}
                                          else
                                          {true})
                                      {let ($newVal = writable)
                                       attrobj["writable" = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}]}
                                      else
                                      {attrobj};
                                   let (value = propobj["value" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                   if (if (prim("stx=", prim("typeof", value) , "undefined"))
                                          {false}
                                          else
                                          {true})
                                      {let ($newVal = value)
                                       attrobj["value" = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}]}
                                      else
                                      {attrobj};
                                   let (get = propobj["get" , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}])
                                   if (if (if (prim("stx=", prim("typeof", get) , "undefined"))
                                              {false}
                                              else
                                              {true})
                                          {if (prim("stx=", prim("typeof", get) , "function"))
                                              {false}
                                              else
                                              {true}}
                                          else
                                          {false})
                                      {%TypeError("defineProperty given a non-function getter")}
                                      else
                                      {let ($newVal = get)
                                       attrobj["get" = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}]};
                                   let (set = propobj["set" , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}])
                                   if (if (if (prim("stx=", prim("typeof", set) , "undefined"))
                                              {false}
                                              else
                                              {true})
                                          {if (prim("stx=", prim("typeof", set) , "function"))
                                              {false}
                                              else
                                              {true}}
                                          else
                                          {false})
                                      {%TypeError("defineProperty given a non-function setter")}
                                      else
                                      {let ($newVal = set)
                                       attrobj["set" = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}]};
                                   if (if (isDataDescriptor(attrobj))
                                          {isAccessorDescriptor(attrobj)}
                                          else
                                          {false})
                                      {%TypeError("The attributes given to defineProperty were inconsistent")}
                                      else
                                      {%defineOwnProperty(obj,
                                                          field,
                                                          attrobj)}}}})
let (%defineProperty = {[#proto: null,
                         #code: %definePropertylambda,
                         #class: "Object",
                         #extensible: true,]})
let (%ObjectConstructor = func(this , args)
                          {let (calledAsFunction = prim("stx=", this , undefined))
                           let (hasArg = prim(">", args["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , 0.))
                           let (notNull = prim("!", prim("stx=", args
                                                                   ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , null)))
                           let (notUndefined = prim("!", prim("stx=", args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined)))
                           let (shouldReturnEarly = if (if (if (calledAsFunction)
                                                               {hasArg}
                                                               else
                                                               {false})
                                                           {notNull}
                                                           else
                                                           {false})
                                                       {notUndefined}
                                                       else
                                                       {false})
                           let (defaultRtn = {[#proto: %ObjectProto,
                                               #class: "Object",
                                               #extensible: true,]})
                           if (shouldReturnEarly)
                              {%ToObject(args["0" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}])}
                              else
                              if (hasArg)
                                 {let (argtype = prim("typeof", args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                  let (isArgObject = let (%or = prim("stx=", argtype , "object"))
                                                     if (%or)
                                                        {%or}
                                                        else
                                                        {prim("stx=", argtype , "function")})
                                  let (isArgSomething = let (%or = let (%or = prim
                                                                    ("stx=", argtype , "boolean"))
                                                                   if (%or)
                                                                    {%or}
                                                                    else
                                                                    {prim
                                                                    ("stx=", argtype , "string")})
                                                        if (%or)
                                                           {%or}
                                                           else
                                                           {prim("stx=", argtype , "number")})
                                  if (isArgObject)
                                     {args["0" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}]}
                                     else
                                     if (isArgSomething)
                                        {%ToObject(args["0" , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}])}
                                        else
                                        {defaultRtn}}
                                 else
                                 {defaultRtn}})
let (%mkArgsObjBase = func(args)
                      {let (keys = get-own-field-names(args))
                       let (argsObj = {[#proto: %ObjectProto,
                                        #class: "Arguments",
                                        #extensible: true,]
                                       'callee' : {#getter %ThrowTypeError ,
                                                   #setter %ThrowTypeError},
                                       'caller' : {#getter %ThrowTypeError ,
                                                   #setter %ThrowTypeError}})
                       {argsObj["callee"<#configurable>=false];
                        argsObj["caller"<#configurable>=false];
                        rec (loop = func(iter)
                                    {let (strx = %ToString(iter))
                                     if (prim("hasOwnProperty", keys , strx))
                                        {%defineOwnProperty(argsObj,
                                                            strx,
                                                            {[#proto: null,
                                                              #class: "Object",
                                                              #extensible: true,]
                                                             'value' : {#value (args
                                                                    [strx , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) ,
                                                                    #writable false ,
                                                                    #configurable false},
                                                             'writable' : {#value (true) ,
                                                                    #writable false ,
                                                                    #configurable false},
                                                             'configurable' : {#value (true) ,
                                                                    #writable false ,
                                                                    #configurable false},
                                                             'enumerable' : {#value (true) ,
                                                                    #writable false ,
                                                                    #configurable false}});
                                         loop(prim("+", iter , 1.))}
                                        else
                                        {%defineOwnProperty(argsObj,
                                                            "length",
                                                            {[#proto: null,
                                                              #class: "Object",
                                                              #extensible: true,]
                                                             'value' : {#value (iter) ,
                                                                    #writable false ,
                                                                    #configurable false},
                                                             'writable' : {#value (true) ,
                                                                    #writable false ,
                                                                    #configurable false},
                                                             'configurable' : {#value (true) ,
                                                                    #writable false ,
                                                                    #configurable false},
                                                             'enumerable' : {#value (false) ,
                                                                    #writable false ,
                                                                    #configurable false}})}})
                        {loop(0.);
                         argsObj}}})
let (%mkArgsObj = func(args)
                  {let (argsObj = %mkArgsObjBase(args))
                   {let ($newVal = false)
                    argsObj["%new" = $newVal ,
                            {[#proto: null,
                              #class: "Object",
                              #extensible: true,]
                             '0' : {#value ($newVal) ,
                                    #writable true ,
                                    #configurable true}}];
                    argsObj["%new"<#writable>=false];
                    argsObj}})
let (%mkNewArgsObj = func(args)
                     {let (argsObj = %mkArgsObjBase(args))
                      {let ($newVal = true)
                       argsObj["%new" = $newVal ,
                               {[#proto: null,
                                 #class: "Object",
                                 #extensible: true,]
                                '0' : {#value ($newVal) ,
                                       #writable true ,
                                       #configurable true}}];
                       argsObj["%new"<#writable>=false];
                       argsObj}})
let (%oneArgObj = func(arg)
                  {%mkArgsObj({[#proto: null,
                                #class: "Object",
                                #extensible: true,]
                               '0' : {#value (arg) ,
                                      #writable false ,
                                      #configurable false},
                               'length' : {#value (1.) ,
                                           #writable false ,
                                           #configurable false}})})
let (%twoArgObj = func(arg1 , arg2)
                  {%mkArgsObj({[#proto: null,
                                #class: "Object",
                                #extensible: true,]
                               '0' : {#value (arg1) ,
                                      #writable false ,
                                      #configurable false},
                               '1' : {#value (arg2) ,
                                      #writable false ,
                                      #configurable false},
                               'length' : {#value (2.) ,
                                           #writable false ,
                                           #configurable false}})})
let (%calllambda = func(this , args)
                   {let (callArgs = %slice_internal(args,
                                                    1.,
                                                    %len(args)))
                    this(args["0" , {[#proto: null,
                                      #class: "Object",
                                      #extensible: true,]}],
                         callArgs)})
let (%applylambda = func(this , args)
                    {let (applyArgs = args["1" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                     {if (let (%or = prim("stx=", prim("typeof", applyArgs) , "undefined"))
                          if (%or)
                             {%or}
                             else
                             {prim("stx=", applyArgs , null)})
                         {applyArgs := {[#proto: null,
                                         #class: "Object",
                                         #extensible: true,]}}
                         else
                         {undefined};
                      %ObjectTypeCheck(applyArgs);
                      applyArgs := %mkArgsObj(applyArgs);
                      this(args["0" , {[#proto: null,
                                        #class: "Object",
                                        #extensible: true,]}],
                           applyArgs)}})
let (%call = {[#proto: %FunctionProto,
               #code: %calllambda,
               #class: "Object",
               #extensible: true,]})
let (%apply = {[#proto: %FunctionProto,
                #code: %applylambda,
                #class: "Object",
                #extensible: true,]})
let (%makeGetter = func(object , id)
                   {{[#proto: %FunctionProto,
                      #code: func(this , args)
                             {if (prim("hasProperty", object , id))
                                 {object[id , {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]}]}
                                 else
                                 {%UnboundId(id)}},
                      #class: "Object",
                      #extensible: false,]}})
let (%UnwritableDispatch = func(id)
                           {func(e)
                            {if (prim("stx=", e , "unwritable-field"))
                                {%TypeError(prim("string+", id , " not writable"))}
                                else
                                {%ErrorDispatch(e)}}})
let (%makeSetter = func(object , id)
                   {{[#proto: %FunctionProto,
                      #code: func(this , args)
                             {try
                              {let ($newVal = args["0" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}])
                               object[id = $newVal ,
                                      {[#proto: null,
                                        #class: "Object",
                                        #extensible: true,]
                                       '0' : {#value ($newVal) ,
                                              #writable true ,
                                              #configurable true}}]}
                              catch
                              {%UnwritableDispatch(id)}},
                      #class: "Object",
                      #extensible: false,]}})
let (%primEach = func(arr , fn)
                 {rec (loop = func(i)
                              {let (istr = %ToString(i))
                               if (prim("hasOwnProperty", arr , istr))
                                  {fn(arr[istr , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}]);
                                   loop(prim("+", i , 1.))}
                                  else
                                  {undefined}})
                  loop(0.)})
let (%defineGlobalVar = func(context , id)
                        {if (prim("!", prim("hasProperty", context , id)))
                            {%defineOwnProperty(%global,
                                                id,
                                                {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]
                                                 'value' : {#value (undefined) ,
                                                            #writable true ,
                                                            #configurable false},
                                                 'writable' : {#value (true) ,
                                                               #writable true ,
                                                               #configurable false},
                                                 'enumerable' : {#value (true) ,
                                                                 #writable true ,
                                                                 #configurable false},
                                                 'configurable' : {#value (false) ,
                                                                   #writable true ,
                                                                   #configurable false}});
                             %defineOwnProperty(context,
                                                id,
                                                {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]
                                                 'get' : {#value (%makeGetter
                                                                   (%global,
                                                                    id)) ,
                                                          #writable true ,
                                                          #configurable false},
                                                 'set' : {#value (%makeSetter
                                                                   (%global,
                                                                    id)) ,
                                                          #writable true ,
                                                          #configurable false},
                                                 'enumerable' : {#value (true) ,
                                                                 #writable false ,
                                                                 #configurable false},
                                                 'configurable' : {#value (true) ,
                                                                   #writable false ,
                                                                   #configurable false}})}
                            else
                            {undefined}})
let (%defineGlobalAccessors = func(context , id)
                              {%defineOwnProperty(%globalContext,
                                                  id,
                                                  {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]
                                                   'get' : {#value (%makeGetter
                                                                    (%global,
                                                                    id)) ,
                                                            #writable true ,
                                                            #configurable false},
                                                   'set' : {#value (%makeSetter
                                                                    (%global,
                                                                    id)) ,
                                                            #writable true ,
                                                            #configurable false},
                                                   'enumerable' : {#value (true) ,
                                                                   #writable false ,
                                                                   #configurable false},
                                                   'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}})})
let (%isNaN = {[#proto: %FunctionProto,
                #code: %isNaNlambda,
                #class: "Object",
                #extensible: true,]})
let (%ErrorConstructor = func(this , args)
                         {let (o = {[#proto: %ErrorProto,
                                     #class: "Error",
                                     #extensible: true,]})
                          if (prim(">=", args["length" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}] , 1.))
                             {let ($newVal = %ToString(args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                              o["message" = $newVal ,
                                {[#proto: null,
                                  #class: "Object",
                                  #extensible: true,]
                                 '0' : {#value ($newVal) ,
                                        #writable true ,
                                        #configurable true}}];
                              o}
                             else
                             {o}})
let (%ErrorGlobalFuncObj = {[#proto: %FunctionProto,
                             #code: %ErrorConstructor,
                             #class: "Object",
                             #extensible: true,]
                            'prototype' : {#value (%ErrorProto) ,
                                           #writable false ,
                                           #configurable false}})
let (%etslambda = func(this , args)
                  {if (if (prim("stx=", prim("typeof", this) , "object"))
                          {false}
                          else
                          {true})
                      {%TypeError("This not object in Error.prototype.toString")}
                      else
                      {let (name = if (prim("stx=", this["name" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                      {"Error"}
                                      else
                                      {%ToString(this["name" , {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]}])})
                       let (msg = if (prim("stx=", this["message" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                     {""}
                                     else
                                     {%ToString(this["message" , {[#proto: null,
                                                                   #class: "Object",
                                                                   #extensible: true,]}])})
                       let (c1 = prim("stx=", name , ""))
                       let (c2 = prim("stx=", msg , ""))
                       label ret :
                       {if (if (c1)
                               {c2}
                               else
                               {false})
                           {break ret "Error"}
                           else
                           {null};
                        if (c1)
                           {break ret msg}
                           else
                           {null};
                        if (c2)
                           {break ret name}
                           else
                           {null};
                        let (prefix = prim("string+", name , ": "))
                        break ret prim("string+", prefix , msg)}}})
let (%ets = {[#proto: %FunctionProto,
              #code: %etslambda,
              #class: "Object",
              #extensible: true,]})
let (%NumberGlobalFuncObj = {[#proto: %FunctionProto,
                              #code: %NumberConstructor,
                              #class: "Object",
                              #extensible: true,]
                             'prototype' : {#value (%NumberProto) ,
                                            #writable false ,
                                            #configurable false},
                             'MAX_VALUE' : {#value (1.79769313486e+308) ,
                                            #writable false ,
                                            #configurable false},
                             'MIN_VALUE' : {#value (4.94065645841e-324) ,
                                            #writable false ,
                                            #configurable false},
                             'NaN' : {#value (NaN) ,
                                      #writable false ,
                                      #configurable false},
                             'NEGATIVE_INFINITY' : {#value (-inf) ,
                                                    #writable false ,
                                                    #configurable false},
                             'POSITIVE_INFINITY' : {#value (+inf) ,
                                                    #writable false ,
                                                    #configurable false},
                             'length' : {#value (1.) ,
                                         #writable false ,
                                         #configurable false}})
let (%stringToStringlambda = func(this , args)
                             {this[<#primval>]})
let (%stringToString = {[#proto: %FunctionProto,
                         #code: %stringToStringlambda,
                         #class: "Object",
                         #extensible: true,]
                        'length' : {#value (0.) ,
                                    #writable false ,
                                    #configurable false}})
let (%StringConstructor = func(this , args)
                          {let (S = if (prim("stx=", args["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , 0.))
                                       {""}
                                       else
                                       {%ToString(args["0" , {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}])})
                           if (prim("stx=", this , undefined))
                              {S}
                              else
                              {let (obj = {[#proto: %StringProto,
                                            #class: "String",
                                            #extensible: true,]
                                           'length' : {#value (prim("strlen", S)) ,
                                                       #writable true ,
                                                       #configurable false}})
                               {%StringIndices(obj,
                                               S);
                                obj}}})
let (%StringGlobalFuncObj = {[#proto: %FunctionProto,
                              #code: %StringConstructor,
                              #class: "Object",
                              #extensible: true,]
                             'length' : {#value (1.) ,
                                         #writable false ,
                                         #configurable false}})
let (%BooleanConstructor = func(this , args)
                           {let (b = %ToBoolean(args["0" , {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]}]))
                            if (prim("stx=", this , undefined))
                               {b}
                               else
                               {{[#proto: %BooleanProto,
                                  #class: "Boolean",
                                  #extensible: true,]}}})
let (%booleanToStringlambda = func(this , args)
                              {let (t = prim("typeof", this))
                               let (b = if (prim("stx=", t , "boolean"))
                                           {this}
                                           else
                                           if (prim("stx=", t , "object"))
                                              {if (prim("stx=", this[<#class>] , "Boolean"))
                                                  {this[<#primval>]}
                                                  else
                                                  {%TypeError("Boolean.prototype.toString got non-boolean object")}}
                                              else
                                              {%TypeError(prim("string+", "Boolean.prototype.toString got " , t))})
                               if (b)
                                  {"true"}
                                  else
                                  {"false"}})
let (%booleanToString = {[#proto: %FunctionProto,
                          #code: %booleanToStringlambda,
                          #class: "Function",
                          #extensible: true,]})
let (%BooleanGlobalFuncObj = {[#proto: %FunctionProto,
                               #code: %BooleanConstructor,
                               #class: "Object",
                               #extensible: true,]})
let (%ObjectGlobalFuncObj = {[#proto: %FunctionProto,
                              #code: %ObjectConstructor,
                              #class: "Object",
                              #extensible: true,]
                             'prototype' : {#value (%ObjectProto) ,
                                            #writable false ,
                                            #configurable false},
                             'length' : {#value (1.) ,
                                         #writable false ,
                                         #configurable false}})
let (%gpoLambda = func(this , args)
                  {let (O = args["0" , {[#proto: null,
                                         #class: "Object",
                                         #extensible: true,]}])
                   {%ObjectTypeCheck(O);
                    O[<#proto>]}})
let (%gpo = {[#proto: %FunctionProto,
              #code: %gpoLambda,
              #class: "Object",
              #extensible: true,]})
let (%gopdLambda = func(this , args)
                   {let (O = args["0" , {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]}])
                    {%ObjectTypeCheck(O);
                     let (name = %ToString(args["1" , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}]))
                     label ret :
                     {if (prim("!", prim("hasOwnProperty", O , name)))
                         {break ret undefined}
                         else
                         {null};
                      let (obj = {[#proto: %ObjectProto,
                                   #class: "Object",
                                   #extensible: true,]})
                      {%defineOwnProperty(obj,
                                          "enumerable",
                                          {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]
                                           'value' : {#value (O[name <#enumerable>]) ,
                                                      #writable true ,
                                                      #configurable false},
                                           'writable' : {#value (true) ,
                                                         #writable true ,
                                                         #configurable false},
                                           'enumerable' : {#value (true) ,
                                                           #writable true ,
                                                           #configurable false},
                                           'configurable' : {#value (true) ,
                                                             #writable true ,
                                                             #configurable false}});
                       %defineOwnProperty(obj,
                                          "configurable",
                                          {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]
                                           'value' : {#value (O[name <#configurable>]) ,
                                                      #writable true ,
                                                      #configurable false},
                                           'writable' : {#value (true) ,
                                                         #writable true ,
                                                         #configurable false},
                                           'enumerable' : {#value (true) ,
                                                           #writable true ,
                                                           #configurable false},
                                           'configurable' : {#value (true) ,
                                                             #writable true ,
                                                             #configurable false}});
                       if (prim("!", prim("isAccessor", O , name)))
                          {%defineOwnProperty(obj,
                                              "value",
                                              {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]
                                               'value' : {#value (O[name , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) ,
                                                          #writable true ,
                                                          #configurable false},
                                               'writable' : {#value (true) ,
                                                             #writable true ,
                                                             #configurable false},
                                               'enumerable' : {#value (true) ,
                                                               #writable true ,
                                                               #configurable false},
                                               'configurable' : {#value (true) ,
                                                                 #writable true ,
                                                                 #configurable false}});
                           %defineOwnProperty(obj,
                                              "writable",
                                              {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]
                                               'value' : {#value (O[name <#writable>]) ,
                                                          #writable true ,
                                                          #configurable false},
                                               'writable' : {#value (true) ,
                                                             #writable true ,
                                                             #configurable false},
                                               'enumerable' : {#value (true) ,
                                                               #writable true ,
                                                               #configurable false},
                                               'configurable' : {#value (true) ,
                                                                 #writable true ,
                                                                 #configurable false}});
                           break ret obj}
                          else
                          {%defineOwnProperty(obj,
                                              "get",
                                              {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]
                                               'value' : {#value (O[name <#getter>]) ,
                                                          #writable true ,
                                                          #configurable false},
                                               'writable' : {#value (true) ,
                                                             #writable true ,
                                                             #configurable false},
                                               'enumerable' : {#value (true) ,
                                                               #writable true ,
                                                               #configurable false},
                                               'configurable' : {#value (true) ,
                                                                 #writable true ,
                                                                 #configurable false}});
                           %defineOwnProperty(obj,
                                              "set",
                                              {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]
                                               'value' : {#value (O[name <#setter>]) ,
                                                          #writable true ,
                                                          #configurable false},
                                               'writable' : {#value (true) ,
                                                             #writable true ,
                                                             #configurable false},
                                               'enumerable' : {#value (true) ,
                                                               #writable true ,
                                                               #configurable false},
                                               'configurable' : {#value (true) ,
                                                                 #writable true ,
                                                                 #configurable false}});
                           break ret obj}}}}})
let (%gopd = {[#proto: %FunctionProto,
               #code: %gopdLambda,
               #class: "Object",
               #extensible: true,]})
let (%objectToStringlambda = func(this , args)
                             {label ret :
                              {if (prim("stx=", this , undefined))
                                  {break ret "[object Undefined]"}
                                  else
                                  {undefined};
                               if (prim("stx=", this , null))
                                  {break ret "[object Null]"}
                                  else
                                  {undefined};
                               let (O = %ToObject(this))
                               let (class = O[<#class>])
                               break ret prim("string+", "[object " , prim
                                                                    ("string+", class , "]"))}})
let (%objectToString = {[#proto: %FunctionProto,
                         #code: %objectToStringlambda,
                         #class: "Object",
                         #extensible: true,]
                        'length' : {#value (0.) ,
                                    #writable false ,
                                    #configurable false}})
let (%propEnumlambda = func(this , args)
                       {let (getOwnProperty = func(o , f)
                                              {if (prim("hasOwnProperty", o , f))
                                                  {o[f , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}]}
                                                  else
                                                  {undefined}})
                        if (prim("stx=", args["0" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}] , undefined))
                           {false}
                           else
                           {let (P = %ToString(args["0" , {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]}]))
                            let (O = %ToObject(this))
                            let (desc = getOwnProperty(O,
                                                       P))
                            if (prim("stx=", desc , undefined))
                               {false}
                               else
                               {O[P <#enumerable>]}}})
let (%propertyIsEnumerable = {[#proto: %FunctionProto,
                               #code: %propEnumlambda,
                               #class: "Object",
                               #extensible: true,]
                              'length' : {#value (1.) ,
                                          #writable false ,
                                          #configurable false}})
let (%toLocaleStringLambda = func(this , args)
                             {let (O = %ToObject(this))
                              let (toString = O["toString" , {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}])
                              if (prim("stx=", toString[<#code>] , null))
                                 {%TypeError("toLocaleString")}
                                 else
                                 {toString(O,
                                           {[#proto: null,
                                             #class: "Object",
                                             #extensible: true,]})}})
let (%toLocaleString = {[#proto: %FunctionProto,
                         #code: %toLocaleStringLambda,
                         #class: "Object",
                         #extensible: true,]
                        'length' : {#value (0.) ,
                                    #writable false ,
                                    #configurable false}})
let (%valueOflambda = func(this , args)
                      {%ToObject(this)})
let (%valueOf = {[#proto: %FunctionProto,
                  #code: %valueOflambda,
                  #class: "Object",
                  #extensible: true,]
                 'length' : {#value (0.) ,
                             #writable false ,
                             #configurable false}})
let (%hasOwnPropertylambda = func(this , args)
                             {if (prim("hasOwnProperty", this , args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                 {true}
                                 else
                                 {false}})
let (%hasOwnProperty = {[#proto: %FunctionProto,
                         #code: %hasOwnPropertylambda,
                         #class: "Object",
                         #extensible: true,]
                        'length' : {#value (1.) ,
                                    #writable false ,
                                    #configurable false}})
let (%IsPrototypeOflambda = func(this , args)
                            {rec (searchChain = func(o , v)
                                                {let (vproto = v[<#proto>])
                                                 if (prim("stx=", vproto , null))
                                                    {false}
                                                    else
                                                    if (prim("stx=", o , vproto))
                                                       {true}
                                                       else
                                                       {searchChain(o,
                                                                    vproto)}})
                             let (vtype = prim("typeof", args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                             if (if (prim("!", prim("stx=", vtype , "object")))
                                    {prim("!", prim("stx=", vtype , "function"))}
                                    else
                                    {false})
                                {false}
                                else
                                {let (O = %ToObject(this))
                                 searchChain(O,
                                             args["0" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])}})
let (%isPrototypeOf = {[#proto: %FunctionProto,
                        #code: %IsPrototypeOflambda,
                        #class: "Object",
                        #extensible: true,]
                       'length' : {#value (1.) ,
                                   #writable false ,
                                   #configurable false}})
let (%EvalErrorProto = {[#proto: %ErrorProto,
                         #class: "Object",
                         #extensible: true,]
                        'name' : {#value ("EvalError") ,
                                  #writable false ,
                                  #configurable false}})
let (%NativeErrorConstructor = func(proto)
                               {func(this , args)
                                {let (rtn = {[#proto: proto,
                                              #class: "Error",
                                              #extensible: true,]})
                                 if (if (prim("stx=", args["0" , {[#proto: null,
                                                                   #class: "Object",
                                                                   #extensible: true,]}] , undefined))
                                        {false}
                                        else
                                        {true})
                                    {let ($newVal = %ToString(args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                     rtn["message" = $newVal ,
                                         {[#proto: null,
                                           #class: "Object",
                                           #extensible: true,]
                                          '0' : {#value ($newVal) ,
                                                 #writable true ,
                                                 #configurable true}}];
                                     rtn}
                                    else
                                    {rtn}}})
let (%SyntaxErrorConstructor = %NativeErrorConstructor(%SyntaxErrorProto))
let (%SyntaxErrorGlobalFuncObj = {[#proto: %SyntaxErrorProto,
                                   #code: %SyntaxErrorConstructor,
                                   #class: "Object",
                                   #extensible: true,]
                                  'prototype' : {#value (%SyntaxErrorProto) ,
                                                 #writable false ,
                                                 #configurable false}})
let (%EvalErrorConstructor = %NativeErrorConstructor(%EvalErrorProto))
let (%EvalErrorGlobalFuncObj = {[#proto: %FunctionProto,
                                 #code: %EvalErrorConstructor,
                                 #class: "Object",
                                 #extensible: true,]
                                'prototype' : {#value (%EvalErrorProto) ,
                                               #writable false ,
                                               #configurable false}})
let (%RangeErrorProto = {[#proto: %ErrorProto,
                          #class: "Object",
                          #extensible: true,]
                         'name' : {#value ("RangeError") ,
                                   #writable false ,
                                   #configurable false}})
let (%RangeErrorConstructor = %NativeErrorConstructor(%RangeErrorProto))
let (%RangeErrorGlobalFuncObj = {[#proto: %RangeErrorProto,
                                  #code: %RangeErrorConstructor,
                                  #class: "Object",
                                  #extensible: true,]
                                 'prototype' : {#value (%RangeErrorProto) ,
                                                #writable false ,
                                                #configurable false}})
let (%ReferenceErrorConstructor = %NativeErrorConstructor(%ReferenceErrorProto))
let (%ReferenceErrorGlobalFuncObj = {[#proto: %ReferenceErrorProto,
                                      #code: %ReferenceErrorConstructor,
                                      #class: "Object",
                                      #extensible: true,]
                                     'prototype' : {#value (%ReferenceErrorProto) ,
                                                    #writable false ,
                                                    #configurable false}})
let (%TypeErrorConstructor = %NativeErrorConstructor(%TypeErrorProto))
let (%TypeErrorGlobalFuncObj = {[#proto: %TypeErrorProto,
                                 #code: %TypeErrorConstructor,
                                 #class: "Object",
                                 #extensible: true,]
                                'prototype' : {#value (%TypeErrorProto) ,
                                               #writable false ,
                                               #configurable false}})
let (%URIErrorProto = {[#proto: %ErrorProto,
                        #class: "Object",
                        #extensible: true,]
                       'name' : {#value ("URIError") ,
                                 #writable false ,
                                 #configurable false}})
let (%URIErrorConstructor = %NativeErrorConstructor(%URIErrorProto))
let (%URIErrorGlobalFuncObj = {[#proto: %FunctionProto,
                                #code: %URIErrorConstructor,
                                #class: "Object",
                                #extensible: true,]
                               'prototype' : {#value (%URIErrorProto) ,
                                              #writable false ,
                                              #configurable false}})
let (%ArrayProto = {[#proto: %ObjectProto,
                     #class: "Array",
                     #extensible: true,]
                    'length' : {#value (0.) ,
                                #writable true ,
                                #configurable false}})
let (%gopnLambda = func(this , args)
                   {let (O = args["0" , {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]}])
                    {%ObjectTypeCheck(O);
                     let (A = {[#proto: %ArrayProto,
                                #class: "Array",
                                #extensible: true,]
                               'length' : {#value (0.) ,
                                           #writable true ,
                                           #configurable false}})
                     let (props = get-own-field-names(O))
                     let (len = props["length" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                     rec (loop = func(i)
                                 {if (prim("<", i , len))
                                     {let (to = prim("prim->str", i))
                                      let (from = prim("prim->str", prim
                                                                    ("-", len , prim
                                                                    ("+", i , 1.))))
                                      let ($newVal = props[from , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                      A[to = $newVal ,
                                        {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]
                                         '0' : {#value ($newVal) ,
                                                #writable true ,
                                                #configurable true}}];
                                      loop(prim("+", i , 1.))}
                                     else
                                     {let ($newVal = i)
                                      A["length" = $newVal ,
                                        {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]
                                         '0' : {#value ($newVal) ,
                                                #writable true ,
                                                #configurable true}}]}})
                     {loop(0.);
                      A}}})
let (%gopn = {[#proto: %FunctionProto,
               #code: %gopnLambda,
               #class: "Object",
               #extensible: true,]})
let (%definePropertiesLambda = func(this , args)
                               {let (O = args["0" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}])
                                {%ObjectTypeCheck(O);
                                 let (props = %ToObject(args["1" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                 let (names = get-own-field-names(props))
                                 let (len = names["length" , {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}])
                                 rec (loop = func(i)
                                             {label ret :
                                              {if (prim("<", i , len))
                                                  {let (indx = prim("prim->str", i))
                                                   let (name = names[indx , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                   if (props[name <#enumerable>])
                                                      {let (argsObj = {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]})
                                                       {let ($newVal = O)
                                                        argsObj["0" = $newVal ,
                                                                {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]
                                                                 '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                        let ($newVal = name)
                                                        argsObj["1" = $newVal ,
                                                                {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]
                                                                 '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                        let ($newVal = props
                                                                    [name , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                        argsObj["2" = $newVal ,
                                                                {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]
                                                                 '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                        let ($newVal = 3.)
                                                        argsObj["length" = $newVal ,
                                                                {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]
                                                                 '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                        %definePropertylambda
                                                          (null,
                                                           argsObj);
                                                        break ret loop
                                                                    (prim
                                                                    ("+", i , 1.))}}
                                                      else
                                                      {break ret loop
                                                                   (prim
                                                                    ("+", i , 1.))}}
                                                  else
                                                  {break ret undefined}}})
                                 loop(0.);
                                 O}})
let (%defineProperties = {[#proto: %FunctionProto,
                           #code: %definePropertiesLambda,
                           #class: "Object",
                           #extensible: true,]})
let (%createLambda = func(this , args)
                     {let (O = args["0" , {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]}])
                      let (t = prim("typeof", O))
                      let (c1 = if (prim("stx=", t , "object"))
                                   {false}
                                   else
                                   {true})
                      let (c2 = if (prim("stx=", t , "function"))
                                   {false}
                                   else
                                   {true})
                      let (c3 = if (prim("stx=", O , null))
                                   {false}
                                   else
                                   {true})
                      {if (if (if (c1)
                                  {c2}
                                  else
                                  {false})
                              {c3}
                              else
                              {false})
                          {%TypeError("Object.create failed")}
                          else
                          {null};
                       let (obj = {[#proto: O,
                                    #class: "Object",
                                    #extensible: true,]})
                       if (if (prim(">=", args["length" , {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]}] , 2.))
                              {if (prim("stx=", args["1" , {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]}] , undefined))
                                  {false}
                                  else
                                  {true}}
                              else
                              {false})
                          {let (Properties = %ToObject(args["1" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                           let (argsObj = {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]})
                           {let ($newVal = obj)
                            argsObj["0" = $newVal ,
                                    {[#proto: null,
                                      #class: "Object",
                                      #extensible: true,]
                                     '0' : {#value ($newVal) ,
                                            #writable true ,
                                            #configurable true}}];
                            let ($newVal = Properties)
                            argsObj["1" = $newVal ,
                                    {[#proto: null,
                                      #class: "Object",
                                      #extensible: true,]
                                     '0' : {#value ($newVal) ,
                                            #writable true ,
                                            #configurable true}}];
                            let ($newVal = 2.)
                            argsObj["length" = $newVal ,
                                    {[#proto: null,
                                      #class: "Object",
                                      #extensible: true,]
                                     '0' : {#value ($newVal) ,
                                            #writable true ,
                                            #configurable true}}];
                            %definePropertiesLambda(null,
                                                    argsObj);
                            obj}}
                          else
                          {obj}}})
let (%create = {[#proto: %FunctionProto,
                 #code: %createLambda,
                 #class: "Object",
                 #extensible: true,]})
let (%sealLambda = func(this , args)
                   {let (O = args["0" , {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]}])
                    {%ObjectTypeCheck(O);
                     let (names = get-own-field-names(O))
                     let (len = names["length" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                     rec (loop = func(i)
                                 {if (prim("<", i , len))
                                     {let (name = names[prim("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                      O[name<#configurable>=false];
                                      loop(prim("+", i , 1.))}
                                     else
                                     {null}})
                     loop(0.);
                     O[<#extensible>=false];
                     O}})
let (%seal = {[#proto: %FunctionProto,
               #code: %sealLambda,
               #class: "Object",
               #extensible: true,]})
let (%freezelambda = func(this , args)
                     {let (O = args["0" , {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]}])
                      {%ObjectTypeCheck(O);
                       let (names = get-own-field-names(O))
                       let (len = names["length" , {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]}])
                       rec (loop = func(i)
                                   {if (prim("<", i , len))
                                       {let (name = names[prim("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                        {if (prim("!", prim("isAccessor", O , name)))
                                            {if (O[name <#writable>])
                                                {O[name<#writable>=false]}
                                                else
                                                {undefined}}
                                            else
                                            {undefined};
                                         O[name<#configurable>=false];
                                         loop(prim("+", i , 1.))}}
                                       else
                                       {null}})
                       {loop(0.);
                        O[<#extensible>=false];
                        O}}})
let (%freeze = {[#proto: %FunctionProto,
                 #code: %freezelambda,
                 #class: "Object",
                 #extensible: true,]})
let (%preventExtensionsLambda = func(this , args)
                                {let (O = args["0" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}])
                                 {%ObjectTypeCheck(O);
                                  O[<#extensible>=false];
                                  O}})
let (%preventExtensions = {[#proto: %FunctionProto,
                            #code: %preventExtensionsLambda,
                            #class: "Object",
                            #extensible: true,]})
let (%isFrozenLambda = func(this , args)
                       {let (O = args["0" , {[#proto: null,
                                              #class: "Object",
                                              #extensible: true,]}])
                        {%ObjectTypeCheck(O);
                         let (names = get-own-field-names(O))
                         let (len = names["length" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}])
                         rec (loop = func(i)
                                     {label ret :
                                      {if (prim("<", i , len))
                                          {let (name = names[prim("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                           let (isData = prim("!", prim
                                                                    ("isAccessor", O , name)))
                                           {if (if (isData)
                                                   {O[name <#writable>]}
                                                   else
                                                   {false})
                                               {break ret false}
                                               else
                                               {null};
                                            if (O[name <#configurable>])
                                               {break ret false}
                                               else
                                               {null};
                                            break ret loop(prim("+", i , 1.))}}
                                          else
                                          {break ret prim("!", O[<#extensible>])}}})
                         loop(0.)}})
let (%isFrozen = {[#proto: %FunctionProto,
                   #code: %isFrozenLambda,
                   #class: "Object",
                   #extensible: true,]})
let (%isSealedLambda = func(this , args)
                       {let (O = args["0" , {[#proto: null,
                                              #class: "Object",
                                              #extensible: true,]}])
                        {%ObjectTypeCheck(O);
                         let (names = get-own-field-names(O))
                         let (len = names["length" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}])
                         rec (loop = func(i)
                                     {label ret :
                                      {if (prim("<", i , len))
                                          {let (name = names[prim("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                           if (O[name <#configurable>])
                                              {break ret false}
                                              else
                                              {null};
                                           break ret loop(prim("+", i , 1.))}
                                          else
                                          {break ret prim("!", O[<#extensible>])}}})
                         loop(0.)}})
let (%isSealed = {[#proto: %FunctionProto,
                   #code: %isSealedLambda,
                   #class: "Object",
                   #extensible: true,]})
let (%isExtensibleLambda = func(this , args)
                           {let (O = args["0" , {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]}])
                            {%ObjectTypeCheck(O);
                             O[<#extensible>]}})
let (%isExtensible = {[#proto: %FunctionProto,
                       #code: %isExtensibleLambda,
                       #class: "Object",
                       #extensible: true,]})
let (%propertyNames = func(obj , get-non-enumerable)
                      {let (aux = {[#proto: null,
                                    #class: "Object",
                                    #extensible: true,]})
                       rec (helper = func(obj)
                                     {if (prim("stx=", obj , null))
                                         {undefined}
                                         else
                                         {let (cur = get-own-field-names(obj))
                                          let (length = cur["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                          rec (loop = func(i)
                                                      {if (prim("<", i , length))
                                                          {let (istr = prim
                                                                    ("prim->str", i))
                                                           {if (let (%or = obj
                                                                    [cur
                                                                    [istr , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] <#enumerable>])
                                                                if (%or)
                                                                   {%or}
                                                                   else
                                                                   {get-non-enumerable})
                                                               {let ($newVal = true)
                                                                aux[cur
                                                                    [istr , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] = $newVal ,
                                                                    {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]
                                                                    '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}]}
                                                               else
                                                               {undefined};
                                                            loop(prim
                                                                   ("+", i , 1.))}}
                                                          else
                                                          {undefined}})
                                          loop(0.);
                                          helper(obj[<#proto>])}})
                       {helper(obj);
                        get-own-field-names(aux)}})
let (%keysLambda = func(this , args)
                   {let (O = args["0" , {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]}])
                    {%ObjectTypeCheck(O);
                     let (A = {[#proto: %ArrayProto,
                                #class: "Array",
                                #extensible: true,]
                               'length' : {#value (0.) ,
                                           #writable true ,
                                           #configurable false}})
                     let (names = get-own-field-names(O))
                     let (len = names["length" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                     rec (loop = func(i , enumCount)
                                 {if (prim("<", i , len))
                                     {let (indx = prim("prim->str", i))
                                      let (name = names[indx , {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]}])
                                      if (O[name <#enumerable>])
                                         {let (pd = {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]
                                                     'value' : {#value (name) ,
                                                                #writable true ,
                                                                #configurable false},
                                                     'writable' : {#value (true) ,
                                                                   #writable true ,
                                                                   #configurable false},
                                                     'enumerable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                     'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}})
                                          %defineOwnProperty(A,
                                                             prim("prim->str", enumCount),
                                                             pd);
                                          loop(prim("+", i , 1.),
                                               prim("+", enumCount , 1.))}
                                         else
                                         {loop(prim("+", i , 1.),
                                               enumCount)}}
                                     else
                                     {let ($newVal = enumCount)
                                      A["length" = $newVal ,
                                        {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]
                                         '0' : {#value ($newVal) ,
                                                #writable true ,
                                                #configurable true}}]}})
                     {loop(0.,
                           0.);
                      A}}})
let (%keys = {[#proto: %FunctionProto,
               #code: %keysLambda,
               #class: "Object",
               #extensible: true,]})
let (%ToUint = func(n , limit)
               {let (number = %ToNumber(n))
                if (let (%or = let (%or = let (%or = if (prim("stx=", number , number))
                                                        {false}
                                                        else
                                                        {true})
                                          if (%or)
                                             {%or}
                                             else
                                             {prim("stx=", number , 0.)})
                               if (%or)
                                  {%or}
                                  else
                                  {prim("stx=", number , +inf)})
                    if (%or)
                       {%or}
                       else
                       {prim("stx=", number , -inf)})
                   {0.}
                   else
                   {let (sign = if (prim("<", number , 0.))
                                   {prim("-", 0. , 1.)}
                                   else
                                   {1.})
                    let (posInt = prim("*", sign , prim("floor", prim
                                                                   ("abs", number))))
                    if (prim("<", sign , 0.))
                       {let (close = prim("%", posInt , limit))
                        prim("+", close , limit)}
                       else
                       {prim("%", posInt , limit)}}})
let (%ToUint32 = func(n)
                 {%ToUint(n,
                          4294967296.)})
let (%ToInt32 = func(n)
                {let (int32bit = %ToUint32(n))
                 if (prim(">=", int32bit , 2147483648.))
                    {prim("-", int32bit , 4294967296.)}
                    else
                    {int32bit}})
let (%ToUint16 = func(n)
                 {%ToUint(n,
                          65536.)})
let (%fromcclambda = func(this , args)
                     {if (prim("stx=", args["length" , {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]}] , 0.))
                         {""}
                         else
                         {let (end = args["length" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}])
                          rec (loop = func(i , soFar)
                                      {if (prim("<", i , end))
                                          {let (char = prim("ascii_ntoc", %ToUint16
                                                                    (args
                                                                    [prim
                                                                    ("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])))
                                           let (next = prim("string+", soFar , char))
                                           loop(prim("+", i , 1.),
                                                next)}
                                          else
                                          {soFar}})
                          loop(0.,
                               "")}})
let (%fromCharCode = {[#proto: %FunctionProto,
                       #code: %fromcclambda,
                       #class: "Object",
                       #extensible: true,]
                      'length' : {#value (1.) ,
                                  #writable false ,
                                  #configurable false}})
let (%joinlambda = func(this , args)
                   {let (O = %ToObject(this))
                    let (lenVal = O["length" , {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]}])
                    let (len = %ToUint32(lenVal))
                    let (sep = if (prim("stx=", args["0" , {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]}] , undefined))
                                  {","}
                                  else
                                  {%ToString(args["0" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])})
                    label ret :
                    {if (prim("stx=", len , 0.))
                        {break ret ""}
                        else
                        {null};
                     rec (loop = func(k , R)
                                 {if (prim(">=", k , len))
                                     {R}
                                     else
                                     {let (S = prim("string+", R , sep))
                                      let (element = O[%ToString(k) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                      let (next = if (let (%or = prim
                                                                   ("stx=", element , null))
                                                      if (%or)
                                                         {%or}
                                                         else
                                                         {prim("stx=", element , undefined)})
                                                     {""}
                                                     else
                                                     {%ToString(element)})
                                      loop(prim("+", k , 1.),
                                           prim("string+", S , next))}})
                     let (start = if (let (%or = prim("stx=", O["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                      if (%or)
                                         {%or}
                                         else
                                         {prim("stx=", O["0" , {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]}] , null)})
                                     {""}
                                     else
                                     {%ToString(O["0" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])})
                     break ret loop(1.,
                                    start)}})
let (%join = {[#proto: %FunctionProto,
               #code: %joinlambda,
               #class: "Object",
               #extensible: true,]})
let (%poplambda = func(this , args)
                  {let (O = %ToObject(this))
                   let (lenVal = O["length" , {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]}])
                   let (len = %ToUint32(lenVal))
                   if (prim("stx=", len , 0.))
                      {let ($newVal = 0.)
                       O["length" = $newVal ,
                         {[#proto: null, #class: "Object", #extensible: true,]
                          '0' : {#value ($newVal) ,
                                 #writable true ,
                                 #configurable true}}];
                       undefined}
                      else
                      {let (indx = %ToString(prim("-", len , 1.)))
                       let (element = O[indx , {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]}])
                       {O[delete indx];
                        let ($newVal = %ToNumber(indx))
                        O["length" = $newVal ,
                          {[#proto: null,
                            #class: "Object",
                            #extensible: true,]
                           '0' : {#value ($newVal) ,
                                  #writable true ,
                                  #configurable true}}];
                        element}}})
let (%pop = {[#proto: %FunctionProto,
              #code: %poplambda,
              #class: "Object",
              #extensible: true,]})
let (%ArrayLengthChange = func(arr , newlen)
                          {let (oldlen = %ToUint32(arr["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                           rec (fix = func(i)
                                      {if (prim("<", i , oldlen))
                                          {arr[delete prim("prim->str", i)];
                                           fix(prim("+", i , 1.))}
                                          else
                                          {undefined}})
                           fix(newlen)})
let (%set-property = func(obj , fld , val)
                     {let (obj = %ToObject(obj))
                      let (fld = %ToString(fld))
                      let (check = func(flag)
                                   {if (flag)
                                       {%TypeError("set-property failed")}
                                       else
                                       {null}})
                      let (e = prim("!", obj[<#extensible>]))
                      {check(e);
                       let (isArrayIndex = func()
                                           {let (uint = %ToUint32(fld))
                                            if (prim("stx=", %ToString(uint) , fld))
                                               {if (prim("stx=", uint , 4294967295.))
                                                   {false}
                                                   else
                                                   {true}}
                                               else
                                               {false}})
                       let (setArrayField = func()
                                            {let (lenCheck = func()
                                                             {if (prim
                                                                    ("stx=", fld , "length"))
                                                                 {let (newLen = %ToUint32
                                                                    (val))
                                                                  let (toCompare = %ToNumber
                                                                    (val))
                                                                  if (if (prim
                                                                    ("stx=", newLen , toCompare))
                                                                    {false}
                                                                    else
                                                                    {true})
                                                                    {throw %JSError
                                                                    ({[#proto: %RangeErrorProto,
                                                                    #class: "Object",
                                                                    #extensible: true,]})}
                                                                    else
                                                                    if (prim
                                                                    ("<", newLen , obj
                                                                    ["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                                                    {%ArrayLengthChange
                                                                    (obj,
                                                                    newLen)}
                                                                    else
                                                                    {undefined}}
                                                                 else
                                                                 {undefined}})
                                             {lenCheck();
                                              let ($newVal = if (prim
                                                                   ("stx=", fld , "length"))
                                                                {%ToUint32
                                                                  (val)}
                                                                else
                                                                {val})
                                              obj[fld = $newVal ,
                                                  {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]
                                                   '0' : {#value ($newVal) ,
                                                          #writable true ,
                                                          #configurable true}}];
                                              if (isArrayIndex())
                                                 {let (uint = %ToUint32(fld))
                                                  let (len = obj["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                  if (prim("<", len , prim
                                                                    ("+", uint , 1.)))
                                                     {let ($newVal = prim
                                                                    ("+", uint , 1.))
                                                      obj["length" = $newVal ,
                                                          {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]
                                                           '0' : {#value ($newVal) ,
                                                                  #writable true ,
                                                                  #configurable true}}]}
                                                     else
                                                     {undefined}}
                                                 else
                                                 {undefined}}})
                       if (prim("stx=", obj[<#class>] , "Array"))
                          {setArrayField()}
                          else
                          {let ($newVal = val)
                           obj[fld = $newVal ,
                               {[#proto: null,
                                 #class: "Object",
                                 #extensible: true,]
                                '0' : {#value ($newVal) ,
                                       #writable true ,
                                       #configurable true}}]}}})
let (%pushlambda = func(this , args)
                   {let (O = %ToObject(this))
                    let (lenVal = O["length" , {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]}])
                    let (len = %ToUint32(lenVal))
                    rec (loop = func(i , n)
                                {if (prim("<", i , args["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                    {let (ii = prim("prim->str", i))
                                     %set-property(O,
                                                   %ToString(n),
                                                   args[ii , {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}]);
                                     loop(prim("+", i , 1.),
                                          prim("+", n , 1.))}
                                    else
                                    {n}})
                    loop(0.,
                         len)})
let (%push = {[#proto: %FunctionProto,
               #code: %pushlambda,
               #class: "Object",
               #extensible: true,]})
let (%reverselambda = func(this , args)
                      {let (O = %ToObject(this))
                       let (lenVal = O["length" , {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]}])
                       let (len = %ToUint32(lenVal))
                       let (middle = prim("floor", prim("/", len , 2.)))
                       rec (loop = func(lower)
                                   {if (if (prim("stx=", lower , middle))
                                           {false}
                                           else
                                           {true})
                                       {label ret :
                                        {let (upper = prim("-", prim("-", len , lower) , 1.))
                                         let (upperP = %ToString(upper))
                                         let (lowerP = %ToString(lower))
                                         let (lowerValue = O[lowerP , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                         let (upperValue = O[upperP , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                         let (lowerExists = prim("hasProperty", O , lowerP))
                                         let (upperExists = prim("hasProperty", O , upperP))
                                         if (if (lowerExists)
                                                {upperExists}
                                                else
                                                {false})
                                            {let ($newVal = upperValue)
                                             O[lowerP = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}];
                                             let ($newVal = lowerValue)
                                             O[upperP = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}];
                                             break ret loop(prim("+", lower , 1.))}
                                            else
                                            {null};
                                         if (upperExists)
                                            {let ($newVal = upperValue)
                                             O[lowerP = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}];
                                             O[delete upperP];
                                             break ret loop(prim("+", lower , 1.))}
                                            else
                                            {null};
                                         if (lowerExists)
                                            {O[delete lowerP];
                                             let ($newVal = lowerValue)
                                             O[upperP = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}];
                                             break ret loop(prim("+", lower , 1.))}
                                            else
                                            {null};
                                         break ret loop(prim("+", lower , 1.))}}
                                       else
                                       {undefined}})
                       {loop(0.);
                        O}})
let (%reverse = {[#proto: %FunctionProto,
                  #code: %reverselambda,
                  #class: "Object",
                  #extensible: true,]})
let (%shiftlambda = func(this , args)
                    {let (O = %ToObject(this))
                     let (lenVal = O["length" , {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]}])
                     let (len = %ToUint32(lenVal))
                     if (prim("stx=", len , 0.))
                        {let ($newVal = 0.)
                         O["length" = $newVal ,
                           {[#proto: null,
                             #class: "Object",
                             #extensible: true,]
                            '0' : {#value ($newVal) ,
                                   #writable true ,
                                   #configurable true}}];
                         undefined}
                        else
                        {let (first = O["0" , {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]}])
                         rec (loop = func(k)
                                     {label ret :
                                      {if (prim(">=", k , len))
                                          {break ret undefined}
                                          else
                                          {null};
                                       let (from = %ToString(k))
                                       let (to = %ToString(prim("-", k , 1.)))
                                       let (fromPresent = prim("hasProperty", O , from))
                                       if (fromPresent)
                                          {let (fromVal = O[from , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                           let ($newVal = fromVal)
                                           O[to = $newVal ,
                                             {[#proto: null,
                                               #class: "Object",
                                               #extensible: true,]
                                              '0' : {#value ($newVal) ,
                                                     #writable true ,
                                                     #configurable true}}];
                                           break ret loop(prim("+", k , 1.))}
                                          else
                                          {O[delete to];
                                           break ret loop(prim("+", k , 1.))}}})
                         loop(1.);
                         let (newLen = prim("-", len , 1.))
                         O[delete %ToString(newLen)];
                         let ($newVal = newLen)
                         O["length" = $newVal ,
                           {[#proto: null,
                             #class: "Object",
                             #extensible: true,]
                            '0' : {#value ($newVal) ,
                                   #writable true ,
                                   #configurable true}}];
                         first}})
let (%shift = {[#proto: %FunctionProto,
                #code: %shiftlambda,
                #class: "Object",
                #extensible: true,]})
let (%arrayToStringlambda = func(this , args)
                            {let (array = %ToObject(this))
                             let (thefunc = array["join" , {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]}])
                             let (ffunc = if (if (prim("!", prim("stx=", prim
                                                                    ("typeof", thefunc) , "object")))
                                                 {prim("!", prim("stx=", prim
                                                                    ("typeof", thefunc) , "function"))}
                                                 else
                                                 {false})
                                             {%objectToStringlambda}
                                             else
                                             if (prim("stx=", thefunc
                                                                [<#code>] , null))
                                                {%objectToStringlambda}
                                                else
                                                {thefunc})
                             ffunc(array,
                                   {[#proto: null,
                                     #class: "Object",
                                     #extensible: true,]})})
let (%arrayToString = {[#proto: %FunctionProto,
                        #code: %arrayToStringlambda,
                        #class: "Object",
                        #extensible: true,]
                       'length' : {#value (0.) ,
                                   #writable false ,
                                   #configurable false}})
let (%arrayTLSlambda = func(this , args)
                       {let (isCallable = func(o)
                                          {label ret :
                                           {if (if (prim("!", prim("stx=", prim
                                                                    ("typeof", o) , "object")))
                                                   {prim("!", prim("stx=", prim
                                                                    ("typeof", o) , "function"))}
                                                   else
                                                   {false})
                                               {break ret false}
                                               else
                                               {null};
                                            if (prim("stx=", o[<#code>] , null))
                                               {break ret false}
                                               else
                                               {null};
                                            break ret true}})
                        let (array = %ToObject(this))
                        let (arrayLen = array["length" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}])
                        let (len = %ToUint32(arrayLen))
                        let (separator = " ")
                        label ret :
                        {if (prim("stx=", len , 0.))
                            {break ret ""}
                            else
                            {null};
                         let (firstElement = array["0" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}])
                         let (R = if (let (%or = prim("stx=", firstElement , null))
                                      if (%or)
                                         {%or}
                                         else
                                         {prim("stx=", firstElement , undefined)})
                                     {""}
                                     else
                                     {let (elementObj = %ToObject(firstElement))
                                      let (funcc = elementObj["toLocaleString" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                      if (prim("!", isCallable(funcc)))
                                         {%TypeError("Not callable in ArrayTLS")}
                                         else
                                         {null};
                                      funcc(elementObj,
                                            {[#proto: null,
                                              #class: "Object",
                                              #extensible: true,]})})
                         rec (inner = func(k , r)
                                      {if (prim(">=", k , len))
                                          {r}
                                          else
                                          {let (S = prim("string+", prim
                                                                    ("prim->str", r) , separator))
                                           let (nextElement = array[prim
                                                                    ("prim->str", k) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                           let (toAppend = if (let (%or = prim
                                                                    ("stx=", nextElement , null))
                                                               if (%or)
                                                                  {%or}
                                                                  else
                                                                  {prim
                                                                    ("stx=", nextElement , undefined)})
                                                              {""}
                                                              else
                                                              {let (elementObj = %ToObject
                                                                    (nextElement))
                                                               let (funcc = elementObj
                                                                    ["toLocaleString" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                               {if (prim
                                                                    ("!", isCallable
                                                                    (funcc)))
                                                                   {throw %JSError
                                                                    ({[#proto: %TypeErrorProto,
                                                                    #class: "Object",
                                                                    #extensible: true,]})}
                                                                   else
                                                                   {null};
                                                                funcc
                                                                  (elementObj,
                                                                   {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]})}})
                                           inner(prim("+", k , 1.),
                                                 prim("string+", prim
                                                                   ("prim->str", r) , prim
                                                                    ("prim->str", toAppend)))}})
                         break ret inner(1.,
                                         R)}})
let (%arrayToLocaleString = {[#proto: %FunctionProto,
                              #code: %arrayTLSlambda,
                              #class: "Object",
                              #extensible: true,]
                             'length' : {#value (0.) ,
                                         #writable false ,
                                         #configurable false}})
let (%ArrayConstructor = func(this , args)
                         {label ret :
                          {if (prim(">=", args["length" , {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]}] , 2.))
                              {let (rtnobj = {[#proto: %ArrayProto,
                                               #class: "Array",
                                               #extensible: true,]
                                              'length' : {#value (0.) ,
                                                          #writable true ,
                                                          #configurable false}})
                               rec (init = func(n)
                                           {let ($newVal = args[prim("prim->str", n) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                            rtnobj[prim("prim->str", n) = $newVal ,
                                                   {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]
                                                    '0' : {#value ($newVal) ,
                                                           #writable true ,
                                                           #configurable true}}];
                                            if (prim(">", n , 0.))
                                               {init(prim("-", n , 1.))}
                                               else
                                               {undefined}})
                               {init(args["length" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]);
                                let ($newVal = args["length" , {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]}])
                                rtnobj["length" = $newVal ,
                                       {[#proto: null,
                                         #class: "Object",
                                         #extensible: true,]
                                        '0' : {#value ($newVal) ,
                                               #writable true ,
                                               #configurable true}}];
                                break ret rtnobj}}
                              else
                              {null};
                           let (c1 = prim("stx=", prim("typeof", args
                                                                   ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , "number"))
                           let (c2 = if (c1)
                                        {if (prim("stx=", %ToUint32(args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                            {false}
                                            else
                                            {true}}
                                        else
                                        {false})
                           if (c2)
                              {throw %JSError({[#proto: %RangeErrorProto,
                                                #class: "Object",
                                                #extensible: true,]})}
                              else
                              if (c1)
                                 {break ret {[#proto: %ArrayProto,
                                              #class: "Array",
                                              #extensible: true,]
                                             'length' : {#value (%ToUint32
                                                                  (args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])) ,
                                                         #writable true ,
                                                         #configurable false}}}
                                 else
                                 {let (rtn = {[#proto: %ArrayProto,
                                               #class: "Array",
                                               #extensible: true,]
                                              'length' : {#value (args
                                                                   ["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) ,
                                                          #writable true ,
                                                          #configurable false}})
                                  {%defineOwnProperty(rtn,
                                                      "0",
                                                      {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]
                                                       'value' : {#value (args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) ,
                                                                  #writable true ,
                                                                  #configurable false},
                                                       'writable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                       'enumerable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                       'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}});
                                   break ret rtn}}}})
let (%concatLambda = func(this , args)
                     {let (O = %ToObject(this))
                      let (emptyobj = {[#proto: null,
                                        #class: "Object",
                                        #extensible: true,]})
                      let (A = %ArrayConstructor(emptyobj,
                                                 emptyobj))
                      rec (procElt = func(obj , elt , n)
                                     {let (procNormalElt = func(nelt , k)
                                                           {let ($newVal = nelt)
                                                            obj[prim("prim->str", k) = $newVal ,
                                                                {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]
                                                                 '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                            prim("+", k , 1.)})
                                      rec (procArrayElt = func(arr , fromIndex , toIndex)
                                                          {if (prim("stx=", arr
                                                                    [prim
                                                                    ("prim->str", fromIndex) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                                              {toIndex}
                                                              else
                                                              {let ($newVal = arr
                                                                    [prim
                                                                    ("prim->str", fromIndex) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                               obj[prim
                                                                    ("prim->str", toIndex) = $newVal ,
                                                                   {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]
                                                                    '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                               procArrayElt
                                                                 (arr,
                                                                  prim
                                                                    ("+", fromIndex , 1.),
                                                                  prim
                                                                    ("+", toIndex , 1.))}})
                                      if (prim("stx=", prim("typeof", elt) , "object"))
                                         {if (prim("stx=", elt[<#class>] , "Array"))
                                             {procArrayElt(elt,
                                                           0.,
                                                           n)}
                                             else
                                             {procNormalElt(elt,
                                                            n)}}
                                         else
                                         {procNormalElt(elt,
                                                        n)}})
                      rec (procAllElts = func(from , fromIndex , toIndex)
                                         {if (if (prim("stx=", from[prim
                                                                    ("prim->str", fromIndex) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                                 {false}
                                                 else
                                                 {true})
                                             {let (nextI = procElt(A,
                                                                   from
                                                                    [prim
                                                                    ("prim->str", fromIndex) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}],
                                                                   toIndex))
                                              procAllElts(from,
                                                          prim("+", fromIndex , 1.),
                                                          nextI)}
                                             else
                                             {toIndex}})
                      let (halftime = if (prim("stx=", O[<#class>] , "Array"))
                                         {procAllElts(O,
                                                      0.,
                                                      0.)}
                                         else
                                         {let ($newVal = O)
                                          A["0" = $newVal ,
                                            {[#proto: null,
                                              #class: "Object",
                                              #extensible: true,]
                                             '0' : {#value ($newVal) ,
                                                    #writable true ,
                                                    #configurable true}}];
                                          1.})
                      let (end = procAllElts(args,
                                             0.,
                                             halftime))
                      {let ($newVal = end)
                       A["length" = $newVal ,
                         {[#proto: null, #class: "Object", #extensible: true,]
                          '0' : {#value ($newVal) ,
                                 #writable true ,
                                 #configurable true}}];
                       A}})
let (%concat = {[#proto: %FunctionProto,
                 #code: %concatLambda,
                 #class: "Object",
                 #extensible: true,]})
let (%sortlambda = func(this , args)
                   {let (obj = %ToObject(this))
                    let (sortCompare = func(j , k)
                                       {let (jString = %ToString(j))
                                        let (kString = %ToString(k))
                                        let (hasj = prim("hasProperty", obj , jString))
                                        let (hask = prim("hasProperty", obj , kString))
                                        label ret :
                                        {if (if (prim("stx=", hasj , false))
                                                {prim("stx=", hask , false)}
                                                else
                                                {false})
                                            {break ret 0.}
                                            else
                                            {null};
                                         if (prim("stx=", hasj , false))
                                            {break ret 1.}
                                            else
                                            {null};
                                         if (prim("stx=", hask , false))
                                            {break ret prim("-", 0. , 1.)}
                                            else
                                            {null};
                                         let (x = obj[jString , {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]}])
                                         let (y = obj[kString , {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]}])
                                         {if (if (prim("stx=", x , undefined))
                                                 {prim("stx=", y , undefined)}
                                                 else
                                                 {false})
                                             {break ret 0.}
                                             else
                                             {null};
                                          if (prim("stx=", x , undefined))
                                             {break ret 1.}
                                             else
                                             {null};
                                          if (prim("stx=", y , undefined))
                                             {break ret prim("-", 0. , 1.)}
                                             else
                                             {null};
                                          if (if (prim("stx=", args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                                 {false}
                                                 else
                                                 {true})
                                             {if (if (prim("stx=", prim
                                                                    ("typeof", args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]) , "function"))
                                                     {false}
                                                     else
                                                     {true})
                                                 {throw %JSError({[#proto: %TypeErrorProto,
                                                                   #class: "Object",
                                                                   #extensible: true,]})}
                                                 else
                                                 {null};
                                              break ret args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]
                                                          (undefined,
                                                           {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]
                                                            '0' : {#value (x) ,
                                                                   #writable true ,
                                                                   #configurable false},
                                                            '1' : {#value (y) ,
                                                                   #writable true ,
                                                                   #configurable false}})}
                                             else
                                             {null};
                                          let (xString = %ToString(x))
                                          let (yString = %ToString(y))
                                          {if (prim("string<", xString , yString))
                                              {break ret prim("-", 0. , 1.)}
                                              else
                                              {null};
                                           if (prim("string<", yString , xString))
                                              {break ret 1.}
                                              else
                                              {null};
                                           break ret 0.}}}})
                    let (insert = func(elt , before)
                                  {rec (insertAndShift = func(prior , i)
                                                         {let (indx = prim
                                                                    ("prim->str", i))
                                                          let (next = obj
                                                                    [indx , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                          {let ($newVal = prior)
                                                           obj[indx = $newVal ,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                           if (prim("<", i , before))
                                                              {insertAndShift
                                                                (next,
                                                                 prim
                                                                   ("+", i , 1.))}
                                                              else
                                                              {undefined}}})
                                   rec (loop = func(currIndex)
                                               {if (prim("stx=", currIndex , before))
                                                   {undefined}
                                                   else
                                                   {let (indx = prim("prim->str", currIndex))
                                                    let (result = sortCompare
                                                                    (currIndex,
                                                                    before))
                                                    if (prim("stx=", result , 1.))
                                                       {let (old = obj
                                                                    [indx , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                        {let ($newVal = elt)
                                                         obj[indx = $newVal ,
                                                             {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]
                                                              '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                         insertAndShift
                                                           (old,
                                                            prim("+", currIndex , 1.))}}
                                                       else
                                                       {loop(prim("+", currIndex , 1.))}}})
                                   loop(0.)})
                    let (len = obj["length" , {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]}])
                    rec (isort = func(i)
                                 {if (prim("<", i , len))
                                     {insert(obj[prim("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}],
                                             i);
                                      isort(prim("+", i , 1.))}
                                     else
                                     {obj}})
                    isort(1.)})
let (%sort = {[#proto: %FunctionProto,
               #code: %sortlambda,
               #class: "Object",
               #extensible: true,]})
let (%ArrayGlobalFuncObj = {[#proto: %FunctionProto,
                             #code: %ArrayConstructor,
                             #class: "Function",
                             #extensible: true,]
                            'prototype' : {#value (%ArrayProto) ,
                                           #writable false ,
                                           #configurable false}})
let (%getCurrentUTC = func()
                      {prim("current-utc-millis", "ignored")})
let (%parse = func(v)
              {0.})
let (%CheckObjectCoercible = func(o)
                             {if (let (%or = prim("stx=", o , undefined))
                                  if (%or)
                                     {%or}
                                     else
                                     {prim("stx=", o , null)})
                                 {%TypeError("Not object coercible")}
                                 else
                                 {undefined}})
let (%charatlambda = func(this , args)
                     {%CheckObjectCoercible(this);
                      let (S = %ToString(this))
                      let (position = %ToInteger(args["0" , {[#proto: null,
                                                              #class: "Object",
                                                              #extensible: true,]}]))
                      let (size = prim("strlen", S))
                      if (let (%or = prim("<", position , 0.))
                          if (%or)
                             {%or}
                             else
                             {prim(">=", position , size)})
                         {""}
                         else
                         {prim("char-at", S , position)}})
let (%charat = {[#proto: %FunctionProto,
                 #code: %charatlambda,
                 #class: "Object",
                 #extensible: true,]})
let (%charcodeatlambda = func(this , args)
                         {%CheckObjectCoercible(this);
                          let (S = %ToString(this))
                          let (position = %ToInteger(args["0" , {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]}]))
                          let (size = prim("strlen", S))
                          if (let (%or = prim("<", position , 0.))
                              if (%or)
                                 {%or}
                                 else
                                 {prim(">=", position , size)})
                             {NaN}
                             else
                             {prim("ascii_cton", prim("char-at", S , position))}})
let (%charcodeat = {[#proto: %FunctionProto,
                     #code: %charcodeatlambda,
                     #class: "Object",
                     #extensible: true,]})
let (%strconcatlambda = func(this , args)
                        {%CheckObjectCoercible(this);
                         let (S = %ToString(this))
                         let (end = args["length" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}])
                         rec (loop = func(i , soFar)
                                     {if (prim("<", i , end))
                                         {let (next = %ToString(args[prim
                                                                    ("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                          loop(prim("+", i , 1.),
                                               prim("string+", soFar , next))}
                                         else
                                         {soFar}})
                         loop(0.,
                              S)})
let (%strconcat = {[#proto: %FunctionProto,
                    #code: %strconcatlambda,
                    #class: "Object",
                    #extensible: true,]})
let (%min = func(a , b)
            {if (prim("<=", a , b))
                {a}
                else
                {b}})
let (%max = func(a , b)
            {if (prim("<=", a , b))
                {b}
                else
                {a}})
let (%substringlambda = func(this , args)
                        {%CheckObjectCoercible(this);
                         let (S = %ToString(this))
                         let (len = prim("strlen", S))
                         let (intStart = %ToInteger(args["0" , {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]}]))
                         let (intEnd = let (end = args["1" , {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}])
                                       if (prim("stx=", end , undefined))
                                          {len}
                                          else
                                          {%ToInteger(end)})
                         let (finalStart = %min(%max(intStart,
                                                     0.),
                                                len))
                         let (finalEnd = %min(%max(intEnd,
                                                   0.),
                                              len))
                         let (from = %min(finalStart,
                                          finalEnd))
                         let (to = %max(finalStart,
                                        finalEnd))
                         rec (loop = func(i , soFar)
                                     {if (prim("<", i , to))
                                         {loop(prim("+", i , 1.),
                                               prim("string+", soFar , prim
                                                                    ("char-at", S , i)))}
                                         else
                                         {soFar}})
                         loop(from,
                              "")})
let (%substring = {[#proto: %FunctionProto,
                    #code: %substringlambda,
                    #class: "Object",
                    #extensible: true,]})
let (%splicelambda = func(this , args)
                     {let (start = args["0" , {[#proto: null,
                                                #class: "Object",
                                                #extensible: true,]}])
                      let (deleteCount = args["1" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}])
                      let (O = %ToObject(this))
                      let (emptyobj = {[#proto: null,
                                        #class: "Object",
                                        #extensible: true,]})
                      let (A = {[#proto: %ArrayProto,
                                 #class: "Array",
                                 #extensible: true,]
                                'length' : {#value (0.) ,
                                            #writable true ,
                                            #configurable false}})
                      let (lenVal = O["length" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                      let (len = %ToUint32(lenVal))
                      let (relativeStart = %ToInteger(start))
                      let (actualStart = if (prim("<", relativeStart , 0.))
                                            {%max(prim("+", len , relativeStart),
                                                  0.)}
                                            else
                                            {%min(relativeStart,
                                                  len)})
                      let (actualDeleteCount = %min(%max(%ToInteger(deleteCount),
                                                         0.),
                                                    prim("-", len , actualStart)))
                      {rec (writeToALoop = func(k)
                                           {if (prim("<", k , actualDeleteCount))
                                               {let (from = %ToString
                                                              (prim("+", actualStart , k)))
                                                if (prim("hasProperty", O , from))
                                                   {let (fromValue = O[from , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                    %defineOwnProperty
                                                      (A,
                                                       %ToString(k),
                                                       {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]
                                                        'value' : {#value (fromValue) ,
                                                                   #writable true ,
                                                                   #configurable false},
                                                        'writable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                        'enumerable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                        'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}});
                                                    let ($newVal = prim
                                                                    ("+", A["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , 1.))
                                                    A["length" = $newVal ,
                                                      {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]
                                                       '0' : {#value ($newVal) ,
                                                              #writable true ,
                                                              #configurable true}}];
                                                    writeToALoop(prim
                                                                   ("+", k , 1.))}
                                                   else
                                                   {writeToALoop(prim
                                                                   ("+", k , 1.))}}
                                               else
                                               {undefined}})
                       writeToALoop(0.);
                       let (itemCount = prim("-", args["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , 2.))
                       {let (step1 = func()
                                     {if (prim("<", itemCount , actualDeleteCount))
                                         {let (end = prim("-", len , actualDeleteCount))
                                          rec (writeToOLoop = func(k)
                                                              {if (prim
                                                                    ("<", k , end))
                                                                  {let (from = %ToString
                                                                    (prim
                                                                    ("+", k , actualDeleteCount)))
                                                                   let (to = %ToString
                                                                    (prim
                                                                    ("+", k , itemCount)))
                                                                   if (prim
                                                                    ("hasProperty", O , from))
                                                                    {let ($newVal = O[from , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                                    O[to = $newVal ,
                                                                    {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]
                                                                    '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                                    writeToOLoop
                                                                    (prim
                                                                    ("+", k , 1.))}
                                                                    else
                                                                    {O[delete to];
                                                                    writeToOLoop
                                                                    (prim
                                                                    ("+", k , 1.))}}
                                                                  else
                                                                  {undefined}})
                                          writeToOLoop(actualStart);
                                          let (delLimit = prim("+", prim
                                                                    ("-", len , actualDeleteCount) , itemCount))
                                          rec (deleteloop = func(k)
                                                            {if (prim
                                                                   (">", k , delLimit))
                                                                {let (next = prim
                                                                    ("-", k , 1.))
                                                                 O[delete %ToString
                                                                    (next)];
                                                                 deleteloop
                                                                   (next)}
                                                                else
                                                                {undefined}})
                                          deleteloop(len)}
                                         else
                                         {null}})
                        step1();
                        let (step2 = func()
                                     {if (prim(">", itemCount , actualDeleteCount))
                                         {rec (writeToOLoop = func(k)
                                                              {if (prim
                                                                    (">", k , actualStart))
                                                                  {let (from = %ToString
                                                                    (prim
                                                                    ("+", k , prim
                                                                    ("-", actualDeleteCount , 1.))))
                                                                   let (to = %ToString
                                                                    (prim
                                                                    ("+", k , prim
                                                                    ("-", itemCount , 1.))))
                                                                   if (prim
                                                                    ("hasProperty", O , from))
                                                                    {let ($newVal = O[from , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                                    O[to = $newVal ,
                                                                    {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]
                                                                    '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                                    writeToOLoop
                                                                    (prim
                                                                    ("-", k , 1.))}
                                                                    else
                                                                    {O[delete to];
                                                                    writeToOLoop
                                                                    (prim
                                                                    ("-", k , 1.))}}
                                                                  else
                                                                  {undefined}})
                                          writeToOLoop(prim("-", len , actualDeleteCount))}
                                         else
                                         {undefined}})
                        step2();
                        let (outerEnd = args["length" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])
                        rec (outerloop = func(k , argsIndex)
                                         {if (prim("<", argsIndex , outerEnd))
                                             {let ($newVal = args[prim
                                                                    ("prim->str", argsIndex) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                              O[%ToString(k) = $newVal ,
                                                {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]
                                                 '0' : {#value ($newVal) ,
                                                        #writable true ,
                                                        #configurable true}}];
                                              outerloop(prim("+", k , 1.),
                                                        prim("+", argsIndex , 1.))}
                                             else
                                             {undefined}})
                        outerloop(actualStart,
                                  2.);
                        let ($newVal = prim("+", prim("-", len , actualDeleteCount) , itemCount))
                        O["length" = $newVal ,
                          {[#proto: null,
                            #class: "Object",
                            #extensible: true,]
                           '0' : {#value ($newVal) ,
                                  #writable true ,
                                  #configurable true}}];
                        A}}})
let (%splice = {[#proto: %FunctionProto,
                 #code: %splicelambda,
                 #class: "Object",
                 #extensible: true,]})
let (%unshiftlambda = func(this , args)
                      {let (O = %ToObject(this))
                       let (lenVal = O["length" , {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]}])
                       let (len = %ToUint32(lenVal))
                       let (argCount = args["length" , {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]}])
                       {rec (Oloop = func(k)
                                     {if (prim(">", k , 0.))
                                         {let (from = %ToString(prim("-", k , 1.)))
                                          let (to = %ToString(prim("+", k , prim
                                                                    ("-", argCount , 1.))))
                                          if (prim("hasProperty", O , from))
                                             {let ($newVal = O[from , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                              O[to = $newVal ,
                                                {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]
                                                 '0' : {#value ($newVal) ,
                                                        #writable true ,
                                                        #configurable true}}];
                                              Oloop(prim("-", k , 1.))}
                                             else
                                             {O[delete to];
                                              Oloop(prim("-", k , 1.))}}
                                         else
                                         {undefined}})
                        Oloop(len);
                        let (end = args["length" , {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]}])
                        rec (argsLoop = func(argsIndex , j)
                                        {if (prim("<", argsIndex , end))
                                            {let ($newVal = args[prim
                                                                   ("prim->str", argsIndex) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                             O[%ToString(j) = $newVal ,
                                               {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]
                                                '0' : {#value ($newVal) ,
                                                       #writable true ,
                                                       #configurable true}}];
                                             argsLoop(prim("+", argsIndex , 1.),
                                                      prim("+", j , 1.))}
                                            else
                                            {undefined}})
                        argsLoop(0.,
                                 0.);
                        let (finalLen = prim("+", len , argCount))
                        {let ($newVal = finalLen)
                         O["length" = $newVal ,
                           {[#proto: null,
                             #class: "Object",
                             #extensible: true,]
                            '0' : {#value ($newVal) ,
                                   #writable true ,
                                   #configurable true}}];
                         finalLen}}})
let (%unshift = {[#proto: %FunctionProto,
                  #code: %unshiftlambda,
                  #class: "Object",
                  #extensible: true,]})
let (%aiolambda = func(this , args)
                  {let (O = %ToObject(this))
                   let (lenValue = O["length" , {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]}])
                   let (len = %ToUint32(lenValue))
                   let (negOne = prim("-", 0. , 1.))
                   label ret :
                   {if (prim("stx=", len , 0.))
                       {break ret negOne}
                       else
                       {undefined};
                    let (n = if (prim("stx=", args["1" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}] , undefined))
                                {0.}
                                else
                                {%ToInteger(args["1" , {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]}])})
                    {if (prim(">=", n , len))
                        {break ret negOne}
                        else
                        {undefined};
                     rec (loop = func(k)
                                 {if (prim("<", k , len))
                                     {let (kStr = %ToString(k))
                                      if (prim("hasProperty", O , kStr))
                                         {let (elementK = O[kStr , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                          if (prim("stx=", args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , elementK))
                                             {break ret k}
                                             else
                                             {undefined};
                                          loop(prim("+", k , 1.))}
                                         else
                                         {loop(prim("+", k , 1.))}}
                                     else
                                     {undefined}})
                     let (start = if (prim(">=", n , 0.))
                                     {n}
                                     else
                                     {%max(prim("-", len , prim("abs", n)),
                                           0.)})
                     {loop(start);
                      break ret negOne}}}})
let (%arrayIndexOf = {[#proto: %FunctionProto,
                       #code: %aiolambda,
                       #class: "Object",
                       #extensible: true,]})
let (%aliolambda = func(this , args)
                   {let (O = %ToObject(this))
                    let (lenValue = O["length" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                    let (len = %ToUint32(lenValue))
                    let (negOne = prim("-", 0. , 1.))
                    label ret :
                    {if (prim("stx=", len , 0.))
                        {break ret negOne}
                        else
                        {undefined};
                     let (n = if (prim("stx=", args["1" , {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]}] , undefined))
                                 {prim("-", len , 1.)}
                                 else
                                 {%ToInteger(args["1" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])})
                     rec (loop = func(k)
                                 {if (prim(">=", k , 0.))
                                     {let (kstr = %ToString(k))
                                      if (prim("hasProperty", O , kstr))
                                         {if (prim("stx=", O[kstr , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                             {break ret k}
                                             else
                                             {loop(prim("-", k , 1.))}}
                                         else
                                         {loop(prim("-", k , 1.))}}
                                     else
                                     {undefined}})
                     let (start = if (prim(">=", n , 0.))
                                     {%min(n,
                                           prim("-", len , 1.))}
                                     else
                                     {prim("-", len , prim("abs", n))})
                     loop(start);
                     break ret negOne}})
let (%arrayLastIndexOf = {[#proto: %FunctionProto,
                           #code: %aliolambda,
                           #class: "Object",
                           #extensible: true,]})
let (%foreachlambda = func(this , args)
                      {let (O = %ToObject(this))
                       let (lenVal = O["length" , {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]}])
                       let (len = %ToUint32(lenVal))
                       let (callbackfn = args["0" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}])
                       label ret :
                       {if (if (prim("stx=", prim("typeof", callbackfn) , "function"))
                               {false}
                               else
                               {true})
                           {%TypeError("Callback not a function in forEach")}
                           else
                           {undefined};
                        let (T = args["1" , {[#proto: null,
                                              #class: "Object",
                                              #extensible: true,]}])
                        rec (loop = func(k)
                                    {if (prim("<", k , len))
                                        {let (Pk = %ToString(k))
                                         if (prim("hasProperty", O , Pk))
                                            {let (kValue = O[Pk , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                             let (argslist = {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]
                                                              '0' : {#value (kValue) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                              '1' : {#value (k) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                              '2' : {#value (O) ,
                                                                    #writable true ,
                                                                    #configurable false}})
                                             callbackfn(T,
                                                        argslist);
                                             loop(prim("+", k , 1.))}
                                            else
                                            {loop(prim("+", k , 1.))}}
                                        else
                                        {undefined}})
                        loop(0.);
                        undefined}})
let (%foreach = {[#proto: %FunctionProto,
                  #code: %foreachlambda,
                  #class: "Object",
                  #extensible: true,]})
let (%maplambda = func(this , args)
                  {let (O = %ToObject(this))
                   let (lenValue = O["length" , {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]}])
                   let (len = %ToUint32(lenValue))
                   let (callbackfn = args["0" , {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]}])
                   label ret :
                   {if (if (prim("stx=", prim("typeof", callbackfn) , "function"))
                           {false}
                           else
                           {true})
                       {%TypeError("Callback not a function in map")}
                       else
                       {null};
                    let (T = args["1" , {[#proto: null,
                                          #class: "Object",
                                          #extensible: true,]}])
                    let (A = {[#proto: %ArrayProto,
                               #class: "Array",
                               #extensible: true,]})
                    rec (loop = func(k)
                                {if (prim("<", k , len))
                                    {let (Pk = %ToString(k))
                                     if (prim("hasProperty", O , Pk))
                                        {let (kValue = O[Pk , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}])
                                         let (argsObj = {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]})
                                         {let ($newVal = kValue)
                                          argsObj["0" = $newVal ,
                                                  {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]
                                                   '0' : {#value ($newVal) ,
                                                          #writable true ,
                                                          #configurable true}}];
                                          let ($newVal = k)
                                          argsObj["1" = $newVal ,
                                                  {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]
                                                   '0' : {#value ($newVal) ,
                                                          #writable true ,
                                                          #configurable true}}];
                                          let ($newVal = O)
                                          argsObj["2" = $newVal ,
                                                  {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]
                                                   '0' : {#value ($newVal) ,
                                                          #writable true ,
                                                          #configurable true}}];
                                          let ($newVal = 3.)
                                          argsObj["length" = $newVal ,
                                                  {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]
                                                   '0' : {#value ($newVal) ,
                                                          #writable true ,
                                                          #configurable true}}];
                                          let (mappedValue = callbackfn
                                                               (T,
                                                                argsObj))
                                          %defineOwnProperty(A,
                                                             Pk,
                                                             {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]
                                                              'value' : {#value (mappedValue) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                              'writable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                              'enumerable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                              'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}});
                                          loop(prim("+", k , 1.))}}
                                        else
                                        {loop(prim("+", k , 1.))}}
                                    else
                                    {let ($newVal = k)
                                     A["length" = $newVal ,
                                       {[#proto: null,
                                         #class: "Object",
                                         #extensible: true,]
                                        '0' : {#value ($newVal) ,
                                               #writable true ,
                                               #configurable true}}]}})
                    {loop(0.);
                     break ret A}}})
let (%map = {[#proto: %FunctionProto,
              #code: %maplambda,
              #class: "Object",
              #extensible: true,]})
let (%filterlambda = func(this , args)
                     {let (O = %ToObject(this))
                      let (lenValue = O["length" , {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]}])
                      let (len = %ToUint32(lenValue))
                      let (callbackfn = args["0" , {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]}])
                      label ret :
                      {if (if (prim("stx=", prim("typeof", callbackfn) , "function"))
                              {false}
                              else
                              {true})
                          {%TypeError("Callback not a function in filter")}
                          else
                          {null};
                       let (T = args["1" , {[#proto: null,
                                             #class: "Object",
                                             #extensible: true,]}])
                       let (A = {[#proto: %ArrayProto,
                                  #class: "Array",
                                  #extensible: true,]
                                 'length' : {#value (0.) ,
                                             #writable true ,
                                             #configurable false}})
                       rec (loop = func(k , to)
                                   {if (prim("<", k , len))
                                       {let (Pk = %ToString(k))
                                        if (prim("hasProperty", O , Pk))
                                           {let (kValue = O[Pk , {[#proto: null,
                                                                   #class: "Object",
                                                                   #extensible: true,]}])
                                            let (argsObj = {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]})
                                            {let ($newVal = kValue)
                                             argsObj["0" = $newVal ,
                                                     {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]
                                                      '0' : {#value ($newVal) ,
                                                             #writable true ,
                                                             #configurable true}}];
                                             let ($newVal = k)
                                             argsObj["1" = $newVal ,
                                                     {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]
                                                      '0' : {#value ($newVal) ,
                                                             #writable true ,
                                                             #configurable true}}];
                                             let ($newVal = O)
                                             argsObj["2" = $newVal ,
                                                     {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]
                                                      '0' : {#value ($newVal) ,
                                                             #writable true ,
                                                             #configurable true}}];
                                             let ($newVal = 3.)
                                             argsObj["length" = $newVal ,
                                                     {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]
                                                      '0' : {#value ($newVal) ,
                                                             #writable true ,
                                                             #configurable true}}];
                                             let (selected = callbackfn
                                                               (T,
                                                                argsObj))
                                             if (%ToBoolean(selected))
                                                {%defineOwnProperty(A,
                                                                    %ToString
                                                                    (to),
                                                                    {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]
                                                                    'value' : {#value (kValue) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                                    'writable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                                    'enumerable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                                    'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}});
                                                 loop(prim("+", k , 1.),
                                                      prim("+", to , 1.))}
                                                else
                                                {loop(prim("+", k , 1.),
                                                      to)}}}
                                           else
                                           {loop(prim("+", k , 1.),
                                                 to)}}
                                       else
                                       {let ($newVal = to)
                                        A["length" = $newVal ,
                                          {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]
                                           '0' : {#value ($newVal) ,
                                                  #writable true ,
                                                  #configurable true}}]}})
                       {loop(0.,
                             0.);
                        break ret A}}})
let (%filter = {[#proto: %FunctionProto,
                 #code: %filterlambda,
                 #class: "Object",
                 #extensible: true,]})
let (%reducelambda = func(this , args)
                     {let (O = %ToObject(this))
                      let (lenValue = O["length" , {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]}])
                      let (len = %ToUint32(lenValue))
                      let (callbackfn = args["0" , {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]}])
                      label ret :
                      {if (if (prim("stx=", prim("typeof", callbackfn) , "function"))
                              {false}
                              else
                              {true})
                          {%TypeError("Callback not a function in reduce")}
                          else
                          {null};
                       if (if (prim("stx=", len , 0.))
                              {prim("<", args["length" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}] , 2.)}
                              else
                              {false})
                          {%TypeError("Reducing an empty list with not enough arguments.")}
                          else
                          {null};
                       let (origK = 0.)
                       let (accumulator = if (prim(">=", args["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , 2.))
                                             {args["1" , {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]}]}
                                             else
                                             {rec (accumLoop = func(k)
                                                               {if (prim
                                                                    ("<", k , len))
                                                                   {let (Pk = %ToString
                                                                    (k))
                                                                    let (kPresent = prim
                                                                    ("hasProperty", O , Pk))
                                                                    if (kPresent)
                                                                    {origK := k;
                                                                    O[Pk , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]}
                                                                    else
                                                                    {accumLoop
                                                                    (prim
                                                                    ("+", k , 1.))}}
                                                                   else
                                                                   {%TypeError
                                                                    ("In Array reduce")}})
                                              accumLoop(0.)})
                       rec (outerLoop = func(k , accumulator)
                                        {if (prim("<", k , len))
                                            {let (Pk = %ToString(k))
                                             let (kPresent = prim("hasProperty", O , Pk))
                                             if (kPresent)
                                                {let (kValue = O[Pk , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                 let (argsObj = {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]})
                                                 {let ($newVal = accumulator)
                                                  argsObj["0" = $newVal ,
                                                          {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]
                                                           '0' : {#value ($newVal) ,
                                                                  #writable true ,
                                                                  #configurable true}}];
                                                  let ($newVal = kValue)
                                                  argsObj["1" = $newVal ,
                                                          {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]
                                                           '0' : {#value ($newVal) ,
                                                                  #writable true ,
                                                                  #configurable true}}];
                                                  let ($newVal = k)
                                                  argsObj["2" = $newVal ,
                                                          {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]
                                                           '0' : {#value ($newVal) ,
                                                                  #writable true ,
                                                                  #configurable true}}];
                                                  let ($newVal = O)
                                                  argsObj["3" = $newVal ,
                                                          {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]
                                                           '0' : {#value ($newVal) ,
                                                                  #writable true ,
                                                                  #configurable true}}];
                                                  let ($newVal = 4.)
                                                  argsObj["length" = $newVal ,
                                                          {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]
                                                           '0' : {#value ($newVal) ,
                                                                  #writable true ,
                                                                  #configurable true}}];
                                                  let (next = callbackfn
                                                                (undefined,
                                                                 argsObj))
                                                  outerLoop(prim("+", k , 1.),
                                                            next)}}
                                                else
                                                {outerLoop(prim("+", k , 1.),
                                                           accumulator)}}
                                            else
                                            {accumulator}})
                       break ret outerLoop(origK,
                                           accumulator)}})
let (%reduce = {[#proto: %FunctionProto,
                 #code: %reducelambda,
                 #class: "Object",
                 #extensible: true,]})
let (%everylambda = func(this , args)
                    {let (O = %ToObject(this))
                     let (lenValue = O["length" , {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]}])
                     let (len = %ToUint32(lenValue))
                     let (callbackfn = args["0" , {[#proto: null,
                                                    #class: "Object",
                                                    #extensible: true,]}])
                     label ret :
                     {if (if (prim("stx=", prim("typeof", callbackfn) , "function"))
                             {false}
                             else
                             {true})
                         {%TypeError("Callback not function in every")}
                         else
                         {null};
                      let (T = args["1" , {[#proto: null,
                                            #class: "Object",
                                            #extensible: true,]}])
                      rec (loop = func(k)
                                  {if (prim("<", k , len))
                                      {let (Pk = %ToString(k))
                                       let (kPresent = prim("hasProperty", O , Pk))
                                       if (kPresent)
                                          {let (kValue = O[Pk , {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]}])
                                           let (argsObj = {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]})
                                           {let ($newVal = kValue)
                                            argsObj["0" = $newVal ,
                                                    {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]
                                                     '0' : {#value ($newVal) ,
                                                            #writable true ,
                                                            #configurable true}}];
                                            let ($newVal = k)
                                            argsObj["1" = $newVal ,
                                                    {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]
                                                     '0' : {#value ($newVal) ,
                                                            #writable true ,
                                                            #configurable true}}];
                                            let ($newVal = O)
                                            argsObj["2" = $newVal ,
                                                    {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]
                                                     '0' : {#value ($newVal) ,
                                                            #writable true ,
                                                            #configurable true}}];
                                            let ($newVal = 3.)
                                            argsObj["length" = $newVal ,
                                                    {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]
                                                     '0' : {#value ($newVal) ,
                                                            #writable true ,
                                                            #configurable true}}];
                                            let (testResult = callbackfn
                                                                (T,
                                                                 argsObj))
                                            if (prim("stx=", %ToBoolean
                                                               (testResult) , false))
                                               {false}
                                               else
                                               {loop(prim("+", k , 1.))}}}
                                          else
                                          {loop(prim("+", k , 1.))}}
                                      else
                                      {true}})
                      break ret loop(0.)}})
let (%every = {[#proto: %FunctionProto,
                #code: %everylambda,
                #class: "Object",
                #extensible: true,]})
let (%somelambda = func(this , args)
                   {let (O = %ToObject(this))
                    let (lenValue = O["length" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                    let (len = %ToUint32(lenValue))
                    let (callbackfn = args["0" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                    label ret :
                    {if (if (prim("stx=", prim("typeof", callbackfn) , "function"))
                            {false}
                            else
                            {true})
                        {%TypeError("Callback not function in some")}
                        else
                        {null};
                     let (T = args["1" , {[#proto: null,
                                           #class: "Object",
                                           #extensible: true,]}])
                     rec (loop = func(k)
                                 {if (prim("<", k , len))
                                     {let (Pk = %ToString(k))
                                      let (kPresent = prim("hasProperty", O , Pk))
                                      if (kPresent)
                                         {let (kValue = O[Pk , {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]}])
                                          let (argsObj = {[#proto: null,
                                                           #class: "Object",
                                                           #extensible: true,]})
                                          {let ($newVal = kValue)
                                           argsObj["0" = $newVal ,
                                                   {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]
                                                    '0' : {#value ($newVal) ,
                                                           #writable true ,
                                                           #configurable true}}];
                                           let ($newVal = k)
                                           argsObj["1" = $newVal ,
                                                   {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]
                                                    '0' : {#value ($newVal) ,
                                                           #writable true ,
                                                           #configurable true}}];
                                           let ($newVal = O)
                                           argsObj["2" = $newVal ,
                                                   {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]
                                                    '0' : {#value ($newVal) ,
                                                           #writable true ,
                                                           #configurable true}}];
                                           let ($newVal = 3.)
                                           argsObj["length" = $newVal ,
                                                   {[#proto: null,
                                                     #class: "Object",
                                                     #extensible: true,]
                                                    '0' : {#value ($newVal) ,
                                                           #writable true ,
                                                           #configurable true}}];
                                           let (testResult = callbackfn
                                                               (T,
                                                                argsObj))
                                           if (prim("stx=", %ToBoolean
                                                              (testResult) , true))
                                              {true}
                                              else
                                              {loop(prim("+", k , 1.))}}}
                                         else
                                         {loop(prim("+", k , 1.))}}
                                     else
                                     {false}})
                     break ret loop(0.)}})
let (%some = {[#proto: %FunctionProto,
               #code: %somelambda,
               #class: "Object",
               #extensible: true,]})
let (%reduceRightLambda = func(this , args)
                          {let (O = %ToObject(this))
                           let (lenValue = O["length" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])
                           let (len = %ToUint32(lenValue))
                           let (callbackfn = args["0" , {[#proto: null,
                                                          #class: "Object",
                                                          #extensible: true,]}])
                           label ret :
                           {if (if (prim("stx=", prim("typeof", callbackfn) , "function"))
                                   {false}
                                   else
                                   {true})
                               {%TypeError("Callback not function in reduceRight")}
                               else
                               {null};
                            if (if (prim("stx=", len , 0.))
                                   {prim("<", args["length" , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}] , 2.)}
                                   else
                                   {false})
                               {%TypeError("Zero-length array in reduceRight")}
                               else
                               {null};
                            let (origK = prim("-", len , 1.))
                            let (accumulator = if (prim(">=", args["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , 2.))
                                                  {args["1" , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}]}
                                                  else
                                                  {rec (accumLoop = func(k)
                                                                    {if (prim
                                                                    (">=", k , 0.))
                                                                    {let (Pk = %ToString
                                                                    (k))
                                                                    let (kPresent = prim
                                                                    ("hasProperty", O , Pk))
                                                                    if (kPresent)
                                                                    {origK := k;
                                                                    O[Pk , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]}
                                                                    else
                                                                    {accumLoop
                                                                    (prim
                                                                    ("-", k , 1.))}}
                                                                    else
                                                                    {%TypeError
                                                                    ("reduceRight")}})
                                                   accumLoop(origK)})
                            rec (outerLoop = func(k , accumulator)
                                             {if (prim(">=", k , 0.))
                                                 {let (Pk = %ToString(k))
                                                  let (kPresent = prim
                                                                    ("hasProperty", O , Pk))
                                                  if (kPresent)
                                                     {let (kValue = O[Pk , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                      let (argsObj = {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]})
                                                      {let ($newVal = accumulator)
                                                       argsObj["0" = $newVal ,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                       let ($newVal = kValue)
                                                       argsObj["1" = $newVal ,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                       let ($newVal = k)
                                                       argsObj["2" = $newVal ,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                       let ($newVal = O)
                                                       argsObj["3" = $newVal ,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                       let ($newVal = 4.)
                                                       argsObj["length" = $newVal ,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}];
                                                       let (next = callbackfn
                                                                    (undefined,
                                                                    argsObj))
                                                       outerLoop(prim
                                                                   ("-", k , 1.),
                                                                 next)}}
                                                     else
                                                     {outerLoop(prim("-", k , 1.),
                                                                accumulator)}}
                                                 else
                                                 {accumulator}})
                            break ret outerLoop(origK,
                                                accumulator)}})
let (%reduceRight = {[#proto: %FunctionProto,
                      #code: %reduceRightLambda,
                      #class: "Object",
                      #extensible: true,]})
let (%slicelambda = func(this , args)
                    {let (O = %ToObject(this))
                     let (A = {[#proto: %ArrayProto,
                                #class: "Array",
                                #extensible: true,]
                               'length' : {#value (0.) ,
                                           #writable true ,
                                           #configurable false}})
                     let (lenVal = O["length" , {[#proto: null,
                                                  #class: "Object",
                                                  #extensible: true,]}])
                     let (len = %ToUint32(lenVal))
                     let (relativeStart = %ToInteger(args["0" , {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]}]))
                     let (initk = if (prim("<", relativeStart , 0.))
                                     {let (added = prim("+", len , relativeStart))
                                      if (prim(">", added , 0.))
                                         {added}
                                         else
                                         {0.}}
                                     else
                                     if (prim("<", relativeStart , len))
                                        {relativeStart}
                                        else
                                        {len})
                     let (relativeEnd = if (prim("stx=", args["1" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                           {len}
                                           else
                                           {%ToInteger(args["1" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                     let (final = if (prim("<", relativeEnd , 0.))
                                     {let (added = prim("+", len , relativeEnd))
                                      if (prim(">", added , 0.))
                                         {added}
                                         else
                                         {0.}}
                                     else
                                     if (prim("<", relativeEnd , len))
                                        {relativeEnd}
                                        else
                                        {len})
                     rec (loop = func(n , k , finalLen)
                                 {label ret :
                                  {if (prim(">=", k , final))
                                      {break ret finalLen}
                                      else
                                      {null};
                                   let (Pk = %ToString(k))
                                   let (kPresent = prim("hasProperty", O , Pk))
                                   if (kPresent)
                                      {let (kValue = O[Pk , {[#proto: null,
                                                              #class: "Object",
                                                              #extensible: true,]}])
                                       %defineOwnProperty(A,
                                                          %ToString(n),
                                                          {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]
                                                           'value' : {#value (kValue) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                           'writable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                           'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                           'enumerable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}});
                                       break ret loop(prim("+", n , 1.),
                                                      prim("+", k , 1.),
                                                      prim("+", finalLen , 1.))}
                                      else
                                      {break ret loop(prim("+", n , 1.),
                                                      prim("+", k , 1.),
                                                      prim("+", finalLen , 1.))}}})
                     {let ($newVal = loop(0.,
                                          initk,
                                          0.))
                      A["length" = $newVal ,
                        {[#proto: null, #class: "Object", #extensible: true,]
                         '0' : {#value ($newVal) ,
                                #writable true ,
                                #configurable true}}];
                      A}})
let (%slice = {[#proto: %FunctionProto,
                #code: %slicelambda,
                #class: "Object",
                #extensible: true,]})
let (%bindLambda = func(this , args)
                   {label ret :
                    {if (if (prim("stx=", prim("typeof", this) , "function"))
                            {false}
                            else
                            {true})
                        {%TypeError("this not function in bind")}
                        else
                        {null};
                     let (thisArg = args["0" , {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]}])
                     let (A = %slicelambda(args,
                                           %oneArgObj(1.)))
                     let (mkNewObj = func(proto)
                                     {let (proto = if (%IsObject(proto))
                                                      {proto}
                                                      else
                                                      {%ObjectProto})
                                      {[#proto: proto,
                                        #class: "Object",
                                        #extensible: true,]}})
                     let (Flambda = func(this_inner , args_inner)
                                    {let (thisArg = if (args_inner["%new" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                       {mkNewObj(this
                                                                   ["prototype" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])}
                                                       else
                                                       {thisArg})
                                     let (concatted = %concatLambda(A,
                                                                    args_inner))
                                     this(thisArg,
                                          concatted)})
                     let (F = {[#proto: %FunctionProto,
                                #code: Flambda,
                                #class: "Function",
                                #extensible: true,]})
                     let (addthrower = func(name)
                                       {%defineOwnProperty(F,
                                                           name,
                                                           {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]
                                                            'get' : {#value (%ThrowTypeError) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                            'set' : {#value (%ThrowTypeError) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                            'enumerable' : {#value (false) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                            'configurable' : {#value (false) ,
                                                                    #writable true ,
                                                                    #configurable false}})})
                     let (FLength = if (prim("stx=", this[<#class>] , "Function"))
                                       {let (L = prim("-", this["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , A["length" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                        %max(0.,
                                             L)}
                                       else
                                       {0.})
                     {%defineOwnProperty(F,
                                         "length",
                                         {[#proto: null,
                                           #class: "Object",
                                           #extensible: true,]
                                          'value' : {#value (FLength) ,
                                                     #writable true ,
                                                     #configurable false},
                                          'writable' : {#value (false) ,
                                                        #writable true ,
                                                        #configurable false},
                                          'enumerable' : {#value (false) ,
                                                          #writable true ,
                                                          #configurable false},
                                          'configurable' : {#value (false) ,
                                                            #writable true ,
                                                            #configurable false}});
                      addthrower("caller");
                      addthrower("arguments");
                      break ret F}}})
let (%bind = {[#proto: %FunctionProto,
               #code: %bindLambda,
               #class: "Object",
               #extensible: true,]})
let (%numToStringAbstract = func(n , r)
                            {rec (nts = func(n , r)
                                        {label ret :
                                         {if (if (prim("stx=", n , n))
                                                 {false}
                                                 else
                                                 {true})
                                             {break ret "NaN"}
                                             else
                                             {null};
                                          if (prim("stx=", n , 0.))
                                             {break ret "0"}
                                             else
                                             {null};
                                          if (prim("<", n , 0.))
                                             {let (negOne = prim("-", 0. , 1.))
                                              let (newN = prim("*", n , negOne))
                                              break ret prim("string+", "-" , nts
                                                                    (newN,
                                                                    r))}
                                             else
                                             {null};
                                          if (prim("stx=", n , +inf))
                                             {break ret "Infinity"}
                                             else
                                             {null};
                                          if (prim("stx=", r , 10.))
                                             {break ret prim("prim->str", n)}
                                             else
                                             {null};
                                          break ret prim("base", n , r)}})
                             nts(n,
                                 r)})
let (%numberToStringlambda = func(this , args)
                             {let (notNumProto = if (prim("stx=", this , %NumberProto))
                                                    {false}
                                                    else
                                                    {true})
                              if (if (notNumProto)
                                     {if (prim("stx=", this[<#proto>] , %NumberProto))
                                         {false}
                                         else
                                         {true}}
                                     else
                                     {false})
                                 {throw {[#proto: %TypeErrorProto,
                                          #class: "Object",
                                          #extensible: true,]}}
                                 else
                                 {let (rint = if (prim("stx=", args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                                 {10.}
                                                 else
                                                 {%ToInteger(args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                                  if (prim("stx=", rint , 10.))
                                     {%numToStringAbstract(this[<#primval>],
                                                           10.)}
                                     else
                                     if (prim("!", prim("stx=", prim("typeof", rint) , "number")))
                                        {throw "RangeError"}
                                        else
                                        if (let (%or = prim("<", rint , 2.))
                                            if (%or)
                                               {%or}
                                               else
                                               {prim(">", rint , 36.)})
                                           {throw "RangeError"}
                                           else
                                           {%numToStringAbstract(this
                                                                   [<#primval>],
                                                                 rint)}}})
let (%numberToString = {[#proto: %FunctionProto,
                         #code: %numberToStringlambda,
                         #class: "Function",
                         #extensible: true,]})
let (%StringIndexOflambda = func(this , args)
                            {%CheckObjectCoercible(this);
                             let (S = %ToString(this))
                             let (searchStr = %ToString(args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                             let (pos = %ToInteger(args["1" , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}]))
                             let (len = prim("strlen", S))
                             let (start = %min(%max(pos,
                                                    0.),
                                               len))
                             let (searchLen = prim("strlen", searchStr))
                             let (check_k = func(k)
                                            {rec (check_j = func(j)
                                                            {if (prim
                                                                   ("stx=", j , searchLen))
                                                                {true}
                                                                else
                                                                if (if (prim
                                                                    ("stx=", prim
                                                                    ("char-at", S , prim
                                                                    ("+", k , j)) , prim
                                                                    ("char-at", searchStr , j)))
                                                                    {false}
                                                                    else
                                                                    {true})
                                                                   {false}
                                                                   else
                                                                   {check_j
                                                                    (prim
                                                                    ("+", j , 1.))}})
                                             if (prim("!", prim("<=", prim
                                                                    ("+", k , searchLen) , len)))
                                                {false}
                                                else
                                                if (prim("!", check_j(0.)))
                                                   {false}
                                                   else
                                                   {true}})
                             rec (find_k = func(curr)
                                           {if (prim(">", prim("+", curr , searchLen) , len))
                                               {prim("-", 0. , 1.)}
                                               else
                                               if (check_k(curr))
                                                  {curr}
                                                  else
                                                  {find_k(prim("+", curr , 1.))}})
                             find_k(start)})
let (%StringIndexOf = {[#proto: %FunctionProto,
                        #code: %StringIndexOflambda,
                        #class: "Object",
                        #extensible: true,]})
let (%replacelambda = func(this , args)
                      {let (S = %ToString(this))
                       let (search = %ToString(args["0" , {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]}]))
                       let (replace = args["1" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                       if (if (prim("stx=", prim("typeof", replace) , "function"))
                              {false}
                              else
                              {true})
                          {throw "String.replace() only supports functions"}
                          else
                          {rec (loop = func(str)
                                       {let (start = %StringIndexOflambda
                                                       (str,
                                                        %oneArgObj(search)))
                                        if (prim("stx=", start , prim
                                                                   ("-", 0. , 1.)))
                                           {str}
                                           else
                                           {let (replaced = %ToString
                                                              (replace
                                                                 (undefined,
                                                                  %oneArgObj
                                                                    (replace))))
                                            let (before = %substringlambda
                                                            (str,
                                                             %twoArgObj
                                                               (0.,
                                                                start)))
                                            let (afterix = prim("+", start , prim
                                                                    ("strlen", search)))
                                            let (after = %substringlambda
                                                           (str,
                                                            %oneArgObj
                                                              (afterix)))
                                            prim("string+", before , prim
                                                                    ("string+", replaced , loop
                                                                    (after)))}})
                           loop(S)}})
let (%replace = {[#proto: %FunctionProto,
                  #code: %replacelambda,
                  #class: "Object",
                  #extensible: true,]})
let (%sliolambda = func(this , args)
                   {%CheckObjectCoercible(this);
                    let (S = %ToString(this))
                    let (searchStr = %ToString(args["0" , {[#proto: null,
                                                            #class: "Object",
                                                            #extensible: true,]}]))
                    let (numPos = %ToNumber(args["1" , {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]}]))
                    let (pos = if (if (prim("stx=", numPos , numPos))
                                      {false}
                                      else
                                      {true})
                                  {+inf}
                                  else
                                  {%ToInteger(numPos)})
                    let (len = prim("strlen", S))
                    let (start = %min(%max(pos,
                                           0.),
                                      len))
                    let (searchLen = prim("strlen", searchStr))
                    let (check_k = func(k)
                                   {rec (check_j = func(j)
                                                   {if (prim("stx=", j , searchLen))
                                                       {true}
                                                       else
                                                       if (if (prim("stx=", prim
                                                                    ("char-at", S , prim
                                                                    ("+", k , j)) , prim
                                                                    ("char-at", searchStr , j)))
                                                              {false}
                                                              else
                                                              {true})
                                                          {false}
                                                          else
                                                          {check_j(prim
                                                                    ("+", j , 1.))}})
                                    if (prim("!", prim("<=", prim("+", k , searchLen) , len)))
                                       {false}
                                       else
                                       if (prim("!", check_j(0.)))
                                          {false}
                                          else
                                          {true}})
                    rec (find_k = func(curr)
                                  {if (prim("<", curr , 0.))
                                      {prim("-", 0. , 1.)}
                                      else
                                      if (check_k(curr))
                                         {curr}
                                         else
                                         {find_k(prim("-", curr , 1.))}})
                    find_k(start)})
let (%StringLastIndexOf = {[#proto: %FunctionProto,
                            #code: %sliolambda,
                            #class: "Object",
                            #extensible: true,]})
let (%localeCompareLambda = func(this , args)
                            {%CheckObjectCoercible(this);
                             let (S = %ToString(this))
                             let (That = %ToString(args["0" , {[#proto: null,
                                                                #class: "Object",
                                                                #extensible: true,]}]))
                             prim("locale-compare", S , That)})
let (%localeCompare = {[#proto: %FunctionProto,
                        #code: %localeCompareLambda,
                        #class: "Object",
                        #extensible: true,]})
let (%stringSliceLambda = func(this , args)
                          {%CheckObjectCoercible(this);
                           let (S = %ToString(this))
                           let (len = prim("strlen", S))
                           let (intStart = %ToInteger(args["0" , {[#proto: null,
                                                                   #class: "Object",
                                                                   #extensible: true,]}]))
                           let (end = args["1" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                           let (intEnd = if (prim("stx=", end , undefined))
                                            {len}
                                            else
                                            {%ToInteger(end)})
                           let (from = if (prim("<", intStart , 0.))
                                          {%max(prim("+", len , intStart),
                                                0.)}
                                          else
                                          {%min(intStart,
                                                len)})
                           let (to = if (prim("<", intEnd , 0.))
                                        {%max(prim("+", len , intEnd),
                                              0.)}
                                        else
                                        {%min(intEnd,
                                              len)})
                           let (span = %max(prim("-", to , from),
                                            0.))
                           rec (build = func(i , result)
                                        {if (prim("<", i , span))
                                            {let (next = prim("string+", result , prim
                                                                    ("char-at", S , prim
                                                                    ("+", from , i))))
                                             build(prim("+", i , 1.),
                                                   next)}
                                            else
                                            {result}})
                           build(0.,
                                 "")})
let (%stringSlice = {[#proto: %FunctionProto,
                      #code: %stringSliceLambda,
                      #class: "Object",
                      #extensible: true,]})
let (%tlclambda = func(this , args)
                  {%CheckObjectCoercible(this);
                   let (S = %ToString(this))
                   prim("to-lower", S)})
let (%toLowerCase = {[#proto: %FunctionProto,
                      #code: %tlclambda,
                      #class: "Object",
                      #extensible: true,]})
let (%tuclambda = func(this , args)
                  {%CheckObjectCoercible(this);
                   let (S = %ToString(this))
                   prim("to-upper", S)})
let (%toUpperCase = {[#proto: %FunctionProto,
                      #code: %tuclambda,
                      #class: "Object",
                      #extensible: true,]})
let (%splitLambda = func(this , args)
                    {"String.prototype.split NYI"})
let (%split = {[#proto: %FunctionProto,
                #code: %splitLambda,
                #class: "Object",
                #extensible: true,]})
let (%IsFinite = func(n)
                 {prim("!", let (%or = let (%or = if (prim("stx=", n , n))
                                                     {false}
                                                     else
                                                     {true})
                                       if (%or)
                                          {%or}
                                          else
                                          {prim("stx=", n , +inf)})
                            if (%or)
                               {%or}
                               else
                               {prim("stx=", n , -inf)})})
let (%msPerDay = 86400000.)
let (%msPerHour = 3600000.)
let (%msPerMin = 60000.)
let (%msPerSecond = 1000.)
let (%Day = func(t)
            {prim("floor", prim("/", t , %msPerDay))})
let (%TimeWithinDay = func(t)
                      {prim("%", t , %msPerDay)})
let (%DaysInYear = func(y)
                   {if (if (prim("stx=", prim("%", y , 4.) , 0.))
                           {false}
                           else
                           {true})
                       {365.}
                       else
                       if (let (%or = prim("stx=", prim("%", y , 400.) , 0.))
                           if (%or)
                              {%or}
                              else
                              if (prim("stx=", prim("%", y , 100.) , 0.))
                                 {false}
                                 else
                                 {true})
                          {366.}
                          else
                          {365.}})
let (%DayFromYear = func(y)
                    {let (fragment = func(offset , coefficient)
                                     {prim("floor", prim("/", prim("-", y , offset) , coefficient))})
                     let (base = prim("*", 365. , prim("-", y , 1970.)))
                     let (part1 = fragment(1969.,
                                           4.))
                     let (part2 = fragment(1901.,
                                           100.))
                     let (part3 = fragment(1601.,
                                           400.))
                     prim("+", prim("-", prim("+", base , part1) , part2) , part3)})
let (%TimeFromYear = func(y)
                     {prim("*", %msPerDay , %DayFromYear(y))})
let (%YearFromTime = func(t)
                     {let (sign = if (prim(">", t , 0.))
                                     {1.}
                                     else
                                     {prim("-", 0. , 1.)})
                      let (start = if (prim("stx=", sign , 1.))
                                      {1969.}
                                      else
                                      {1970.})
                      rec (loop = func(y)
                                  {if (if (prim("<=", %TimeFromYear(y) , t))
                                          {prim(">", %TimeFromYear(prim
                                                                    ("+", 1. , y)) , t)}
                                          else
                                          {false})
                                      {y}
                                      else
                                      {loop(prim("+", y , sign))}})
                      loop(start)})
let (%DayWithinYear = func(t)
                      {prim("-", %Day(t) , %DayFromYear(%YearFromTime(t)))})
let (%InLeapYear = func(t)
                   {if (prim("stx=", %DaysInYear(%YearFromTime(t)) , 365.))
                       {0.}
                       else
                       {1.}})
let (%DaysInMonth = func(m , leap)
                    {let (m = prim("%", m , 12.))
                     if (let (%or = let (%or = let (%or = prim("stx=", m , 3.))
                                               if (%or)
                                                  {%or}
                                                  else
                                                  {prim("stx=", m , 5.)})
                                    if (%or)
                                       {%or}
                                       else
                                       {prim("stx=", m , 8.)})
                         if (%or)
                            {%or}
                            else
                            {prim("stx=", m , 10.)})
                        {30.}
                        else
                        if (prim("stx=", m , 1.))
                           {prim("+", 28. , leap)}
                           else
                           {31.}})
let (%MonthFromTime = func(t)
                      {let (DayWithinYear = func(t)
                                            {prim("-", %Day(t) , %DayFromYear
                                                                   (%YearFromTime
                                                                    (t)))})
                       let (CheckLeapRange = func(start , end)
                                             {if (prim("<=", prim("+", start , %InLeapYear
                                                                    (t)) , DayWithinYear
                                                                    (t)))
                                                 {prim("<", DayWithinYear(t) , prim
                                                                    ("+", end , %InLeapYear
                                                                    (t)))}
                                                 else
                                                 {false}})
                       if (if (prim("<=", 0. , %DayWithinYear(t)))
                              {prim("<", %DayWithinYear(t) , 31.)}
                              else
                              {false})
                          {0.}
                          else
                          if (if (prim("<=", 31. , %DayWithinYear(t)))
                                 {prim("<", %DayWithinYear(t) , prim("+", 59. , %InLeapYear
                                                                    (t)))}
                                 else
                                 {false})
                             {1.}
                             else
                             if (CheckLeapRange(59.,
                                                90.))
                                {2.}
                                else
                                if (CheckLeapRange(90.,
                                                   120.))
                                   {3.}
                                   else
                                   if (CheckLeapRange(120.,
                                                      151.))
                                      {4.}
                                      else
                                      if (CheckLeapRange(151.,
                                                         181.))
                                         {5.}
                                         else
                                         if (CheckLeapRange(181.,
                                                            212.))
                                            {6.}
                                            else
                                            if (CheckLeapRange(212.,
                                                               243.))
                                               {7.}
                                               else
                                               if (CheckLeapRange(243.,
                                                                  273.))
                                                  {8.}
                                                  else
                                                  if (CheckLeapRange(273.,
                                                                    304.))
                                                     {9.}
                                                     else
                                                     if (CheckLeapRange
                                                           (304.,
                                                            334.))
                                                        {10.}
                                                        else
                                                        if (CheckLeapRange
                                                              (334.,
                                                               365.))
                                                           {11.}
                                                           else
                                                           {%TypeError
                                                             ("Something terrible in date %MonthFromTime")}})
let (%DateFromTime = func(t)
                     {let (mft = %MonthFromTime(t))
                      let (CalcDay = func(offset)
                                     {prim("-", prim("-", %DayWithinYear(t) , offset) , %InLeapYear
                                                                    (t))})
                      if (prim("stx=", mft , 0.))
                         {prim("+", %DayWithinYear(t) , 1.)}
                         else
                         if (prim("stx=", mft , 1.))
                            {prim("-", %DayWithinYear(t) , 30.)}
                            else
                            if (prim("stx=", mft , 2.))
                               {CalcDay(58.)}
                               else
                               if (prim("stx=", mft , 3.))
                                  {CalcDay(89.)}
                                  else
                                  if (prim("stx=", mft , 4.))
                                     {CalcDay(119.)}
                                     else
                                     if (prim("stx=", mft , 5.))
                                        {CalcDay(150.)}
                                        else
                                        if (prim("stx=", mft , 6.))
                                           {CalcDay(180.)}
                                           else
                                           if (prim("stx=", mft , 7.))
                                              {CalcDay(211.)}
                                              else
                                              if (prim("stx=", mft , 8.))
                                                 {CalcDay(242.)}
                                                 else
                                                 if (prim("stx=", mft , 9.))
                                                    {CalcDay(272.)}
                                                    else
                                                    if (prim("stx=", mft , 10.))
                                                       {CalcDay(303.)}
                                                       else
                                                       if (prim("stx=", mft , 11.))
                                                          {CalcDay(333.)}
                                                          else
                                                          {%TypeError
                                                            ("Something terrible happened in %DateFromTime")}})
let (%LocalTime = func(t)
                  {t})
let (%MakeDate = func(day , time)
                 {prim("+", prim("*", day , %msPerDay) , time)})
let (%MakeDay = func(yr , mt , date)
                {if (prim("!", if (if (%IsFinite(yr))
                                      {%IsFinite(mt)}
                                      else
                                      {false})
                                  {%IsFinite(date)}
                                  else
                                  {false}))
                    {NaN}
                    else
                    {let (y = %ToInteger(yr))
                     let (m = %ToInteger(mt))
                     let (dt = %ToInteger(date))
                     let (ym = prim("+", y , prim("floor", prim("/", m , 12.))))
                     let (mn = prim("%", m , 12.))
                     let (yt = %TimeFromYear(y))
                     rec (loop = func(t , mo , leap)
                                 {if (prim("<", mo , m))
                                     {let (leap = %InLeapYear(t))
                                      let (t = prim("+", t , prim("*", %DaysInMonth
                                                                    (mo,
                                                                    leap) , %msPerDay)))
                                      loop(t,
                                           prim("+", mo , 1.),
                                           leap)}
                                     else
                                     {t}})
                     let (t = loop(yt,
                                   0.,
                                   %InLeapYear(yt)))
                     if (let (%or = let (%or = if (prim("stx=", %YearFromTime
                                                                  (t) , ym))
                                                  {false}
                                                  else
                                                  {true})
                                    if (%or)
                                       {%or}
                                       else
                                       if (prim("stx=", %MonthFromTime(t) , mn))
                                          {false}
                                          else
                                          {true})
                         if (%or)
                            {%or}
                            else
                            if (prim("stx=", %DateFromTime(t) , 1.))
                               {false}
                               else
                               {true})
                        {NaN}
                        else
                        {prim("-", prim("+", %Day(t) , dt) , 1.)}}})
let (%MakeTime = func(h , m , s , ms)
                 {if (prim("!", if (if (if (%IsFinite(h))
                                           {%IsFinite(m)}
                                           else
                                           {false})
                                       {%IsFinite(s)}
                                       else
                                       {false})
                                   {%IsFinite(ms)}
                                   else
                                   {false}))
                     {NaN}
                     else
                     {let (hour = %ToInteger(h))
                      let (min = %ToInteger(m))
                      let (sec = %ToInteger(s))
                      let (millis = %ToInteger(ms))
                      let (t = prim("+", prim("+", prim("+", prim("*", hour , %msPerHour) , prim
                                                                    ("*", min , %msPerMin)) , prim
                                                                    ("*", sec , %msPerSecond)) , millis))
                      t}})
let (%UTC = func(t)
            {t})
let (%getYearlambda = func(this , args)
                      {78.})
let (%getYear = {[#proto: null,
                  #code: %getYearlambda,
                  #class: "Object",
                  #extensible: true,]})
let (%getMonthlambda = func(this , args)
                       {3.})
let (%getMonth = {[#proto: null,
                   #code: %getMonthlambda,
                   #class: "Object",
                   #extensible: true,]})
let (%DateProto = {[#proto: %ObjectProto, #class: "Date", #extensible: true,]
                   'getYear' : {#value (%getYear) ,
                                #writable false ,
                                #configurable false},
                   'getMonth' : {#value (%getMonth) ,
                                 #writable false ,
                                 #configurable false}})
let (%dateToStringLambda = func(this , args)
                           {"Date toString NYI"})
let (%dateToString = {[#proto: %FunctionProto,
                       #code: %dateToStringLambda,
                       #class: "Object",
                       #extensible: true,]})
let (%dateValueOfLambda = func(this , args)
                          {this[<#primval>]})
let (%dateValueOf = {[#proto: %FunctionProto,
                      #code: %dateValueOfLambda,
                      #class: "Object",
                      #extensible: true,]})
let (%TimeClip = func(t)
                 {if (prim("!", if (%IsFinite(t))
                                   {prim("<=", prim("abs", t) , 8.64e+15)}
                                   else
                                   {false}))
                     {NaN}
                     else
                     {%ToInteger(t)}})
let (%DateConstructor = func(this , args)
                        {let (calledAsFunction = prim("stx=", this , undefined))
                         let (nargs = args["length" , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}])
                         if (calledAsFunction)
                            {let (v = %getCurrentUTC())
                             let (o = {[#proto: %DateProto,
                                        #class: "Date",
                                        #extensible: true,]})
                             %dateToStringLambda(o,
                                                 {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]})}
                            else
                            if (prim("stx=", nargs , 0.))
                               {let (v = %getCurrentUTC())
                                {[#proto: %DateProto,
                                  #class: "Date",
                                  #extensible: true,]}}
                               else
                               if (prim("stx=", nargs , 1.))
                                  {let (v = %ToPrimitive(args["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                   let (V = if (prim("stx=", prim("typeof", v) , "string"))
                                               {%parse(v)}
                                               else
                                               {%ToNumber(v)})
                                   let (clipped = %TimeClip(V))
                                   {[#proto: %DateProto,
                                     #class: "Date",
                                     #extensible: true,]}}
                                  else
                                  {let (y = %ToNumber(args["0" , {[#proto: null,
                                                                   #class: "Object",
                                                                   #extensible: true,]}]))
                                   let (m = %ToNumber(args["1" , {[#proto: null,
                                                                   #class: "Object",
                                                                   #extensible: true,]}]))
                                   let (dt = if (prim("stx=", args["2" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                                {1.}
                                                else
                                                {%ToNumber(args["2" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                                   let (h = if (prim("stx=", args["3" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                               {0.}
                                               else
                                               {%ToNumber(args["3" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                                   let (min = if (prim("stx=", args["4" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                                 {0.}
                                                 else
                                                 {%ToNumber(args["4" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                                   let (s = if (prim("stx=", args["5" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                               {0.}
                                               else
                                               {%ToNumber(args["5" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                                   let (milli = if (prim("stx=", args
                                                                   ["6" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}] , undefined))
                                                   {0.}
                                                   else
                                                   {%ToNumber(args["6" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])})
                                   let (yr = let (tiy = %ToInteger(y))
                                             let (rangecond1 = let (%or = prim
                                                                    ("<", 0. , tiy))
                                                               if (%or)
                                                                  {%or}
                                                                  else
                                                                  {prim
                                                                    ("stx=", 0. , tiy)})
                                             let (rangecond2 = let (%or = prim
                                                                    ("<", tiy , 99.))
                                                               if (%or)
                                                                  {%or}
                                                                  else
                                                                  {prim
                                                                    ("stx=", tiy , 99.)})
                                             if (if (if (if (prim("stx=", y , y))
                                                            {false}
                                                            else
                                                            {true})
                                                        {rangecond1}
                                                        else
                                                        {false})
                                                    {rangecond2}
                                                    else
                                                    {false})
                                                {prim("+", 1900. , tiy)}
                                                else
                                                {y})
                                   let (finalDate = %MakeDate(%MakeDay
                                                                (yr,
                                                                 m,
                                                                 dt),
                                                              %MakeTime
                                                                (h,
                                                                 min,
                                                                 s,
                                                                 milli)))
                                   let (primval = %TimeClip(%UTC(finalDate)))
                                   {[#proto: %DateProto,
                                     #class: "Date",
                                     #extensible: true,]}}})
let (%DateGlobalFuncObj = {[#proto: %FunctionProto,
                            #code: %DateConstructor,
                            #class: "Object",
                            #extensible: true,]
                           'prototype' : {#value (%DateProto) ,
                                          #writable true ,
                                          #configurable false}})
let (%dateGetTimezoneOffsetLambda = func(this , args)
                                    {let (t = this[<#primval>])
                                     if (prim("stx=", t , NaN))
                                        {NaN}
                                        else
                                        {0.}})
let (%dateGetTimezoneOffset = {[#proto: %FunctionProto,
                                #code: %dateGetTimezoneOffsetLambda,
                                #class: "Object",
                                #extensible: true,]})
let (%dategetDayLambda = func(this , args)
                         {let (day = prim("floor", prim("/", this[<#primval>] , %msPerDay)))
                          let (weekday = prim("%", prim("+", day , 4.) , 7.))
                          weekday})
let (%dategetDay = {[#proto: %FunctionProto,
                     #code: %dategetDayLambda,
                     #class: "Object",
                     #extensible: true,]})
let (%dategetDateLambda = func(this , args)
                          {let (t = this[<#primval>])
                           if (prim("stx=", t , NaN))
                              {t}
                              else
                              {%DateFromTime(%LocalTime(t))}})
let (%dategetDate = {[#proto: %FunctionProto,
                      #code: %dategetDateLambda,
                      #class: "Object",
                      #extensible: true,]})
let (%defineNYIProperty = func(base , name)
                          {let (unimplFunc = func(this , args)
                                             {%TypeError(prim("string+", name , " NYI"))})
                           let (unimplObj = {[#proto: %FunctionProto,
                                              #code: unimplFunc,
                                              #class: "Object",
                                              #extensible: true,]})
                           %define15Property(base,
                                             name,
                                             unimplObj)})
let (%testlambda = func(this , args)
                   {prim("print", "You used the es5.env testlambda.  Are you sure you didn't forget to include the regexp.js library, or regexp.env?")})
let (%test = {[#proto: null,
               #code: %testlambda,
               #class: "Object",
               #extensible: true,]})
let (%RegExpProto = {[#proto: %ObjectProto,
                      #class: "Object",
                      #extensible: true,]
                     'test' : {#value (%test) ,
                               #writable false ,
                               #configurable false}})
let (%RegExpConstructor = func(this , args)
                          {{[#proto: %RegExpProto,
                             #class: "Object",
                             #extensible: true,]}})
let (%RegExpGlobalFuncObj = {[#proto: %FunctionProto,
                              #code: %RegExpConstructor,
                              #class: "Object",
                              #extensible: true,]
                             'prototype' : {#value (%RegExpProto) ,
                                            #writable false ,
                                            #configurable false},
                             'length' : {#value (2.) ,
                                         #writable false ,
                                         #configurable false}})
let (%parseIntlambda = func(this , args)
                       {let (numstr = %ToString(args["0" , {[#proto: null,
                                                             #class: "Object",
                                                             #extensible: true,]}]))
                        prim("numstr->num", numstr)})
let (%parseInt = {[#proto: %FunctionProto,
                   #code: %parseIntlambda,
                   #class: "Object",
                   #extensible: true,]})
let (%decodeURILambda = func(this , args)
                        {"decodeURI NYI"})
let (%decodeURI = {[#proto: %FunctionProto,
                    #code: %decodeURILambda,
                    #class: "Object",
                    #extensible: true,]})
let (%decodeURIComponentLambda = func(this , args)
                                 {"decodeURIComponent NYI"})
let (%decodeURIComponent = {[#proto: %FunctionProto,
                             #code: %decodeURIComponentLambda,
                             #class: "Object",
                             #extensible: true,]})
let (%encodeURILambda = func(this , args)
                        {"encodeURI NYI"})
let (%encodeURI = {[#proto: %FunctionProto,
                    #code: %encodeURILambda,
                    #class: "Object",
                    #extensible: true,]})
let (%encodeURIComponentLambda = func(this , args)
                                 {"encodeURIComponent NYI"})
let (%encodeURIComponent = {[#proto: %FunctionProto,
                             #code: %encodeURIComponentLambda,
                             #class: "Object",
                             #extensible: true,]})
let (%explambda = func()
                  {undefined})
let (%exp = {[#proto: null,
              #code: %explambda,
              #class: "Object",
              #extensible: true,]})
let (%Math = {[#proto: null, #class: "Object", #extensible: true,]
              'E' : {#value (2.71828182846) ,
                     #writable false ,
                     #configurable false},
              'LN10' : {#value (2.30258509299) ,
                        #writable false ,
                        #configurable false},
              'LN2' : {#value (0.69314718056) ,
                       #writable false ,
                       #configurable false},
              'LOG2E' : {#value (1.44269504089) ,
                         #writable false ,
                         #configurable false},
              'LOG10E' : {#value (0.434294481903) ,
                          #writable false ,
                          #configurable false},
              'PI' : {#value (3.14159265359) ,
                      #writable false ,
                      #configurable false},
              'SQRT1_2' : {#value (0.707106781187) ,
                           #writable false ,
                           #configurable false},
              'SQRT2' : {#value (1.41421356237) ,
                         #writable false ,
                         #configurable false},
              'exp' : {#value (%exp) , #writable false , #configurable false}})
let (%minMaxLambda = func(this , args , op , init)
                     {let (end = args["length" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}])
                      label ret :
                      {if (prim("stx=", end , 0.))
                          {break ret init}
                          else
                          {null};
                       rec (loop = func(best , i)
                                   {if (prim("<", i , end))
                                       {let (curr = %ToNumber(args[prim
                                                                    ("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                        if (if (prim("stx=", curr , curr))
                                               {false}
                                               else
                                               {true})
                                           {break ret NaN}
                                           else
                                           {null};
                                        loop(op(best,
                                                curr),
                                             prim("+", i , 1.))}
                                       else
                                       {best}})
                       break ret loop(init,
                                      0.)}})
let (%mathMinLambda = func(this , args)
                      {%minMaxLambda(this,
                                     args,
                                     %min,
                                     +inf)})
let (%mathMin = {[#proto: %FunctionProto,
                  #code: %mathMinLambda,
                  #class: "Object",
                  #extensible: true,]})
let (%mathMaxLambda = func(this , args)
                      {%minMaxLambda(this,
                                     args,
                                     %max,
                                     -inf)})
let (%mathMax = {[#proto: %FunctionProto,
                  #code: %mathMaxLambda,
                  #class: "Object",
                  #extensible: true,]})
let (%mathAbsLambda = func(this , args)
                      {let (n = %ToNumber(args["0" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]))
                       label ret :
                       {if (if (prim("stx=", n , n))
                               {false}
                               else
                               {true})
                           {break ret n}
                           else
                           {null};
                        if (prim("stx=", n , -inf))
                           {break ret +inf}
                           else
                           {null};
                        break ret prim("abs", n)}})
let (%mathAbs = {[#proto: %FunctionProto,
                  #code: %mathAbsLambda,
                  #class: "Object",
                  #extensible: true,]})
let (%acosLambda = func(this , args)
                   {"acos NYI"})
let (%acos = {[#proto: %FunctionProto,
               #code: %acosLambda,
               #class: "Object",
               #extensible: true,]})
let (%asinLambda = func(this , args)
                   {"asin NYI"})
let (%asin = {[#proto: %FunctionProto,
               #code: %asinLambda,
               #class: "Object",
               #extensible: true,]})
let (%atanLambda = func(this , args)
                   {"atan NYI"})
let (%atan = {[#proto: %FunctionProto,
               #code: %atanLambda,
               #class: "Object",
               #extensible: true,]})
let (%atan2Lambda = func(this , args)
                    {"atan2 NYI"})
let (%atan2 = {[#proto: %FunctionProto,
                #code: %atan2Lambda,
                #class: "Object",
                #extensible: true,]})
let (%cosLambda = func(this , args)
                  {"cos NYI"})
let (%cos = {[#proto: %FunctionProto,
              #code: %cosLambda,
              #class: "Object",
              #extensible: true,]})
let (%randomLambda = func(this , args)
                     {4.})
let (%random = {[#proto: %FunctionProto,
                 #code: %randomLambda,
                 #class: "Object",
                 #extensible: true,]})
let (%roundLambda = func(this , args)
                    {"round NYI"})
let (%round = {[#proto: %FunctionProto,
                #code: %roundLambda,
                #class: "Object",
                #extensible: true,]})
let (%sinLambda = func(this , args)
                  {let (n = %ToNumber(args["0" , {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]}]))
                   label ret :
                   {if (if (prim("stx=", n , n))
                           {false}
                           else
                           {true})
                       {break ret n}
                       else
                       {null};
                    if (prim("stx=", n , 0.))
                       {break ret n}
                       else
                       {null};
                    if (prim("stx=", n , +inf))
                       {break ret NaN}
                       else
                       {null};
                    if (prim("stx=", n , -inf))
                       {break ret NaN}
                       else
                       {null};
                    break ret prim("sin", n)}})
let (%sin = {[#proto: %FunctionProto,
              #code: %sinLambda,
              #class: "Object",
              #extensible: true,]})
let (%sqrtLambda = func(this , args)
                   {"sqrt NYI"})
let (%sqrt = {[#proto: %FunctionProto,
               #code: %sqrtLambda,
               #class: "Object",
               #extensible: true,]})
let (%tanLambda = func(this , args)
                  {"tan NYI"})
let (%tan = {[#proto: %FunctionProto,
              #code: %tanLambda,
              #class: "Object",
              #extensible: true,]})
let (%mathLogLambda = func(this , args)
                      {let (n = %ToNumber(args["0" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]))
                       label ret :
                       {if (if (prim("stx=", n , n))
                               {false}
                               else
                               {true})
                           {break ret n}
                           else
                           {null};
                        if (prim("<", n , 0.))
                           {break ret NaN}
                           else
                           {null};
                        if (prim("stx=", n , 0.))
                           {break ret -inf}
                           else
                           {null};
                        if (prim("stx=", n , 1.))
                           {break ret 0.}
                           else
                           {null};
                        if (prim("stx=", n , +inf))
                           {break ret n}
                           else
                           {null};
                        break ret prim("log", n)}})
let (%mathLog = {[#proto: %FunctionProto,
                  #code: %mathLogLambda,
                  #class: "Object",
                  #extensible: true,]})
let (%mathCeilLambda = func(this , args)
                       {let (x = %ToNumber(args["0" , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}]))
                        label ret :
                        {if (let (%or = let (%or = let (%or = if (prim
                                                                    ("stx=", x , x))
                                                                 {false}
                                                                 else
                                                                 {true})
                                                   if (%or)
                                                      {%or}
                                                      else
                                                      {prim("stx=", x , 0.)})
                                        if (%or)
                                           {%or}
                                           else
                                           {prim("stx=", x , -inf)})
                             if (%or)
                                {%or}
                                else
                                {prim("stx=", x , +inf)})
                            {break ret x}
                            else
                            {null};
                         break ret prim("ceil", x)}})
let (%mathCeil = {[#proto: %FunctionProto,
                   #code: %mathCeilLambda,
                   #class: "Object",
                   #extensible: true,]})
let (%mathFloorLambda = func(this , args)
                        {let (x = %ToNumber(args["0" , {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]}]))
                         label ret :
                         {if (let (%or = let (%or = let (%or = if (prim
                                                                    ("stx=", x , x))
                                                                  {false}
                                                                  else
                                                                  {true})
                                                    if (%or)
                                                       {%or}
                                                       else
                                                       {prim("stx=", x , 0.)})
                                         if (%or)
                                            {%or}
                                            else
                                            {prim("stx=", x , -inf)})
                              if (%or)
                                 {%or}
                                 else
                                 {prim("stx=", x , +inf)})
                             {break ret x}
                             else
                             {null};
                          break ret prim("floor", x)}})
let (%mathFloor = {[#proto: %FunctionProto,
                    #code: %mathFloorLambda,
                    #class: "Object",
                    #extensible: true,]})
let (%PrimAdd = func(l , r)
                {let (l = %ToPrimitive(l))
                 let (r = %ToPrimitive(r))
                 if (prim("stx=", prim("typeof", l) , "string"))
                    {let (lstr = prim("prim->str", l))
                     let (rstr = prim("prim->str", r))
                     prim("string+", lstr , rstr)}
                    else
                    if (prim("stx=", prim("typeof", r) , "string"))
                       {let (lstr = prim("prim->str", l))
                        let (rstr = prim("prim->str", r))
                        prim("string+", lstr , rstr)}
                       else
                       {let (lnum = prim("prim->num", l))
                        let (rnum = prim("prim->num", r))
                        prim("+", lnum , rnum)}})
let (%PrefixOp = func(obj , fld , op)
                 {let (oldValue = %ToNumber(obj[fld , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}]))
                  let (newValue = op(oldValue,
                                     1.))
                  {let ($newVal = newValue)
                   obj[fld = $newVal ,
                       {[#proto: null, #class: "Object", #extensible: true,]
                        '0' : {#value ($newVal) ,
                               #writable true ,
                               #configurable true}}];
                   newValue}})
let (%PrefixIncrement = func(obj , fld)
                        {%PrefixOp(obj,
                                   fld,
                                   %PrimAdd)})
let (%mathPowLambda = func(this , args)
                      {let (x = %ToNumber(args["0" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]))
                       let (y = %ToNumber(args["1" , {[#proto: null,
                                                       #class: "Object",
                                                       #extensible: true,]}]))
                       label ret :
                       {if (if (prim("stx=", y , y))
                               {false}
                               else
                               {true})
                           {break ret NaN}
                           else
                           {null};
                        if (prim("stx=", y , 0.))
                           {break ret 1.}
                           else
                           {null};
                        if (if (if (prim("stx=", x , x))
                                   {false}
                                   else
                                   {true})
                               {if (prim("stx=", y , 0.))
                                   {false}
                                   else
                                   {true}}
                               else
                               {false})
                           {break ret NaN}
                           else
                           {null};
                        let (absX = prim("abs", x))
                        {if (if (prim(">", absX , 1.))
                                {prim("stx=", y , +inf)}
                                else
                                {false})
                            {break ret +inf}
                            else
                            {null};
                         if (if (prim(">", absX , 1.))
                                {prim("stx=", y , -inf)}
                                else
                                {false})
                            {break ret 0.}
                            else
                            {null};
                         if (if (prim("stx=", absX , 1.))
                                {let (%or = prim("stx=", y , +inf))
                                 if (%or)
                                    {%or}
                                    else
                                    {prim("stx=", y , -inf)}}
                                else
                                {false})
                            {break ret NaN}
                            else
                            {null};
                         if (if (prim("<", absX , 1.))
                                {prim("stx=", y , +inf)}
                                else
                                {false})
                            {break ret 0.}
                            else
                            {null};
                         if (if (prim("<", absX , 1.))
                                {prim("stx=", y , -inf)}
                                else
                                {false})
                            {break ret +inf}
                            else
                            {null};
                         if (if (prim("stx=", x , +inf))
                                {prim(">", y , 0.)}
                                else
                                {false})
                            {break ret +inf}
                            else
                            {null};
                         if (if (prim("stx=", x , +inf))
                                {prim("<", y , 0.)}
                                else
                                {false})
                            {break ret 0.}
                            else
                            {null};
                         let (isOdd = func(n)
                                      {let (divided = prim("/", n , 2.))
                                       if (prim("stx=", prim("floor", n) , n))
                                          {if (prim("stx=", prim("floor", divided) , divided))
                                              {false}
                                              else
                                              {true}}
                                          else
                                          {false}})
                         {if (if (prim("stx=", x , -inf))
                                 {prim(">", y , 0.)}
                                 else
                                 {false})
                             {break ret if (isOdd(y))
                                           {-inf}
                                           else
                                           {+inf}}
                             else
                             {null};
                          if (if (prim("stx=", x , -inf))
                                 {prim("<", y , 0.)}
                                 else
                                 {false})
                             {break ret 0.}
                             else
                             {null};
                          if (if (prim("stx=", x , 0.))
                                 {prim(">", y , 0.)}
                                 else
                                 {false})
                             {break ret 0.}
                             else
                             {null};
                          if (if (prim("stx=", x , 0.))
                                 {prim("<", y , 0.)}
                                 else
                                 {false})
                             {break ret +inf}
                             else
                             {null};
                          let (oddY = isOdd(y))
                          if (if (if (prim("stx=", x , 0.))
                                     {prim("<", y , 0.)}
                                     else
                                     {false})
                                 {oddY}
                                 else
                                 {false})
                             {break ret -inf}
                             else
                             {null};
                          if (if (prim("stx=", x , 0.))
                                 {prim("<", y , 0.)}
                                 else
                                 {false})
                             {break ret +inf}
                             else
                             {null};
                          let (isFinite = func(n)
                                          {if (if (prim("stx=", n , +inf))
                                                  {false}
                                                  else
                                                  {true})
                                              {if (prim("stx=", n , -inf))
                                                  {false}
                                                  else
                                                  {true}}
                                              else
                                              {false}})
                          let (finiteX = isFinite(x))
                          let (finiteY = isFinite(y))
                          if (if (if (if (prim("<", x , 0.))
                                         {finiteX}
                                         else
                                         {false})
                                     {finiteY}
                                     else
                                     {false})
                                 {if (prim("stx=", prim("floor", y) , y))
                                     {false}
                                     else
                                     {true}}
                                 else
                                 {false})
                             {break ret NaN}
                             else
                             {null};
                          break ret prim("pow", x , y)}}}})
let (%mathPow = {[#proto: %FunctionProto,
                  #code: %mathPowLambda,
                  #class: "Object",
                  #extensible: true,]})
let (%valueOfLambda = func(this , args , proto , typestr)
                      {let (hasWrongProto = if (prim("stx=", this[<#proto>] , proto))
                                               {false}
                                               else
                                               {true})
                       let (hasWrongTypeof = if (prim("stx=", prim("typeof", this) , typestr))
                                                {false}
                                                else
                                                {true})
                       let (isntProto = if (prim("stx=", this , proto))
                                           {false}
                                           else
                                           {true})
                       if (if (if (hasWrongProto)
                                  {hasWrongTypeof}
                                  else
                                  {false})
                              {isntProto}
                              else
                              {false})
                          {%TypeError("valueOf")}
                          else
                          if (hasWrongTypeof)
                             {this[<#primval>]}
                             else
                             {this}})
let (%stringValueOf = {[#proto: %FunctionProto,
                        #code: func(this , args)
                               {%valueOfLambda(this,
                                               args,
                                               %StringProto,
                                               "string")},
                        #class: "Object",
                        #extensible: true,]})
let (%numValueOf = {[#proto: %FunctionProto,
                     #code: func(this , args)
                            {%valueOfLambda(this,
                                            args,
                                            %NumberProto,
                                            "number")},
                     #class: "Object",
                     #extensible: true,]})
let (%booleanValueOf = {[#proto: %FunctionProto,
                         #code: func(this , args)
                                {%valueOfLambda(this,
                                                args,
                                                %BooleanProto,
                                                "boolean")},
                         #class: "Object",
                         #extensible: true,]})
let (%toFixedLambda = func(this , args)
                      {let (f = %ToInteger(args["0" , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}]))
                       label ret :
                       {if (let (%or = prim("<", f , 0.))
                            if (%or)
                               {%or}
                               else
                               {prim(">", f , 20.)})
                           {throw %JSError({[#proto: %RangeErrorProto,
                                             #class: "Object",
                                             #extensible: true,]})}
                           else
                           {null};
                        let (x = if (prim("stx=", prim("typeof", this) , "number"))
                                    {this}
                                    else
                                    {this[<#primval>]})
                        if (if (prim("stx=", x , x))
                               {false}
                               else
                               {true})
                           {break ret "NaN"}
                           else
                           {null};
                        if (prim(">=", x , 1e+21))
                           {break ret %ToString(x)}
                           else
                           {null};
                        break ret prim("to-fixed", x , f)}})
let (%toFixed = {[#proto: %FunctionProto,
                  #code: %toFixedLambda,
                  #class: "Object",
                  #extensible: true,]})
let (%numTLSLambda = func(this , args)
                     {let (x = if (prim("stx=", prim("typeof", this) , "number"))
                                  {this}
                                  else
                                  {this[<#primval>]})
                      let (obj = {[#proto: %StringProto,
                                   #class: "Object",
                                   #extensible: true,]})
                      %toLocaleStringLambda(obj,
                                            {[#proto: null,
                                              #class: "Object",
                                              #extensible: true,]})})
let (%numTLS = {[#proto: %FunctionProto,
                 #code: %numTLSLambda,
                 #class: "Object",
                 #extensible: true,]})
let (%toExponentialLambda = func(this , args)
                            {"toExponential NYI"})
let (%toExponential = {[#proto: %FunctionProto,
                        #code: %toExponentialLambda,
                        #class: "Object",
                        #extensible: true,]})
let (%toPrecisionLambda = func(this , args)
                          {"toPrecision NYI"})
let (%toPrecision = {[#proto: %FunctionProto,
                      #code: %toPrecisionLambda,
                      #class: "Object",
                      #extensible: true,]})
let (%PrimSub = func(l , r)
                {let (l = %ToNumber(l))
                 let (r = %ToNumber(r))
                 prim("-", l , r)})
let (%BitwiseAnd = func(l , r)
                   {prim("&", %ToInt32(l) , %ToInt32(r))})
let (%SignedRightShift = func(l , r)
                         {prim(">>", %ToInt32(l) , %ToUint32(r))})
let (%LeftShift = func(l , r)
                  {prim("<<", %ToInt32(l) , %ToUint32(r))})
let (%UnsignedRightShift = func(l , r)
                           {prim(">>>", %ToUint32(l) , %ToUint32(r))})
let (%PrefixDecrement = func(obj , fld)
                        {%PrefixOp(obj,
                                   fld,
                                   %PrimSub)})
let (%PostfixOp = func(obj , fld , op)
                  {let (oldValue = %ToNumber(obj[fld , {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]}]))
                   let (newValue = op(oldValue,
                                      1.))
                   {let ($newVal = newValue)
                    obj[fld = $newVal ,
                        {[#proto: null, #class: "Object", #extensible: true,]
                         '0' : {#value ($newVal) ,
                                #writable true ,
                                #configurable true}}];
                    oldValue}})
let (%PostDecrement = func(obj , fld)
                      {%PostfixOp(obj,
                                  fld,
                                  %PrimSub)})
let (%PostIncrement = func(obj , fld)
                      {%PostfixOp(obj,
                                  fld,
                                  %PrimAdd)})
let (%PrimMultOp = func(l , r , op)
                   {let (lNum = %ToNumber(l))
                    let (rNum = %ToNumber(r))
                    op(lNum,
                       rNum)})
let (%CompareOp = func(l , r , LeftFirst)
                  {let (rest = func(px , py)
                               {let (pxtype = prim("typeof", px))
                                let (pytype = prim("typeof", py))
                                label ret :
                                {if (let (%or = if (prim("stx=", pxtype , "string"))
                                                   {false}
                                                   else
                                                   {true})
                                     if (%or)
                                        {%or}
                                        else
                                        if (prim("stx=", pytype , "string"))
                                           {false}
                                           else
                                           {true})
                                    {let (nx = %ToNumber(px))
                                     let (ny = %ToNumber(py))
                                     {if (let (%or = if (prim("stx=", nx , nx))
                                                        {false}
                                                        else
                                                        {true})
                                          if (%or)
                                             {%or}
                                             else
                                             if (prim("stx=", ny , ny))
                                                {false}
                                                else
                                                {true})
                                         {break ret undefined}
                                         else
                                         {null};
                                      if (prim("stx=", nx , ny))
                                         {break ret false}
                                         else
                                         {null};
                                      if (prim("stx=", nx , +inf))
                                         {break ret false}
                                         else
                                         {null};
                                      if (prim("stx=", ny , +inf))
                                         {break ret true}
                                         else
                                         {null};
                                      if (prim("stx=", ny , -inf))
                                         {break ret false}
                                         else
                                         {null};
                                      if (prim("stx=", nx , -inf))
                                         {break ret true}
                                         else
                                         {null};
                                      break ret prim("<", nx , ny)}}
                                    else
                                    {break ret prim("string<", px , py)}}})
                   if (LeftFirst)
                      {let (px = %ToPrimitiveHint(l,
                                                  "number"))
                       let (py = %ToPrimitiveHint(r,
                                                  "number"))
                       rest(px,
                            py)}
                      else
                      {let (py = %ToPrimitiveHint(r,
                                                  "number"))
                       let (px = %ToPrimitiveHint(l,
                                                  "number"))
                       rest(px,
                            py)}})
let (%LessThan = func(l , r)
                 {let (result = %CompareOp(l,
                                           r,
                                           true))
                  if (prim("stx=", result , undefined))
                     {false}
                     else
                     {result}})
let (%GreaterThan = func(l , r)
                    {let (result = %CompareOp(r,
                                              l,
                                              false))
                     if (prim("stx=", result , undefined))
                        {false}
                        else
                        {result}})
let (%LessEqual = func(l , r)
                  {let (result = %CompareOp(r,
                                            l,
                                            false))
                   if (if (prim("stx=", result , undefined))
                          {false}
                          else
                          {true})
                      {prim("!", result)}
                      else
                      {false}})
let (%GreaterEqual = func(l , r)
                     {let (result = %CompareOp(l,
                                               r,
                                               true))
                      if (if (prim("stx=", result , undefined))
                             {false}
                             else
                             {true})
                         {prim("!", result)}
                         else
                         {false}})
let (%BitwiseInfix = func(l , r , op)
                     {let (lnum = %ToInt32(l))
                      let (rnum = %ToInt32(r))
                      op(lnum,
                         rnum)})
let (%EnvCheckAssign = func(context , id , val , strict)
                       {if (if (%isUnbound(context,
                                           id))
                               {strict}
                               else
                               {false})
                           {throw %JSError({[#proto: %ReferenceErrorProto,
                                             #class: "Object",
                                             #extensible: true,]
                                            'message' : {#value (id) ,
                                                         #writable true ,
                                                         #configurable false}})}
                           else
                           {try
                            {%set-property(context,
                                           id,
                                           val)}
                            catch
                            {%UnwritableDispatch(id)}}})
let (%UnaryPlus = func(expr)
                  {%ToNumber(expr)})
let (%UnaryNeg = func(expr)
                 {let (oldValue = %ToNumber(expr))
                  if (if (prim("stx=", oldValue , oldValue))
                         {false}
                         else
                         {true})
                     {oldValue}
                     else
                     {let (negOne = prim("-", 0. , 1.))
                      prim("*", oldValue , negOne)}})
let (%BitwiseNot = func(expr)
                   {let (oldValue = %ToInt32(expr))
                    prim("~", oldValue)})
let (%logLambda = func(o , s)
                  {rec (loop = func(i)
                               {if (prim("hasProperty", s , prim("prim->str", i)))
                                   {prim("pretty", s[prim("prim->str", i) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]);
                                    loop(prim("+", i , 1.))}
                                   else
                                   {undefined}})
                   loop(0.)})
let (%log = {[#proto: %FunctionProto,
              #code: %logLambda,
              #class: "Object",
              #extensible: true,]})
let (%console = {[#proto: null, #class: "Object", #extensible: true,]
                 'log' : {#value (%log) ,
                          #writable false ,
                          #configurable false},
                 'info' : {#value (%log) ,
                           #writable false ,
                           #configurable false},
                 'warn' : {#value (%log) ,
                           #writable false ,
                           #configurable false},
                 'error' : {#value (%log) ,
                            #writable false ,
                            #configurable false}})
let (%makeContextVarDefiner = func()
                              {let (envstore = {[#proto: null,
                                                 #class: "Object",
                                                 #extensible: true,]})
                               func(context , id)
                               {let (envstore = if (prim("stx=", context , %globalContext))
                                                   {%global}
                                                   else
                                                   {envstore})
                                if (prim("hasOwnProperty", context , id))
                                   {if (prim("!", prim("hasProperty", envstore , id)))
                                       {let ($newVal = undefined)
                                        envstore[id = $newVal ,
                                                 {[#proto: null,
                                                   #class: "Object",
                                                   #extensible: true,]
                                                  '0' : {#value ($newVal) ,
                                                         #writable true ,
                                                         #configurable true}}]}
                                       else
                                       {undefined};
                                    undefined}
                                   else
                                   {let ($newVal = undefined)
                                    envstore[id = $newVal ,
                                             {[#proto: null,
                                               #class: "Object",
                                               #extensible: true,]
                                              '0' : {#value ($newVal) ,
                                                     #writable true ,
                                                     #configurable true}}];
                                    let (%setter = {[#proto: null,
                                                     #code: func(this , args)
                                                            {if (prim
                                                                   ("hasProperty", envstore , id))
                                                                {let ($newVal = args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                                 envstore
                                                                   [id = $newVal ,
                                                                    {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]
                                                                    '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}]}
                                                                else
                                                                {%UnboundId
                                                                  (id)}},
                                                     #class: "Object",
                                                     #extensible: true,]})
                                    let (%getter = {[#proto: null,
                                                     #code: func(this , args)
                                                            {if (prim
                                                                   ("hasProperty", envstore , id))
                                                                {envstore
                                                                  [id , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]}
                                                                else
                                                                {%UnboundId
                                                                  (id)}},
                                                     #class: "Object",
                                                     #extensible: true,]})
                                    %defineOwnProperty(context,
                                                       id,
                                                       {[#proto: null,
                                                         #class: "Object",
                                                         #extensible: true,]
                                                        'get' : {#value (%getter) ,
                                                                 #writable true ,
                                                                 #configurable false},
                                                        'set' : {#value (%setter) ,
                                                                 #writable true ,
                                                                 #configurable false}})}}})
let (%configurableEval = func(evalThis , evalContext , useStrict , args)
                         {let (evalStr = args["0" , {[#proto: null,
                                                      #class: "Object",
                                                      #extensible: true,]}])
                          let (evalStr = if (useStrict)
                                            {prim("string+", "'use strict';" , evalStr)}
                                            else
                                            {evalStr})
                          let (globalEnv = %makeGlobalEnv())
                          {let ($newVal = evalThis)
                           globalEnv["%this" = $newVal ,
                                     {[#proto: null,
                                       #class: "Object",
                                       #extensible: true,]
                                      '0' : {#value ($newVal) ,
                                             #writable true ,
                                             #configurable true}}];
                           let ($newVal = {[#proto: evalContext,
                                            #class: "Object",
                                            #extensible: true,]})
                           globalEnv["%strictContext" = $newVal ,
                                     {[#proto: null,
                                       #class: "Object",
                                       #extensible: true,]
                                      '0' : {#value ($newVal) ,
                                             #writable true ,
                                             #configurable true}}];
                           let ($newVal = evalContext)
                           globalEnv["%nonstrictContext" = $newVal ,
                                     {[#proto: null,
                                       #class: "Object",
                                       #extensible: true,]
                                      '0' : {#value ($newVal) ,
                                             #writable true ,
                                             #configurable true}}];
                           let ($newVal = %makeContextVarDefiner())
                           globalEnv["%defineGlobalVar" = $newVal ,
                                     {[#proto: null,
                                       #class: "Object",
                                       #extensible: true,]
                                      '0' : {#value ($newVal) ,
                                             #writable true ,
                                             #configurable true}}];
                           if (prim("stx=", prim("typeof", evalStr) , "string"))
                              {@eval(evalStr , globalEnv)}
                              else
                              {evalStr}}})
let (%evallambda = func(this , args)
                   {%configurableEval(%global,
                                      %globalContext,
                                      false,
                                      args)})
let (%eval = {[#proto: null,
               #code: %evallambda,
               #class: "Object",
               #extensible: true,]})
let (%maybeDirectEval = func(theThis , theContext , args , strict)
                        {let (contextEval = theContext["eval" , {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]}])
                         if (prim("stx=", contextEval , %eval))
                            {%configurableEval(theThis,
                                               theContext,
                                               strict,
                                               args)}
                            else
                            {%AppExprCheck(contextEval,
                                           args)}})
let (%FunctionConstructor = func(this , args)
                            {let (argCount = args["length" , {[#proto: null,
                                                               #class: "Object",
                                                               #extensible: true,]}])
                             rec (formArgString = func(n , result)
                                                  {if (prim("stx=", n , prim
                                                                    ("-", argCount , 1.)))
                                                      {result}
                                                      else
                                                      {let (currentArg = %ToString
                                                                    (args
                                                                    [prim
                                                                    ("prim->str", n) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]))
                                                       let (next = if (prim
                                                                    ("stx=", n , prim
                                                                    ("-", argCount , 2.)))
                                                                    {prim
                                                                    ("string+", result , currentArg)}
                                                                    else
                                                                    {prim
                                                                    ("string+", prim
                                                                    ("string+", result , currentArg) , ",")})
                                                       formArgString(prim
                                                                    ("+", n , 1.),
                                                                    next)}})
                             let (body = if (prim("stx=", argCount , 0.))
                                            {""}
                                            else
                                            {args[prim("prim->str", prim
                                                                    ("-", argCount , 1.)) , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]})
                             let (P = if (let (%or = prim("stx=", argCount , 0.))
                                          if (%or)
                                             {%or}
                                             else
                                             {prim("stx=", argCount , 1.)})
                                         {""}
                                         else
                                         {formArgString(0.,
                                                        "")})
                             let (prefix = prim("string+", "((function(){ return function (" , prim
                                                                    ("string+", P , "){")))
                             let (final = prim("string+", prefix , prim
                                                                    ("string+", body , "}; })());")))
                             %evallambda(undefined,
                                         {[#proto: null,
                                           #class: "Object",
                                           #extensible: true,]
                                          '0' : {#value (final) ,
                                                 #writable false ,
                                                 #configurable false}})})
let (%FunctionGlobalFuncObj = {[#proto: %FunctionProto,
                                #code: %FunctionConstructor,
                                #class: "Object",
                                #extensible: true,]
                               'prototype' : {#value (%FunctionProto) ,
                                              #writable false ,
                                              #configurable false},
                               'length' : {#value (0.) ,
                                           #writable false ,
                                           #configurable false}})
let (%isFiniteLambda = func(this , args)
                       {let (n = %ToNumber(args["0" , {[#proto: null,
                                                        #class: "Object",
                                                        #extensible: true,]}]))
                        %IsFinite(n)})
let (%isFinite = {[#proto: %FunctionProto,
                   #code: %isFiniteLambda,
                   #class: "Object",
                   #extensible: true,]})
let (%parseFloatLambda = func(this , args)
                         {"parseFloat NYI"})
let (%parseFloat = {[#proto: %FunctionProto,
                     #code: %parseFloatLambda,
                     #class: "Object",
                     #extensible: true,]})
let (%escapeLambda = func(this , args)
                     {"escape NYI"})
let (%escape = {[#proto: %FunctionProto,
                 #code: %escapeLambda,
                 #class: "Object",
                 #extensible: true,]})
let (%unescapeLambda = func(this , args)
                       {"unescape NYI"})
let (%unescape = {[#proto: %FunctionProto,
                   #code: %unescapeLambda,
                   #class: "Object",
                   #extensible: true,]})
let (%makeWithContext = func(context , object)
                        {let (names = %propertyNames(object,
                                                     true))
                         let (mksetter = func(id)
                                         {{[#proto: null,
                                            #code: func(this , args)
                                                   {if (prim("hasProperty", object , id))
                                                       {let ($newVal = args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                        object[id = $newVal ,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}]}
                                                       else
                                                       {let ($newVal = args
                                                                    ["0" , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}])
                                                        context[id = $newVal ,
                                                                {[#proto: null,
                                                                  #class: "Object",
                                                                  #extensible: true,]
                                                                 '0' : {#value ($newVal) ,
                                                                    #writable true ,
                                                                    #configurable true}}]}},
                                            #class: "Object",
                                            #extensible: true,]}})
                         let (mkgetter = func(id)
                                         {{[#proto: null,
                                            #code: func(this , args)
                                                   {if (prim("hasProperty", object , id))
                                                       {object[id , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]}
                                                       else
                                                       {context[id , {[#proto: null,
                                                                    #class: "Object",
                                                                    #extensible: true,]}]}},
                                            #class: "Object",
                                            #extensible: true,]}})
                         let (newcontext = {[#proto: context,
                                             #class: "Object",
                                             #extensible: true,]})
                         let (addBinding = func(id)
                                           {%defineOwnProperty(newcontext,
                                                               id,
                                                               {[#proto: null,
                                                                 #class: "Object",
                                                                 #extensible: true,]
                                                                'set' : {#value (mksetter
                                                                    (id)) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                                'get' : {#value (mkgetter
                                                                    (id)) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                                'configurable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false},
                                                                'enumerable' : {#value (true) ,
                                                                    #writable true ,
                                                                    #configurable false}})})
                         {%primEach(names,
                                    addBinding);
                          newcontext}})
let (%this = %global)
let (%strictContext = %globalContext)
let (%nonstrictContext = %globalContext)
let (%context = %nonstrictContext)
let (#strict = false)
"success"
